
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.2.3, mkdocs-material-7.3.6">
    
    
      
        <title>autoware_reference_system/test/dropped_messages.py - Reference System Documentation</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.a57b2b03.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.3f5d1f46.min.css">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
    
      


    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
  
    
    <script>function __prefix(e){return new URL("../..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#autoware_reference_systemtestdropped_messagespy" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Reference System Documentation" class="md-header__button md-logo" aria-label="Reference System Documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Reference System Documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              autoware_reference_system/test/dropped_messages.py
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Reference System Documentation" class="md-nav__button md-logo" aria-label="Reference System Documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    Reference System Documentation
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../Pages/md_README" class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../Reports" class="md-nav__link">
        Reports
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../Classes" class="md-nav__link">
        Classes
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../Namespaces" class="md-nav__link">
        Namespaces
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../Modules" class="md-nav__link">
        Modules
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        Files
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../Pages" class="md-nav__link">
        Related Pages
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#namespaces" class="md-nav__link">
    Namespaces
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#source-code" class="md-nav__link">
    Source code
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="autoware_reference_systemtestdropped_messagespy">autoware_reference_system/test/dropped_messages.py</h1>
<h2 id="namespaces">Namespaces</h2>
<table>
<thead>
<tr>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><a href="/reference-system/Namespaces/namespacedropped__messages/">dropped_messages</a></strong></td>
</tr>
</tbody>
</table>
<h2 id="source-code">Source code</h2>
<pre><code class="language-python"># Copyright 2021 Apex.AI, Inc.
#
# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import os
import random

from bokeh.io import output_file
# from bokeh.layouts import layout
from bokeh.models import ColumnDataSource
from bokeh.models import DatetimeTickFormatter
from bokeh.models.ranges import FactorRange
from bokeh.models.tools import HoverTool
from bokeh.models.widgets.markups import Div
from bokeh.models.widgets.tables import DataTable, TableColumn
from bokeh.palettes import cividis
from bokeh.plotting import figure
from bokeh.transform import factor_cmap
import networkx as nx
import numpy as np
import pandas as pd

from trace_utils import initDataModel
from utils import getDirPath


def summary(path, duration, size):
    fname = path + 'dropped_messages_and_latency_summary_' + duration + 's'
    print('Output report to ' + fname + '.html')
    output_file(
        filename=fname + '.html',
        title='Dropped Messages and Latency Summary Report ' + duration + 's')
    data_dict = {}
    for fname in os.listdir(path):
        fpath = path + fname
        # load tracing data
        data_model = initDataModel(fpath)
        wd = getDirPath(fpath)

        tmp_name = wd.find('_rmw')
        exe = fname[0:tmp_name]
        rmw = fname[tmp_name + 1:-(len(duration) + 2)]

        try:
            data_dict[exe]
        except KeyError:
            data_dict[exe] = {}
        try:
            data_dict[exe][rmw]
        except KeyError:
            data_dict[exe][rmw] = {}

        data_dict[exe][rmw] = parseData(data_model)
    x = []
    for exe in data_dict:
        for rmw in data_dict[exe]:
            x.append((exe, rmw))
            # print(data_dict[exe][rmw]['dropped'])


def individual(data_model, size):
    data_dict = parseData(data_model)
    dropped_df = data_dict['dropped']
    latency_df = data_dict['latency']
    run_time = data_dict['run_time']

    y = list(zip(dropped_df.node, dropped_df.topic))

    latency_source = ColumnDataSource(latency_df)
    dropped_source = ColumnDataSource(dropped_df)

    dropped_source.data['y'] = y
    # use this for axis of figure ~0.25 of buffer
    max_dropped = max(dropped_df['dropped']) + 0.25
    # initialize figure
    dropped_fig = figure(
        title='Dropped Messages Summary ({:.2f} s) [UNDER DEVELOPMENT]'.format(float(run_time)),
        y_axis_label='Callback by Node and Topic Name',
        x_axis_label='Dropped Messages',
        y_range=FactorRange(*y),
        x_range=(0, max_dropped),
        plot_width=int(size * 2.0),
        plot_height=size,
        margin=(10, 10, 10, 10)
    )
    # add horizontal bar to figure
    dropped_fig.hbar(
        y='y',
        right='dropped',
        width=0.1,
        source=dropped_source,
        fill_color=factor_cmap(
            'y',
            palette=cividis(dropped_df['topic'].shape[0]),
            factors=list(dropped_df['topic'].values.tolist()),
            start=1, end=2)
    )
    dropped_fig.yaxis.major_label_orientation = 'horizontal'
    dropped_fig.yaxis.subgroup_label_orientation = 'horizontal'
    dropped_fig.yaxis.group_label_orientation = 'horizontal'
    # add hover tool
    hover = HoverTool()
    hover.tooltips = [
        ('Callback (Node and Topic)', '@node @topic'),
        ('Dropped', '@dropped'),
        ('Expected', '@expected_count'),
        ('Received', '@count')
    ]
    dropped_fig.add_tools(hover)

    # add dropped messages table
    dropped_summary = dropped_df.describe().T.reset_index()
    columns = [TableColumn(field=col, title=col) for col in dropped_summary]
    dropped_table_title = Div(
        text='&lt;b&gt;Dropped Messages Summary Table [UNDER DEVELOPMENT]&lt;/b&gt;',
        width=1000,
        height=10
    )
    dropped_table = [
        dropped_table_title,
        DataTable(
            columns=columns,
            source=ColumnDataSource(dropped_summary),
            margin=(10, 10, 10, 10),
            height=150,
            width=size)]

    # add latency plot
    latency_fig = figure(
        title='Latency From Front Lidar to Collision Estimator [UNDER DEVELOPMENT]',
        x_axis_label='Time',
        y_axis_label='Latency to Object Collision Estimator (ms)',
        plot_width=int(size * 2.0),
        plot_height=size,
        margin=(10, 10, 10, 10)
    )
    latency_fig.line(
        x='timestamp',
        y='latency',
        source=latency_source,
        line_width=2
    )
    latency_fig.xaxis[0].formatter = DatetimeTickFormatter(seconds=['%Ss'])

    # add latency table
    latency_summary = latency_df.describe().T.reset_index()
    columns = [TableColumn(field=col, title=col) for col in latency_summary]
    latency_table_title = Div(
        text='&lt;b&gt;Latency Summary Table&lt;/b&gt;',
        width=1000,
        height=10
    )
    latency_table = [
        latency_table_title,
        DataTable(
            columns=columns,
            source=ColumnDataSource(latency_summary),
            margin=(10, 10, 10, 10),
            height=75,
            width=size)]
    return [
        [dropped_table], [dropped_fig],
        [latency_table], [latency_fig]
    ]


def parseData(data_model):
    callback_symbols = data_model.get_callback_symbols()
    colors = []  # Adds random colors for each callback
    color_i = 0
    earliest_date = None
    latest_date = None
    dropped_data = []
    front_lidar_data = pd.DataFrame()
    object_collision_data = pd.DataFrame()
    for obj, symbol in callback_symbols.items():
        callback_df = data_model.get_callback_durations(obj)
        # get node information and filter out internal subscriptions
        owner_info = data_model.get_callback_owner_info(obj)
        if owner_info is not None:
            if '/parameter_events' in owner_info:
                continue
            period = 0.0
            if 'period' in owner_info:
                # assume in milliseconds so convert to seconds
                period = float(owner_info[
                    owner_info.find('period: ') + len('period: '):owner_info.rfind(' ')]) / 1000
            if 'FrontLidarDriver' in owner_info and 'Timer' in owner_info:
                front_lidar_data = callback_df
            if 'ObjectCollisionEstimator' in owner_info:
                object_collision_data = callback_df

        # add color to list if needed
        if(len(colors) &lt;= color_i):
            colors.append('#%06X' % random.randint(0, 256**3-1))
        # get human readable name of callback
        substr = 'node: '
        index = str.find(owner_info, substr)
        if index &gt;= 0:
            index += len(substr)
            node = owner_info[index:(str.find(owner_info, ','))]
        substr = 'topic: /'
        index = str.find(owner_info, substr)
        if index &gt;= 0:
            index += len(substr)
            topic = owner_info[index:]
        else:
            topic = ''
        # get first and last timestamp of data
        thefirstdate = callback_df.loc[:, 'timestamp'].iloc[0]
        if earliest_date is None:
            earliest_date = thefirstdate
        elif earliest_date is not None and thefirstdate &lt;= earliest_date:
            earliest_date = thefirstdate
        thelastdate = callback_df.loc[:, 'timestamp'].iloc[len(callback_df)-1]
        if latest_date is None:
            latest_date = thelastdate
        elif latest_date is not None and thelastdate &gt;= latest_date:
            latest_date = thelastdate
        # add name of callback and count to list
        dropped_data.append(
            [str(node), str(topic), float(len(callback_df)), period, 0.0, 0.0, colors[color_i]])
        color_i += 1

    front_lidar_data = front_lidar_data.reset_index(drop=True)
    object_collision_data = object_collision_data.reset_index(drop=True)

    # ensure dataframes are same length for latency calc, drop extra lidar frames
    extra = len(front_lidar_data) - len(object_collision_data)
    if(extra &gt; 0):
        front_lidar_data.drop(front_lidar_data.tail(extra).index, inplace=True)
    latency = object_collision_data['timestamp'] - front_lidar_data['timestamp']
    dropped_df = pd.DataFrame(
        dropped_data,
        columns=['node', 'topic', 'count', 'period', 'dropped', 'expected_count', 'color'])
    latency_df = pd.DataFrame(
        {'index': range(0, len(latency)),
         'latency': latency,
         'timestamp': front_lidar_data['timestamp']})
    # sort values by node and topic
    dropped_df = dropped_df.sort_values(by=['node', 'topic'])
    # generate node graph
    node_graph = generateNodeGraph(dropped_df)
    # calculate run time
    approx_run_time = None
    if earliest_date is not None and latest_date is not None:
        approx_run_time = getRunTime(earliest_date, latest_date)
    # calculate estimated count and received count
    dropped_df = calcTotals(approx_run_time, dropped_df)
    # count expected and dropped messages
    dropped_df = countDropped(dropped_df, node_graph)
    # prepare output
    data_dict = {
        'dropped': dropped_df,
        'latency': latency_df,
        'node_graph': node_graph,
        'start': earliest_date,
        'end': latest_date,
        'run_time': approx_run_time,
    }
    return data_dict


def getRunTime(start, end):
    # calculate run time in seconds for experiment
    return (end - start).total_seconds()


def calcTotals(run_time, dataframe):
    # calculate expected counts for each period
    mask = (dataframe['period'] != 0)
    period_non_zero = dataframe[mask]
    dataframe.loc[mask, 'expected_count'] = (run_time / period_non_zero['period']).apply(np.floor)
    return dataframe


def generateNodeGraph(dataframe):
    connections = []
    # for every node that has a defined period
    for node in dataframe.node:
        # assume node has sub nodes by default
        sub_node_exists = True
        # search for sub nodes of current node, assume node name is topic name
        current_node = node  # current top-level node of fork
        fork_topics = []
        sub_topics = []
        in_fork = False
        while sub_node_exists:
            if(len(fork_topics) != 0 and not in_fork):
                # fork topic exists
                current_node = fork_topics.pop(0)
                in_fork = True
            if(len(sub_topics) != 0):
                # sub topics still exist
                current_node = sub_topics.pop(0)
            sub_node_df = dataframe.loc[
                ((dataframe.topic == current_node) &amp;
                 (dataframe.expected_count == 0))]
            if not sub_node_df.empty:
                # node has sub node(s)
                if(sub_node_df.shape[0] &gt; 1):
                    # node has more than one sub node
                    for fork in sub_node_df.node:
                        if fork not in fork_topics:
                            fork_topics.append(fork)
                for sub_node in sub_node_df.node:
                    # add to list of tuples
                    connections.append((current_node, sub_node))
                    if not dataframe.loc[dataframe.topic == sub_node].empty:
                        if sub_node not in sub_topics:
                            sub_topics.append(sub_node)
                    else:
                        # no sub nodes
                        if(in_fork):
                            in_fork = False
                            continue
                        sub_node_exists = False
            else:
                # no sub nodes
                if(in_fork):
                    in_fork = False
                    continue
                sub_node_exists = False
    # generate DAG from list of tuples
    graph = nx.DiGraph()
    graph.add_edges_from(connections)
    return graph


def countDropped(dataframe, node_graph):
    mask = (dataframe['expected_count'] != 0)
    expected_non_zero = dataframe[mask]
    # for every node that has a defined period
    for node in expected_non_zero.node:
        # assume node has sub nodes by default
        sub_node_exists = True
        # search for sub nodes of current node, assume node name is topic name
        current_node = node  # current top-level node of fork
        fork_topics = []
        sub_topics = []
        in_fork = False
        # pred = len(node_graph.pred[node])
        # if(pred &gt; 0):
        # TODO(flynneva): figure out a way to trace up the node graph
        # to determine if a fusion node reduces the total expected
        # count = expected_non_zero.expected_count.sum()
        # expected = count - dataframe.loc[(
        #     (dataframe.node == node) &amp;
        #     (dataframe.topic == '')),
        #    'expected_count'].values[0]
        # subtract front lidar expected count due to fusion node
        # TODO(flynneva): figure out a better way to handle fusion nodes
        # expected -= dataframe.loc[(
        #    (dataframe.node == 'FrontLidarDriver') &amp;
        #    (dataframe.topic == '')),
        #   'expected_count'].values[0]
        # else:
        # calculate dropped for current node
        expected = dataframe.loc[(
            (dataframe.node == node) &amp;
            (dataframe.topic == '')),
            'expected_count'].values[0]
        count = dataframe.loc[(
            (dataframe.node == current_node) &amp;
            (dataframe.topic == '')), 'count'].values[0]
        dataframe.loc[(
            (dataframe.node == current_node) &amp;
            (dataframe.topic == '')), 'dropped'] = abs(expected - count)
        while sub_node_exists:
            if(len(fork_topics) != 0 and not in_fork):
                # fork topic exists
                current_node = fork_topics.pop(0)
                in_fork = True
            if(len(sub_topics) != 0):
                # sub topics still exist
                current_node = sub_topics.pop(0)
            sub_node_df = dataframe.loc[
                ((dataframe.topic == current_node) &amp;
                 (dataframe.expected_count == 0))]
            if not sub_node_df.empty:
                # node has sub node(s)
                if(sub_node_df.shape[0] &gt; 1):
                    # node has more than one sub node
                    for fork in sub_node_df.node:
                        if fork not in fork_topics:
                            fork_topics.append(fork)
                for sub_node in sub_node_df.node:
                    dataframe.loc[(
                        (dataframe.node == sub_node) &amp;
                        (dataframe.topic == current_node)), 'expected_count'] = expected
                    count = dataframe.loc[(
                        (dataframe.node == sub_node) &amp;
                        (dataframe.topic == current_node)), 'count'].values[0]
                    dataframe.loc[(
                        (dataframe.node == sub_node) &amp;
                        (dataframe.topic == current_node)), 'dropped'] = abs(expected - count)
                    if not dataframe.loc[dataframe.topic == sub_node].empty:
                        if sub_node not in sub_topics:
                            sub_topics.append(sub_node)
                    else:
                        # no sub nodes
                        if(in_fork):
                            in_fork = False
                            continue
                        sub_node_exists = False
            else:
                # no sub nodes
                if(in_fork):
                    in_fork = False
                    continue
                sub_node_exists = False
    return dataframe
</code></pre>
<hr />
<p>Updated on 2021-12-24 at 10:47:52 -0800</p>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
        
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        
          Made with
          <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
            Material for MkDocs
          </a>
        
        
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../..", "features": [], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "search": "../../assets/javascripts/workers/search.fcfe8b6d.min.js", "version": {"provider": "mike", "default": "stable"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.b1047164.min.js"></script>
      
    
  </body>
</html>