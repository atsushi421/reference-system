{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"Classes/","text":"Classes struct RclcppSystem class TestNodeGraph namespace callback_duration namespace constants namespace dropped_messages namespace errors class UnsupportedTraceTypeError namespace generate_callback_traces class TestGenerateTracesAutowareReferenceSystem namespace generate_reports namespace generate_std_traces class TestGenerateTracesAutowareReferenceSystem namespace generate_summary_reports namespace memory_usage namespace nodes struct CommandSettings struct CyclicSettings struct FusionSettings struct IntersectionSettings struct Connection struct SensorSettings struct TransformSettings namespace rclcpp_system class Command class Cyclic struct subscription_t class Fusion struct subscription_t class Intersection struct Connection class Sensor class Transform namespace timing struct BenchmarkCPUUsage struct BenchmarkThroughput struct Default namespace rclcpp namespace reference_interfaces namespace msg struct Message4kb namespace Message4kb_Constants struct TransmissionStats namespace TransmissionStats_Constants struct sample_statistic_t struct statistic_value_t namespace std::chrono_literals namespace std_latency namespace test_platform namespace test_requirements class TestRequirementsAutowareReferenceSystem namespace testing namespace trace_utils namespace unittest namespace utils Updated on 2021-12-24 at 17:45:36 +0000","title":"Classes"},{"location":"Classes/#classes","text":"struct RclcppSystem class TestNodeGraph namespace callback_duration namespace constants namespace dropped_messages namespace errors class UnsupportedTraceTypeError namespace generate_callback_traces class TestGenerateTracesAutowareReferenceSystem namespace generate_reports namespace generate_std_traces class TestGenerateTracesAutowareReferenceSystem namespace generate_summary_reports namespace memory_usage namespace nodes struct CommandSettings struct CyclicSettings struct FusionSettings struct IntersectionSettings struct Connection struct SensorSettings struct TransformSettings namespace rclcpp_system class Command class Cyclic struct subscription_t class Fusion struct subscription_t class Intersection struct Connection class Sensor class Transform namespace timing struct BenchmarkCPUUsage struct BenchmarkThroughput struct Default namespace rclcpp namespace reference_interfaces namespace msg struct Message4kb namespace Message4kb_Constants struct TransmissionStats namespace TransmissionStats_Constants struct sample_statistic_t struct statistic_value_t namespace std::chrono_literals namespace std_latency namespace test_platform namespace test_requirements class TestRequirementsAutowareReferenceSystem namespace testing namespace trace_utils namespace unittest namespace utils Updated on 2021-12-24 at 17:45:36 +0000","title":"Classes"},{"location":"Classes/classTestNodeGraph/","text":"TestNodeGraph Inherits from testing::Test Public Functions Name void SetUp () void TearDown () Public Functions Documentation function SetUp inline void SetUp() function TearDown inline void TearDown() Updated on 2021-12-24 at 17:45:36 +0000","title":"TestNodeGraph"},{"location":"Classes/classTestNodeGraph/#testnodegraph","text":"Inherits from testing::Test","title":"TestNodeGraph"},{"location":"Classes/classTestNodeGraph/#public-functions","text":"Name void SetUp () void TearDown ()","title":"Public Functions"},{"location":"Classes/classTestNodeGraph/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classTestNodeGraph/#function-setup","text":"inline void SetUp()","title":"function SetUp"},{"location":"Classes/classTestNodeGraph/#function-teardown","text":"inline void TearDown() Updated on 2021-12-24 at 17:45:36 +0000","title":"function TearDown"},{"location":"Classes/classerrors_1_1UnsupportedTraceTypeError/","text":"errors::UnsupportedTraceTypeError Inherits from Exception Updated on 2021-12-24 at 17:45:36 +0000","title":"errors::UnsupportedTraceTypeError"},{"location":"Classes/classerrors_1_1UnsupportedTraceTypeError/#errorsunsupportedtracetypeerror","text":"Inherits from Exception Updated on 2021-12-24 at 17:45:36 +0000","title":"errors::UnsupportedTraceTypeError"},{"location":"Classes/classgenerate__callback__traces_1_1TestGenerateTracesAutowareReferenceSystem/","text":"generate_callback_traces::TestGenerateTracesAutowareReferenceSystem Inherits from unittest.TestCase Public Functions Name def test_generate_traces (self self) Public Functions Documentation function test_generate_traces def test_generate_traces( self self ) Updated on 2021-12-24 at 17:45:36 +0000","title":"generate_callback_traces::TestGenerateTracesAutowareReferenceSystem"},{"location":"Classes/classgenerate__callback__traces_1_1TestGenerateTracesAutowareReferenceSystem/#generate_callback_tracestestgeneratetracesautowarereferencesystem","text":"Inherits from unittest.TestCase","title":"generate_callback_traces::TestGenerateTracesAutowareReferenceSystem"},{"location":"Classes/classgenerate__callback__traces_1_1TestGenerateTracesAutowareReferenceSystem/#public-functions","text":"Name def test_generate_traces (self self)","title":"Public Functions"},{"location":"Classes/classgenerate__callback__traces_1_1TestGenerateTracesAutowareReferenceSystem/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classgenerate__callback__traces_1_1TestGenerateTracesAutowareReferenceSystem/#function-test_generate_traces","text":"def test_generate_traces( self self ) Updated on 2021-12-24 at 17:45:36 +0000","title":"function test_generate_traces"},{"location":"Classes/classgenerate__std__traces_1_1TestGenerateTracesAutowareReferenceSystem/","text":"generate_std_traces::TestGenerateTracesAutowareReferenceSystem Inherits from unittest.TestCase Public Functions Name def test_generate_traces (self self) Public Functions Documentation function test_generate_traces def test_generate_traces( self self ) Updated on 2021-12-24 at 17:45:36 +0000","title":"generate_std_traces::TestGenerateTracesAutowareReferenceSystem"},{"location":"Classes/classgenerate__std__traces_1_1TestGenerateTracesAutowareReferenceSystem/#generate_std_tracestestgeneratetracesautowarereferencesystem","text":"Inherits from unittest.TestCase","title":"generate_std_traces::TestGenerateTracesAutowareReferenceSystem"},{"location":"Classes/classgenerate__std__traces_1_1TestGenerateTracesAutowareReferenceSystem/#public-functions","text":"Name def test_generate_traces (self self)","title":"Public Functions"},{"location":"Classes/classgenerate__std__traces_1_1TestGenerateTracesAutowareReferenceSystem/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classgenerate__std__traces_1_1TestGenerateTracesAutowareReferenceSystem/#function-test_generate_traces","text":"def test_generate_traces( self self ) Updated on 2021-12-24 at 17:45:36 +0000","title":"function test_generate_traces"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Command/","text":"nodes::rclcpp_system::Command Inherits from rclcpp::Node Public Functions Name Command (const CommandSettings & settings) Public Functions Documentation function Command inline explicit Command( const CommandSettings & settings ) Updated on 2021-12-24 at 17:45:36 +0000","title":"nodes::rclcpp_system::Command"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Command/#nodesrclcpp_systemcommand","text":"Inherits from rclcpp::Node","title":"nodes::rclcpp_system::Command"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Command/#public-functions","text":"Name Command (const CommandSettings & settings)","title":"Public Functions"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Command/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Command/#function-command","text":"inline explicit Command( const CommandSettings & settings ) Updated on 2021-12-24 at 17:45:36 +0000","title":"function Command"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Cyclic/","text":"nodes::rclcpp_system::Cyclic Inherits from rclcpp::Node Public Functions Name Cyclic (const CyclicSettings & settings) Public Functions Documentation function Cyclic inline explicit Cyclic( const CyclicSettings & settings ) Updated on 2021-12-24 at 17:45:36 +0000","title":"nodes::rclcpp_system::Cyclic"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Cyclic/#nodesrclcpp_systemcyclic","text":"Inherits from rclcpp::Node","title":"nodes::rclcpp_system::Cyclic"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Cyclic/#public-functions","text":"Name Cyclic (const CyclicSettings & settings)","title":"Public Functions"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Cyclic/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Cyclic/#function-cyclic","text":"inline explicit Cyclic( const CyclicSettings & settings ) Updated on 2021-12-24 at 17:45:36 +0000","title":"function Cyclic"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Fusion/","text":"nodes::rclcpp_system::Fusion Inherits from rclcpp::Node Public Functions Name Fusion (const FusionSettings & settings) Public Functions Documentation function Fusion inline explicit Fusion( const FusionSettings & settings ) Updated on 2021-12-24 at 17:45:36 +0000","title":"nodes::rclcpp_system::Fusion"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Fusion/#nodesrclcpp_systemfusion","text":"Inherits from rclcpp::Node","title":"nodes::rclcpp_system::Fusion"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Fusion/#public-functions","text":"Name Fusion (const FusionSettings & settings)","title":"Public Functions"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Fusion/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Fusion/#function-fusion","text":"inline explicit Fusion( const FusionSettings & settings ) Updated on 2021-12-24 at 17:45:36 +0000","title":"function Fusion"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Intersection/","text":"nodes::rclcpp_system::Intersection Inherits from rclcpp::Node Public Functions Name Intersection (const IntersectionSettings & settings) rclcpp::CallbackGroup::SharedPtr get_callback_group_of_subscription (const std::string & input_topic) Public Functions Documentation function Intersection inline explicit Intersection( const IntersectionSettings & settings ) function get_callback_group_of_subscription inline rclcpp::CallbackGroup::SharedPtr get_callback_group_of_subscription( const std::string & input_topic ) Updated on 2021-12-24 at 17:45:36 +0000","title":"nodes::rclcpp_system::Intersection"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Intersection/#nodesrclcpp_systemintersection","text":"Inherits from rclcpp::Node","title":"nodes::rclcpp_system::Intersection"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Intersection/#public-functions","text":"Name Intersection (const IntersectionSettings & settings) rclcpp::CallbackGroup::SharedPtr get_callback_group_of_subscription (const std::string & input_topic)","title":"Public Functions"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Intersection/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Intersection/#function-intersection","text":"inline explicit Intersection( const IntersectionSettings & settings )","title":"function Intersection"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Intersection/#function-get_callback_group_of_subscription","text":"inline rclcpp::CallbackGroup::SharedPtr get_callback_group_of_subscription( const std::string & input_topic ) Updated on 2021-12-24 at 17:45:36 +0000","title":"function get_callback_group_of_subscription"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Sensor/","text":"nodes::rclcpp_system::Sensor Inherits from rclcpp::Node Public Functions Name Sensor (const SensorSettings & settings) Public Functions Documentation function Sensor inline explicit Sensor( const SensorSettings & settings ) Updated on 2021-12-24 at 17:45:36 +0000","title":"nodes::rclcpp_system::Sensor"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Sensor/#nodesrclcpp_systemsensor","text":"Inherits from rclcpp::Node","title":"nodes::rclcpp_system::Sensor"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Sensor/#public-functions","text":"Name Sensor (const SensorSettings & settings)","title":"Public Functions"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Sensor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Sensor/#function-sensor","text":"inline explicit Sensor( const SensorSettings & settings ) Updated on 2021-12-24 at 17:45:36 +0000","title":"function Sensor"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Transform/","text":"nodes::rclcpp_system::Transform Inherits from rclcpp::Node Public Functions Name Transform (const TransformSettings & settings) Public Functions Documentation function Transform inline explicit Transform( const TransformSettings & settings ) Updated on 2021-12-24 at 17:45:36 +0000","title":"nodes::rclcpp_system::Transform"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Transform/#nodesrclcpp_systemtransform","text":"Inherits from rclcpp::Node","title":"nodes::rclcpp_system::Transform"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Transform/#public-functions","text":"Name Transform (const TransformSettings & settings)","title":"Public Functions"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Transform/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Transform/#function-transform","text":"inline explicit Transform( const TransformSettings & settings ) Updated on 2021-12-24 at 17:45:36 +0000","title":"function Transform"},{"location":"Classes/classtest__requirements_1_1TestRequirementsAutowareReferenceSystem/","text":"test_requirements::TestRequirementsAutowareReferenceSystem Inherits from unittest.TestCase Public Functions Name def test_pubs_and_subs (self self) Public Functions Documentation function test_pubs_and_subs def test_pubs_and_subs( self self ) Updated on 2021-12-24 at 17:45:36 +0000","title":"test_requirements::TestRequirementsAutowareReferenceSystem"},{"location":"Classes/classtest__requirements_1_1TestRequirementsAutowareReferenceSystem/#test_requirementstestrequirementsautowarereferencesystem","text":"Inherits from unittest.TestCase","title":"test_requirements::TestRequirementsAutowareReferenceSystem"},{"location":"Classes/classtest__requirements_1_1TestRequirementsAutowareReferenceSystem/#public-functions","text":"Name def test_pubs_and_subs (self self)","title":"Public Functions"},{"location":"Classes/classtest__requirements_1_1TestRequirementsAutowareReferenceSystem/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classtest__requirements_1_1TestRequirementsAutowareReferenceSystem/#function-test_pubs_and_subs","text":"def test_pubs_and_subs( self self ) Updated on 2021-12-24 at 17:45:36 +0000","title":"function test_pubs_and_subs"},{"location":"Classes/structRclcppSystem/","text":"RclcppSystem Public Types Name using rclcpp::Node NodeBaseType using nodes::rclcpp_system::Command Command using nodes::rclcpp_system::Cyclic Cyclic using nodes::rclcpp_system::Fusion Fusion using nodes::rclcpp_system::Intersection Intersection using nodes::rclcpp_system::Sensor Sensor using nodes::rclcpp_system::Transform Transform Public Types Documentation using NodeBaseType using RclcppSystem::NodeBaseType = rclcpp::Node; using Command using RclcppSystem::Command = nodes::rclcpp_system::Command; using Cyclic using RclcppSystem::Cyclic = nodes::rclcpp_system::Cyclic; using Fusion using RclcppSystem::Fusion = nodes::rclcpp_system::Fusion; using Intersection using RclcppSystem::Intersection = nodes::rclcpp_system::Intersection; using Sensor using RclcppSystem::Sensor = nodes::rclcpp_system::Sensor; using Transform using RclcppSystem::Transform = nodes::rclcpp_system::Transform; Updated on 2021-12-24 at 17:45:36 +0000","title":"RclcppSystem"},{"location":"Classes/structRclcppSystem/#rclcppsystem","text":"","title":"RclcppSystem"},{"location":"Classes/structRclcppSystem/#public-types","text":"Name using rclcpp::Node NodeBaseType using nodes::rclcpp_system::Command Command using nodes::rclcpp_system::Cyclic Cyclic using nodes::rclcpp_system::Fusion Fusion using nodes::rclcpp_system::Intersection Intersection using nodes::rclcpp_system::Sensor Sensor using nodes::rclcpp_system::Transform Transform","title":"Public Types"},{"location":"Classes/structRclcppSystem/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Classes/structRclcppSystem/#using-nodebasetype","text":"using RclcppSystem::NodeBaseType = rclcpp::Node;","title":"using NodeBaseType"},{"location":"Classes/structRclcppSystem/#using-command","text":"using RclcppSystem::Command = nodes::rclcpp_system::Command;","title":"using Command"},{"location":"Classes/structRclcppSystem/#using-cyclic","text":"using RclcppSystem::Cyclic = nodes::rclcpp_system::Cyclic;","title":"using Cyclic"},{"location":"Classes/structRclcppSystem/#using-fusion","text":"using RclcppSystem::Fusion = nodes::rclcpp_system::Fusion;","title":"using Fusion"},{"location":"Classes/structRclcppSystem/#using-intersection","text":"using RclcppSystem::Intersection = nodes::rclcpp_system::Intersection;","title":"using Intersection"},{"location":"Classes/structRclcppSystem/#using-sensor","text":"using RclcppSystem::Sensor = nodes::rclcpp_system::Sensor;","title":"using Sensor"},{"location":"Classes/structRclcppSystem/#using-transform","text":"using RclcppSystem::Transform = nodes::rclcpp_system::Transform; Updated on 2021-12-24 at 17:45:36 +0000","title":"using Transform"},{"location":"Classes/structnodes_1_1CommandSettings/","text":"nodes::CommandSettings Public Attributes Name std::string node_name std::string input_topic Public Attributes Documentation variable node_name std::string node_name; variable input_topic std::string input_topic; Updated on 2021-12-24 at 17:45:36 +0000","title":"nodes::CommandSettings"},{"location":"Classes/structnodes_1_1CommandSettings/#nodescommandsettings","text":"","title":"nodes::CommandSettings"},{"location":"Classes/structnodes_1_1CommandSettings/#public-attributes","text":"Name std::string node_name std::string input_topic","title":"Public Attributes"},{"location":"Classes/structnodes_1_1CommandSettings/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structnodes_1_1CommandSettings/#variable-node_name","text":"std::string node_name;","title":"variable node_name"},{"location":"Classes/structnodes_1_1CommandSettings/#variable-input_topic","text":"std::string input_topic; Updated on 2021-12-24 at 17:45:36 +0000","title":"variable input_topic"},{"location":"Classes/structnodes_1_1CyclicSettings/","text":"nodes::CyclicSettings Public Attributes Name std::string node_name std::vector< std::string > inputs std::string output_topic uint64_t number_crunch_limit std::chrono::nanoseconds cycle_time Public Attributes Documentation variable node_name std::string node_name; variable inputs std::vector< std::string > inputs; variable output_topic std::string output_topic; variable number_crunch_limit uint64_t number_crunch_limit; variable cycle_time std::chrono::nanoseconds cycle_time; Updated on 2021-12-24 at 17:45:36 +0000","title":"nodes::CyclicSettings"},{"location":"Classes/structnodes_1_1CyclicSettings/#nodescyclicsettings","text":"","title":"nodes::CyclicSettings"},{"location":"Classes/structnodes_1_1CyclicSettings/#public-attributes","text":"Name std::string node_name std::vector< std::string > inputs std::string output_topic uint64_t number_crunch_limit std::chrono::nanoseconds cycle_time","title":"Public Attributes"},{"location":"Classes/structnodes_1_1CyclicSettings/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structnodes_1_1CyclicSettings/#variable-node_name","text":"std::string node_name;","title":"variable node_name"},{"location":"Classes/structnodes_1_1CyclicSettings/#variable-inputs","text":"std::vector< std::string > inputs;","title":"variable inputs"},{"location":"Classes/structnodes_1_1CyclicSettings/#variable-output_topic","text":"std::string output_topic;","title":"variable output_topic"},{"location":"Classes/structnodes_1_1CyclicSettings/#variable-number_crunch_limit","text":"uint64_t number_crunch_limit;","title":"variable number_crunch_limit"},{"location":"Classes/structnodes_1_1CyclicSettings/#variable-cycle_time","text":"std::chrono::nanoseconds cycle_time; Updated on 2021-12-24 at 17:45:36 +0000","title":"variable cycle_time"},{"location":"Classes/structnodes_1_1FusionSettings/","text":"nodes::FusionSettings Public Attributes Name std::string node_name std::string input_0 std::string input_1 std::string output_topic uint64_t number_crunch_limit Public Attributes Documentation variable node_name std::string node_name; variable input_0 std::string input_0; variable input_1 std::string input_1; variable output_topic std::string output_topic; variable number_crunch_limit uint64_t number_crunch_limit; Updated on 2021-12-24 at 17:45:36 +0000","title":"nodes::FusionSettings"},{"location":"Classes/structnodes_1_1FusionSettings/#nodesfusionsettings","text":"","title":"nodes::FusionSettings"},{"location":"Classes/structnodes_1_1FusionSettings/#public-attributes","text":"Name std::string node_name std::string input_0 std::string input_1 std::string output_topic uint64_t number_crunch_limit","title":"Public Attributes"},{"location":"Classes/structnodes_1_1FusionSettings/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structnodes_1_1FusionSettings/#variable-node_name","text":"std::string node_name;","title":"variable node_name"},{"location":"Classes/structnodes_1_1FusionSettings/#variable-input_0","text":"std::string input_0;","title":"variable input_0"},{"location":"Classes/structnodes_1_1FusionSettings/#variable-input_1","text":"std::string input_1;","title":"variable input_1"},{"location":"Classes/structnodes_1_1FusionSettings/#variable-output_topic","text":"std::string output_topic;","title":"variable output_topic"},{"location":"Classes/structnodes_1_1FusionSettings/#variable-number_crunch_limit","text":"uint64_t number_crunch_limit; Updated on 2021-12-24 at 17:45:36 +0000","title":"variable number_crunch_limit"},{"location":"Classes/structnodes_1_1IntersectionSettings/","text":"nodes::IntersectionSettings Public Classes Name struct Connection Public Attributes Name std::string node_name std::vector< Connection > connections Public Attributes Documentation variable node_name std::string node_name; variable connections std::vector< Connection > connections; Updated on 2021-12-24 at 17:45:36 +0000","title":"nodes::IntersectionSettings"},{"location":"Classes/structnodes_1_1IntersectionSettings/#nodesintersectionsettings","text":"","title":"nodes::IntersectionSettings"},{"location":"Classes/structnodes_1_1IntersectionSettings/#public-classes","text":"Name struct Connection","title":"Public Classes"},{"location":"Classes/structnodes_1_1IntersectionSettings/#public-attributes","text":"Name std::string node_name std::vector< Connection > connections","title":"Public Attributes"},{"location":"Classes/structnodes_1_1IntersectionSettings/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structnodes_1_1IntersectionSettings/#variable-node_name","text":"std::string node_name;","title":"variable node_name"},{"location":"Classes/structnodes_1_1IntersectionSettings/#variable-connections","text":"std::vector< Connection > connections; Updated on 2021-12-24 at 17:45:36 +0000","title":"variable connections"},{"location":"Classes/structnodes_1_1IntersectionSettings_1_1Connection/","text":"nodes::IntersectionSettings::Connection Public Attributes Name std::string input_topic std::string output_topic uint64_t number_crunch_limit Public Attributes Documentation variable input_topic std::string input_topic; variable output_topic std::string output_topic; variable number_crunch_limit uint64_t number_crunch_limit; Updated on 2021-12-24 at 17:45:36 +0000","title":"nodes::IntersectionSettings::Connection"},{"location":"Classes/structnodes_1_1IntersectionSettings_1_1Connection/#nodesintersectionsettingsconnection","text":"","title":"nodes::IntersectionSettings::Connection"},{"location":"Classes/structnodes_1_1IntersectionSettings_1_1Connection/#public-attributes","text":"Name std::string input_topic std::string output_topic uint64_t number_crunch_limit","title":"Public Attributes"},{"location":"Classes/structnodes_1_1IntersectionSettings_1_1Connection/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structnodes_1_1IntersectionSettings_1_1Connection/#variable-input_topic","text":"std::string input_topic;","title":"variable input_topic"},{"location":"Classes/structnodes_1_1IntersectionSettings_1_1Connection/#variable-output_topic","text":"std::string output_topic;","title":"variable output_topic"},{"location":"Classes/structnodes_1_1IntersectionSettings_1_1Connection/#variable-number_crunch_limit","text":"uint64_t number_crunch_limit; Updated on 2021-12-24 at 17:45:36 +0000","title":"variable number_crunch_limit"},{"location":"Classes/structnodes_1_1SensorSettings/","text":"nodes::SensorSettings Public Attributes Name std::string node_name std::string topic_name std::chrono::nanoseconds cycle_time Public Attributes Documentation variable node_name std::string node_name; variable topic_name std::string topic_name; variable cycle_time std::chrono::nanoseconds cycle_time; Updated on 2021-12-24 at 17:45:36 +0000","title":"nodes::SensorSettings"},{"location":"Classes/structnodes_1_1SensorSettings/#nodessensorsettings","text":"","title":"nodes::SensorSettings"},{"location":"Classes/structnodes_1_1SensorSettings/#public-attributes","text":"Name std::string node_name std::string topic_name std::chrono::nanoseconds cycle_time","title":"Public Attributes"},{"location":"Classes/structnodes_1_1SensorSettings/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structnodes_1_1SensorSettings/#variable-node_name","text":"std::string node_name;","title":"variable node_name"},{"location":"Classes/structnodes_1_1SensorSettings/#variable-topic_name","text":"std::string topic_name;","title":"variable topic_name"},{"location":"Classes/structnodes_1_1SensorSettings/#variable-cycle_time","text":"std::chrono::nanoseconds cycle_time; Updated on 2021-12-24 at 17:45:36 +0000","title":"variable cycle_time"},{"location":"Classes/structnodes_1_1TransformSettings/","text":"nodes::TransformSettings Public Attributes Name std::string node_name std::string input_topic std::string output_topic uint64_t number_crunch_limit Public Attributes Documentation variable node_name std::string node_name; variable input_topic std::string input_topic; variable output_topic std::string output_topic; variable number_crunch_limit uint64_t number_crunch_limit; Updated on 2021-12-24 at 17:45:36 +0000","title":"nodes::TransformSettings"},{"location":"Classes/structnodes_1_1TransformSettings/#nodestransformsettings","text":"","title":"nodes::TransformSettings"},{"location":"Classes/structnodes_1_1TransformSettings/#public-attributes","text":"Name std::string node_name std::string input_topic std::string output_topic uint64_t number_crunch_limit","title":"Public Attributes"},{"location":"Classes/structnodes_1_1TransformSettings/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structnodes_1_1TransformSettings/#variable-node_name","text":"std::string node_name;","title":"variable node_name"},{"location":"Classes/structnodes_1_1TransformSettings/#variable-input_topic","text":"std::string input_topic;","title":"variable input_topic"},{"location":"Classes/structnodes_1_1TransformSettings/#variable-output_topic","text":"std::string output_topic;","title":"variable output_topic"},{"location":"Classes/structnodes_1_1TransformSettings/#variable-number_crunch_limit","text":"uint64_t number_crunch_limit; Updated on 2021-12-24 at 17:45:36 +0000","title":"variable number_crunch_limit"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Cyclic_1_1subscription__t/","text":"nodes::rclcpp_system::Cyclic::subscription_t Public Attributes Name rclcpp::Subscription< message_t >::SharedPtr subscription uint32_t sequence_number message_t::SharedPtr cache Public Attributes Documentation variable subscription rclcpp::Subscription< message_t >::SharedPtr subscription; variable sequence_number uint32_t sequence_number = 0; variable cache message_t::SharedPtr cache; Updated on 2021-12-24 at 17:45:36 +0000","title":"nodes::rclcpp_system::Cyclic::subscription_t"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Cyclic_1_1subscription__t/#nodesrclcpp_systemcyclicsubscription_t","text":"","title":"nodes::rclcpp_system::Cyclic::subscription_t"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Cyclic_1_1subscription__t/#public-attributes","text":"Name rclcpp::Subscription< message_t >::SharedPtr subscription uint32_t sequence_number message_t::SharedPtr cache","title":"Public Attributes"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Cyclic_1_1subscription__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Cyclic_1_1subscription__t/#variable-subscription","text":"rclcpp::Subscription< message_t >::SharedPtr subscription;","title":"variable subscription"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Cyclic_1_1subscription__t/#variable-sequence_number","text":"uint32_t sequence_number = 0;","title":"variable sequence_number"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Cyclic_1_1subscription__t/#variable-cache","text":"message_t::SharedPtr cache; Updated on 2021-12-24 at 17:45:36 +0000","title":"variable cache"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Fusion_1_1subscription__t/","text":"nodes::rclcpp_system::Fusion::subscription_t Public Attributes Name rclcpp::Subscription< message_t >::SharedPtr subscription uint32_t sequence_number message_t::SharedPtr cache Public Attributes Documentation variable subscription rclcpp::Subscription< message_t >::SharedPtr subscription; variable sequence_number uint32_t sequence_number = 0; variable cache message_t::SharedPtr cache; Updated on 2021-12-24 at 17:45:36 +0000","title":"nodes::rclcpp_system::Fusion::subscription_t"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Fusion_1_1subscription__t/#nodesrclcpp_systemfusionsubscription_t","text":"","title":"nodes::rclcpp_system::Fusion::subscription_t"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Fusion_1_1subscription__t/#public-attributes","text":"Name rclcpp::Subscription< message_t >::SharedPtr subscription uint32_t sequence_number message_t::SharedPtr cache","title":"Public Attributes"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Fusion_1_1subscription__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Fusion_1_1subscription__t/#variable-subscription","text":"rclcpp::Subscription< message_t >::SharedPtr subscription;","title":"variable subscription"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Fusion_1_1subscription__t/#variable-sequence_number","text":"uint32_t sequence_number = 0;","title":"variable sequence_number"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Fusion_1_1subscription__t/#variable-cache","text":"message_t::SharedPtr cache; Updated on 2021-12-24 at 17:45:36 +0000","title":"variable cache"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Intersection_1_1Connection/","text":"nodes::rclcpp_system::Intersection::Connection Public Attributes Name rclcpp::Publisher< message_t >::SharedPtr publisher rclcpp::Subscription< message_t >::SharedPtr subscription rclcpp::CallbackGroup::SharedPtr callback_group uint64_t number_crunch_limit uint32_t sequence_number uint32_t input_sequence_number Public Attributes Documentation variable publisher rclcpp::Publisher< message_t >::SharedPtr publisher; variable subscription rclcpp::Subscription< message_t >::SharedPtr subscription; variable callback_group rclcpp::CallbackGroup::SharedPtr callback_group; variable number_crunch_limit uint64_t number_crunch_limit; variable sequence_number uint32_t sequence_number = 0; variable input_sequence_number uint32_t input_sequence_number = 0; Updated on 2021-12-24 at 17:45:36 +0000","title":"nodes::rclcpp_system::Intersection::Connection"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Intersection_1_1Connection/#nodesrclcpp_systemintersectionconnection","text":"","title":"nodes::rclcpp_system::Intersection::Connection"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Intersection_1_1Connection/#public-attributes","text":"Name rclcpp::Publisher< message_t >::SharedPtr publisher rclcpp::Subscription< message_t >::SharedPtr subscription rclcpp::CallbackGroup::SharedPtr callback_group uint64_t number_crunch_limit uint32_t sequence_number uint32_t input_sequence_number","title":"Public Attributes"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Intersection_1_1Connection/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Intersection_1_1Connection/#variable-publisher","text":"rclcpp::Publisher< message_t >::SharedPtr publisher;","title":"variable publisher"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Intersection_1_1Connection/#variable-subscription","text":"rclcpp::Subscription< message_t >::SharedPtr subscription;","title":"variable subscription"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Intersection_1_1Connection/#variable-callback_group","text":"rclcpp::CallbackGroup::SharedPtr callback_group;","title":"variable callback_group"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Intersection_1_1Connection/#variable-number_crunch_limit","text":"uint64_t number_crunch_limit;","title":"variable number_crunch_limit"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Intersection_1_1Connection/#variable-sequence_number","text":"uint32_t sequence_number = 0;","title":"variable sequence_number"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Intersection_1_1Connection/#variable-input_sequence_number","text":"uint32_t input_sequence_number = 0; Updated on 2021-12-24 at 17:45:36 +0000","title":"variable input_sequence_number"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/","text":"nodes::timing::BenchmarkCPUUsage Public Types Name using std::chrono::nanoseconds time_t using std::chrono::milliseconds milliseconds using std::chrono::seconds seconds Public Attributes Name constexpr time_t FRONT_LIDAR_DRIVER constexpr time_t REAR_LIDAR_DRIVER constexpr time_t POINT_CLOUD_MAP constexpr time_t VISUALIZER constexpr time_t LANELET2MAP constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS constexpr uint64_t POINTS_TRANSFORMER_FRONT constexpr uint64_t POINTS_TRANSFORMER_REAR constexpr uint64_t VOXEL_GRID_DOWNSAMPLER constexpr uint64_t POINT_CLOUD_MAP_LOADER constexpr uint64_t RAY_GROUND_FILTER constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR constexpr uint64_t EUCLIDEAN_INTERSECTION constexpr uint64_t OBJECT_COLLISION_ESTIMATOR constexpr uint64_t MPC_CONTROLLER constexpr uint64_t PARKING_PLANNER constexpr uint64_t LANE_PLANNER constexpr uint64_t POINT_CLOUD_FUSION constexpr uint64_t NDT_LOCALIZER constexpr uint64_t VEHICLE_INTERFACE constexpr uint64_t LANELET_2_GLOBAL_PLANNER constexpr uint64_t LANELET_2_MAP_LOADER constexpr uint64_t BEHAVIOR_PLANNER constexpr time_t BEHAVIOR_PLANNER_CYCLE Public Types Documentation using time_t using nodes::timing::BenchmarkCPUUsage::time_t = std::chrono::nanoseconds; using milliseconds using nodes::timing::BenchmarkCPUUsage::milliseconds = std::chrono::milliseconds; using seconds using nodes::timing::BenchmarkCPUUsage::seconds = std::chrono::seconds; Public Attributes Documentation variable FRONT_LIDAR_DRIVER static constexpr time_t FRONT_LIDAR_DRIVER = Default::FRONT_LIDAR_DRIVER; variable REAR_LIDAR_DRIVER static constexpr time_t REAR_LIDAR_DRIVER = Default::REAR_LIDAR_DRIVER; variable POINT_CLOUD_MAP static constexpr time_t POINT_CLOUD_MAP = Default::POINT_CLOUD_MAP; variable VISUALIZER static constexpr time_t VISUALIZER = Default::VISUALIZER; variable LANELET2MAP static constexpr time_t LANELET2MAP = Default::LANELET2MAP; variable EUCLIDEAN_CLUSTER_SETTINGS static constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS = Default::EUCLIDEAN_CLUSTER_SETTINGS; variable POINTS_TRANSFORMER_FRONT static constexpr uint64_t POINTS_TRANSFORMER_FRONT = 0; variable POINTS_TRANSFORMER_REAR static constexpr uint64_t POINTS_TRANSFORMER_REAR = 0; variable VOXEL_GRID_DOWNSAMPLER static constexpr uint64_t VOXEL_GRID_DOWNSAMPLER = 0; variable POINT_CLOUD_MAP_LOADER static constexpr uint64_t POINT_CLOUD_MAP_LOADER = 0; variable RAY_GROUND_FILTER static constexpr uint64_t RAY_GROUND_FILTER = 0; variable EUCLIDEAN_CLUSTER_DETECTOR static constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR = 0; variable EUCLIDEAN_INTERSECTION static constexpr uint64_t EUCLIDEAN_INTERSECTION = 0; variable OBJECT_COLLISION_ESTIMATOR static constexpr uint64_t OBJECT_COLLISION_ESTIMATOR = 0; variable MPC_CONTROLLER static constexpr uint64_t MPC_CONTROLLER = 0; variable PARKING_PLANNER static constexpr uint64_t PARKING_PLANNER = 0; variable LANE_PLANNER static constexpr uint64_t LANE_PLANNER = 0; variable POINT_CLOUD_FUSION static constexpr uint64_t POINT_CLOUD_FUSION = 0; variable NDT_LOCALIZER static constexpr uint64_t NDT_LOCALIZER = 0; variable VEHICLE_INTERFACE static constexpr uint64_t VEHICLE_INTERFACE = 0; variable LANELET_2_GLOBAL_PLANNER static constexpr uint64_t LANELET_2_GLOBAL_PLANNER = 0; variable LANELET_2_MAP_LOADER static constexpr uint64_t LANELET_2_MAP_LOADER = 0; variable BEHAVIOR_PLANNER static constexpr uint64_t BEHAVIOR_PLANNER = 0; variable BEHAVIOR_PLANNER_CYCLE static constexpr time_t BEHAVIOR_PLANNER_CYCLE = Default::BEHAVIOR_PLANNER_CYCLE; Updated on 2021-12-24 at 17:45:36 +0000","title":"nodes::timing::BenchmarkCPUUsage"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#nodestimingbenchmarkcpuusage","text":"","title":"nodes::timing::BenchmarkCPUUsage"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#public-types","text":"Name using std::chrono::nanoseconds time_t using std::chrono::milliseconds milliseconds using std::chrono::seconds seconds","title":"Public Types"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#public-attributes","text":"Name constexpr time_t FRONT_LIDAR_DRIVER constexpr time_t REAR_LIDAR_DRIVER constexpr time_t POINT_CLOUD_MAP constexpr time_t VISUALIZER constexpr time_t LANELET2MAP constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS constexpr uint64_t POINTS_TRANSFORMER_FRONT constexpr uint64_t POINTS_TRANSFORMER_REAR constexpr uint64_t VOXEL_GRID_DOWNSAMPLER constexpr uint64_t POINT_CLOUD_MAP_LOADER constexpr uint64_t RAY_GROUND_FILTER constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR constexpr uint64_t EUCLIDEAN_INTERSECTION constexpr uint64_t OBJECT_COLLISION_ESTIMATOR constexpr uint64_t MPC_CONTROLLER constexpr uint64_t PARKING_PLANNER constexpr uint64_t LANE_PLANNER constexpr uint64_t POINT_CLOUD_FUSION constexpr uint64_t NDT_LOCALIZER constexpr uint64_t VEHICLE_INTERFACE constexpr uint64_t LANELET_2_GLOBAL_PLANNER constexpr uint64_t LANELET_2_MAP_LOADER constexpr uint64_t BEHAVIOR_PLANNER constexpr time_t BEHAVIOR_PLANNER_CYCLE","title":"Public Attributes"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#using-time_t","text":"using nodes::timing::BenchmarkCPUUsage::time_t = std::chrono::nanoseconds;","title":"using time_t"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#using-milliseconds","text":"using nodes::timing::BenchmarkCPUUsage::milliseconds = std::chrono::milliseconds;","title":"using milliseconds"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#using-seconds","text":"using nodes::timing::BenchmarkCPUUsage::seconds = std::chrono::seconds;","title":"using seconds"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-front_lidar_driver","text":"static constexpr time_t FRONT_LIDAR_DRIVER = Default::FRONT_LIDAR_DRIVER;","title":"variable FRONT_LIDAR_DRIVER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-rear_lidar_driver","text":"static constexpr time_t REAR_LIDAR_DRIVER = Default::REAR_LIDAR_DRIVER;","title":"variable REAR_LIDAR_DRIVER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-point_cloud_map","text":"static constexpr time_t POINT_CLOUD_MAP = Default::POINT_CLOUD_MAP;","title":"variable POINT_CLOUD_MAP"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-visualizer","text":"static constexpr time_t VISUALIZER = Default::VISUALIZER;","title":"variable VISUALIZER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-lanelet2map","text":"static constexpr time_t LANELET2MAP = Default::LANELET2MAP;","title":"variable LANELET2MAP"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-euclidean_cluster_settings","text":"static constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS = Default::EUCLIDEAN_CLUSTER_SETTINGS;","title":"variable EUCLIDEAN_CLUSTER_SETTINGS"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-points_transformer_front","text":"static constexpr uint64_t POINTS_TRANSFORMER_FRONT = 0;","title":"variable POINTS_TRANSFORMER_FRONT"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-points_transformer_rear","text":"static constexpr uint64_t POINTS_TRANSFORMER_REAR = 0;","title":"variable POINTS_TRANSFORMER_REAR"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-voxel_grid_downsampler","text":"static constexpr uint64_t VOXEL_GRID_DOWNSAMPLER = 0;","title":"variable VOXEL_GRID_DOWNSAMPLER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-point_cloud_map_loader","text":"static constexpr uint64_t POINT_CLOUD_MAP_LOADER = 0;","title":"variable POINT_CLOUD_MAP_LOADER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-ray_ground_filter","text":"static constexpr uint64_t RAY_GROUND_FILTER = 0;","title":"variable RAY_GROUND_FILTER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-euclidean_cluster_detector","text":"static constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR = 0;","title":"variable EUCLIDEAN_CLUSTER_DETECTOR"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-euclidean_intersection","text":"static constexpr uint64_t EUCLIDEAN_INTERSECTION = 0;","title":"variable EUCLIDEAN_INTERSECTION"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-object_collision_estimator","text":"static constexpr uint64_t OBJECT_COLLISION_ESTIMATOR = 0;","title":"variable OBJECT_COLLISION_ESTIMATOR"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-mpc_controller","text":"static constexpr uint64_t MPC_CONTROLLER = 0;","title":"variable MPC_CONTROLLER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-parking_planner","text":"static constexpr uint64_t PARKING_PLANNER = 0;","title":"variable PARKING_PLANNER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-lane_planner","text":"static constexpr uint64_t LANE_PLANNER = 0;","title":"variable LANE_PLANNER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-point_cloud_fusion","text":"static constexpr uint64_t POINT_CLOUD_FUSION = 0;","title":"variable POINT_CLOUD_FUSION"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-ndt_localizer","text":"static constexpr uint64_t NDT_LOCALIZER = 0;","title":"variable NDT_LOCALIZER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-vehicle_interface","text":"static constexpr uint64_t VEHICLE_INTERFACE = 0;","title":"variable VEHICLE_INTERFACE"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-lanelet_2_global_planner","text":"static constexpr uint64_t LANELET_2_GLOBAL_PLANNER = 0;","title":"variable LANELET_2_GLOBAL_PLANNER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-lanelet_2_map_loader","text":"static constexpr uint64_t LANELET_2_MAP_LOADER = 0;","title":"variable LANELET_2_MAP_LOADER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-behavior_planner","text":"static constexpr uint64_t BEHAVIOR_PLANNER = 0;","title":"variable BEHAVIOR_PLANNER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-behavior_planner_cycle","text":"static constexpr time_t BEHAVIOR_PLANNER_CYCLE = Default::BEHAVIOR_PLANNER_CYCLE; Updated on 2021-12-24 at 17:45:36 +0000","title":"variable BEHAVIOR_PLANNER_CYCLE"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/","text":"nodes::timing::BenchmarkThroughput Public Types Name using std::chrono::nanoseconds time_t using std::chrono::milliseconds milliseconds using std::chrono::seconds seconds Public Attributes Name constexpr time_t FRONT_LIDAR_DRIVER constexpr time_t REAR_LIDAR_DRIVER constexpr time_t POINT_CLOUD_MAP constexpr time_t VISUALIZER constexpr time_t LANELET2MAP constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS constexpr uint64_t POINTS_TRANSFORMER_FRONT constexpr uint64_t POINTS_TRANSFORMER_REAR constexpr uint64_t VOXEL_GRID_DOWNSAMPLER constexpr uint64_t POINT_CLOUD_MAP_LOADER constexpr uint64_t RAY_GROUND_FILTER constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR constexpr uint64_t EUCLIDEAN_INTERSECTION constexpr uint64_t OBJECT_COLLISION_ESTIMATOR constexpr uint64_t MPC_CONTROLLER constexpr uint64_t PARKING_PLANNER constexpr uint64_t LANE_PLANNER constexpr uint64_t POINT_CLOUD_FUSION constexpr uint64_t NDT_LOCALIZER constexpr uint64_t VEHICLE_INTERFACE constexpr uint64_t LANELET_2_GLOBAL_PLANNER constexpr uint64_t LANELET_2_MAP_LOADER constexpr uint64_t BEHAVIOR_PLANNER constexpr time_t BEHAVIOR_PLANNER_CYCLE Public Types Documentation using time_t using nodes::timing::BenchmarkThroughput::time_t = std::chrono::nanoseconds; using milliseconds using nodes::timing::BenchmarkThroughput::milliseconds = std::chrono::milliseconds; using seconds using nodes::timing::BenchmarkThroughput::seconds = std::chrono::seconds; Public Attributes Documentation variable FRONT_LIDAR_DRIVER static constexpr time_t FRONT_LIDAR_DRIVER = milliseconds(0); variable REAR_LIDAR_DRIVER static constexpr time_t REAR_LIDAR_DRIVER = milliseconds(0); variable POINT_CLOUD_MAP static constexpr time_t POINT_CLOUD_MAP = milliseconds(0); variable VISUALIZER static constexpr time_t VISUALIZER = milliseconds(0); variable LANELET2MAP static constexpr time_t LANELET2MAP = milliseconds(0); variable EUCLIDEAN_CLUSTER_SETTINGS static constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS = milliseconds(0); variable POINTS_TRANSFORMER_FRONT static constexpr uint64_t POINTS_TRANSFORMER_FRONT = 0; variable POINTS_TRANSFORMER_REAR static constexpr uint64_t POINTS_TRANSFORMER_REAR = 0; variable VOXEL_GRID_DOWNSAMPLER static constexpr uint64_t VOXEL_GRID_DOWNSAMPLER = 0; variable POINT_CLOUD_MAP_LOADER static constexpr uint64_t POINT_CLOUD_MAP_LOADER = 0; variable RAY_GROUND_FILTER static constexpr uint64_t RAY_GROUND_FILTER = 0; variable EUCLIDEAN_CLUSTER_DETECTOR static constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR = 0; variable EUCLIDEAN_INTERSECTION static constexpr uint64_t EUCLIDEAN_INTERSECTION = 0; variable OBJECT_COLLISION_ESTIMATOR static constexpr uint64_t OBJECT_COLLISION_ESTIMATOR = 0; variable MPC_CONTROLLER static constexpr uint64_t MPC_CONTROLLER = 0; variable PARKING_PLANNER static constexpr uint64_t PARKING_PLANNER = 0; variable LANE_PLANNER static constexpr uint64_t LANE_PLANNER = 0; variable POINT_CLOUD_FUSION static constexpr uint64_t POINT_CLOUD_FUSION = 0; variable NDT_LOCALIZER static constexpr uint64_t NDT_LOCALIZER = 0; variable VEHICLE_INTERFACE static constexpr uint64_t VEHICLE_INTERFACE = 0; variable LANELET_2_GLOBAL_PLANNER static constexpr uint64_t LANELET_2_GLOBAL_PLANNER = 0; variable LANELET_2_MAP_LOADER static constexpr uint64_t LANELET_2_MAP_LOADER = 0; variable BEHAVIOR_PLANNER static constexpr uint64_t BEHAVIOR_PLANNER = 0; variable BEHAVIOR_PLANNER_CYCLE static constexpr time_t BEHAVIOR_PLANNER_CYCLE = milliseconds(0); Updated on 2021-12-24 at 17:45:36 +0000","title":"nodes::timing::BenchmarkThroughput"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#nodestimingbenchmarkthroughput","text":"","title":"nodes::timing::BenchmarkThroughput"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#public-types","text":"Name using std::chrono::nanoseconds time_t using std::chrono::milliseconds milliseconds using std::chrono::seconds seconds","title":"Public Types"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#public-attributes","text":"Name constexpr time_t FRONT_LIDAR_DRIVER constexpr time_t REAR_LIDAR_DRIVER constexpr time_t POINT_CLOUD_MAP constexpr time_t VISUALIZER constexpr time_t LANELET2MAP constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS constexpr uint64_t POINTS_TRANSFORMER_FRONT constexpr uint64_t POINTS_TRANSFORMER_REAR constexpr uint64_t VOXEL_GRID_DOWNSAMPLER constexpr uint64_t POINT_CLOUD_MAP_LOADER constexpr uint64_t RAY_GROUND_FILTER constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR constexpr uint64_t EUCLIDEAN_INTERSECTION constexpr uint64_t OBJECT_COLLISION_ESTIMATOR constexpr uint64_t MPC_CONTROLLER constexpr uint64_t PARKING_PLANNER constexpr uint64_t LANE_PLANNER constexpr uint64_t POINT_CLOUD_FUSION constexpr uint64_t NDT_LOCALIZER constexpr uint64_t VEHICLE_INTERFACE constexpr uint64_t LANELET_2_GLOBAL_PLANNER constexpr uint64_t LANELET_2_MAP_LOADER constexpr uint64_t BEHAVIOR_PLANNER constexpr time_t BEHAVIOR_PLANNER_CYCLE","title":"Public Attributes"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#using-time_t","text":"using nodes::timing::BenchmarkThroughput::time_t = std::chrono::nanoseconds;","title":"using time_t"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#using-milliseconds","text":"using nodes::timing::BenchmarkThroughput::milliseconds = std::chrono::milliseconds;","title":"using milliseconds"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#using-seconds","text":"using nodes::timing::BenchmarkThroughput::seconds = std::chrono::seconds;","title":"using seconds"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-front_lidar_driver","text":"static constexpr time_t FRONT_LIDAR_DRIVER = milliseconds(0);","title":"variable FRONT_LIDAR_DRIVER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-rear_lidar_driver","text":"static constexpr time_t REAR_LIDAR_DRIVER = milliseconds(0);","title":"variable REAR_LIDAR_DRIVER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-point_cloud_map","text":"static constexpr time_t POINT_CLOUD_MAP = milliseconds(0);","title":"variable POINT_CLOUD_MAP"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-visualizer","text":"static constexpr time_t VISUALIZER = milliseconds(0);","title":"variable VISUALIZER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-lanelet2map","text":"static constexpr time_t LANELET2MAP = milliseconds(0);","title":"variable LANELET2MAP"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-euclidean_cluster_settings","text":"static constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS = milliseconds(0);","title":"variable EUCLIDEAN_CLUSTER_SETTINGS"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-points_transformer_front","text":"static constexpr uint64_t POINTS_TRANSFORMER_FRONT = 0;","title":"variable POINTS_TRANSFORMER_FRONT"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-points_transformer_rear","text":"static constexpr uint64_t POINTS_TRANSFORMER_REAR = 0;","title":"variable POINTS_TRANSFORMER_REAR"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-voxel_grid_downsampler","text":"static constexpr uint64_t VOXEL_GRID_DOWNSAMPLER = 0;","title":"variable VOXEL_GRID_DOWNSAMPLER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-point_cloud_map_loader","text":"static constexpr uint64_t POINT_CLOUD_MAP_LOADER = 0;","title":"variable POINT_CLOUD_MAP_LOADER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-ray_ground_filter","text":"static constexpr uint64_t RAY_GROUND_FILTER = 0;","title":"variable RAY_GROUND_FILTER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-euclidean_cluster_detector","text":"static constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR = 0;","title":"variable EUCLIDEAN_CLUSTER_DETECTOR"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-euclidean_intersection","text":"static constexpr uint64_t EUCLIDEAN_INTERSECTION = 0;","title":"variable EUCLIDEAN_INTERSECTION"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-object_collision_estimator","text":"static constexpr uint64_t OBJECT_COLLISION_ESTIMATOR = 0;","title":"variable OBJECT_COLLISION_ESTIMATOR"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-mpc_controller","text":"static constexpr uint64_t MPC_CONTROLLER = 0;","title":"variable MPC_CONTROLLER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-parking_planner","text":"static constexpr uint64_t PARKING_PLANNER = 0;","title":"variable PARKING_PLANNER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-lane_planner","text":"static constexpr uint64_t LANE_PLANNER = 0;","title":"variable LANE_PLANNER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-point_cloud_fusion","text":"static constexpr uint64_t POINT_CLOUD_FUSION = 0;","title":"variable POINT_CLOUD_FUSION"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-ndt_localizer","text":"static constexpr uint64_t NDT_LOCALIZER = 0;","title":"variable NDT_LOCALIZER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-vehicle_interface","text":"static constexpr uint64_t VEHICLE_INTERFACE = 0;","title":"variable VEHICLE_INTERFACE"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-lanelet_2_global_planner","text":"static constexpr uint64_t LANELET_2_GLOBAL_PLANNER = 0;","title":"variable LANELET_2_GLOBAL_PLANNER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-lanelet_2_map_loader","text":"static constexpr uint64_t LANELET_2_MAP_LOADER = 0;","title":"variable LANELET_2_MAP_LOADER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-behavior_planner","text":"static constexpr uint64_t BEHAVIOR_PLANNER = 0;","title":"variable BEHAVIOR_PLANNER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-behavior_planner_cycle","text":"static constexpr time_t BEHAVIOR_PLANNER_CYCLE = milliseconds(0); Updated on 2021-12-24 at 17:45:36 +0000","title":"variable BEHAVIOR_PLANNER_CYCLE"},{"location":"Classes/structnodes_1_1timing_1_1Default/","text":"nodes::timing::Default Public Types Name using std::chrono::nanoseconds time_t using std::chrono::milliseconds milliseconds Public Attributes Name constexpr time_t FRONT_LIDAR_DRIVER constexpr time_t REAR_LIDAR_DRIVER constexpr time_t POINT_CLOUD_MAP constexpr time_t VISUALIZER constexpr time_t LANELET2MAP constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS constexpr uint64_t POINTS_TRANSFORMER_FRONT constexpr uint64_t POINTS_TRANSFORMER_REAR constexpr uint64_t VOXEL_GRID_DOWNSAMPLER constexpr uint64_t POINT_CLOUD_MAP_LOADER constexpr uint64_t RAY_GROUND_FILTER constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR constexpr uint64_t EUCLIDEAN_INTERSECTION constexpr uint64_t OBJECT_COLLISION_ESTIMATOR constexpr uint64_t MPC_CONTROLLER constexpr uint64_t PARKING_PLANNER constexpr uint64_t LANE_PLANNER constexpr uint64_t POINT_CLOUD_FUSION constexpr uint64_t NDT_LOCALIZER constexpr uint64_t VEHICLE_INTERFACE constexpr uint64_t LANELET_2_GLOBAL_PLANNER constexpr uint64_t LANELET_2_MAP_LOADER constexpr uint64_t BEHAVIOR_PLANNER constexpr time_t BEHAVIOR_PLANNER_CYCLE Public Types Documentation using time_t using nodes::timing::Default::time_t = std::chrono::nanoseconds; using milliseconds using nodes::timing::Default::milliseconds = std::chrono::milliseconds; Public Attributes Documentation variable FRONT_LIDAR_DRIVER static constexpr time_t FRONT_LIDAR_DRIVER = milliseconds(100); variable REAR_LIDAR_DRIVER static constexpr time_t REAR_LIDAR_DRIVER = milliseconds(100); variable POINT_CLOUD_MAP static constexpr time_t POINT_CLOUD_MAP = milliseconds(120); variable VISUALIZER static constexpr time_t VISUALIZER = milliseconds(60); variable LANELET2MAP static constexpr time_t LANELET2MAP = milliseconds(100); variable EUCLIDEAN_CLUSTER_SETTINGS static constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS = milliseconds(25); variable POINTS_TRANSFORMER_FRONT static constexpr uint64_t POINTS_TRANSFORMER_FRONT = 65536; variable POINTS_TRANSFORMER_REAR static constexpr uint64_t POINTS_TRANSFORMER_REAR = 65536; variable VOXEL_GRID_DOWNSAMPLER static constexpr uint64_t VOXEL_GRID_DOWNSAMPLER = 65536; variable POINT_CLOUD_MAP_LOADER static constexpr uint64_t POINT_CLOUD_MAP_LOADER = 65536; variable RAY_GROUND_FILTER static constexpr uint64_t RAY_GROUND_FILTER = 65536; variable EUCLIDEAN_CLUSTER_DETECTOR static constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR = 65536; variable EUCLIDEAN_INTERSECTION static constexpr uint64_t EUCLIDEAN_INTERSECTION = 65536; variable OBJECT_COLLISION_ESTIMATOR static constexpr uint64_t OBJECT_COLLISION_ESTIMATOR = 65536; variable MPC_CONTROLLER static constexpr uint64_t MPC_CONTROLLER = 65536; variable PARKING_PLANNER static constexpr uint64_t PARKING_PLANNER = 65536; variable LANE_PLANNER static constexpr uint64_t LANE_PLANNER = 65536; variable POINT_CLOUD_FUSION static constexpr uint64_t POINT_CLOUD_FUSION = 65536; variable NDT_LOCALIZER static constexpr uint64_t NDT_LOCALIZER = 65536; variable VEHICLE_INTERFACE static constexpr uint64_t VEHICLE_INTERFACE = 65536; variable LANELET_2_GLOBAL_PLANNER static constexpr uint64_t LANELET_2_GLOBAL_PLANNER = 65536; variable LANELET_2_MAP_LOADER static constexpr uint64_t LANELET_2_MAP_LOADER = 65536; variable BEHAVIOR_PLANNER static constexpr uint64_t BEHAVIOR_PLANNER = 65536; variable BEHAVIOR_PLANNER_CYCLE static constexpr time_t BEHAVIOR_PLANNER_CYCLE = milliseconds(100); Updated on 2021-12-24 at 17:45:36 +0000","title":"nodes::timing::Default"},{"location":"Classes/structnodes_1_1timing_1_1Default/#nodestimingdefault","text":"","title":"nodes::timing::Default"},{"location":"Classes/structnodes_1_1timing_1_1Default/#public-types","text":"Name using std::chrono::nanoseconds time_t using std::chrono::milliseconds milliseconds","title":"Public Types"},{"location":"Classes/structnodes_1_1timing_1_1Default/#public-attributes","text":"Name constexpr time_t FRONT_LIDAR_DRIVER constexpr time_t REAR_LIDAR_DRIVER constexpr time_t POINT_CLOUD_MAP constexpr time_t VISUALIZER constexpr time_t LANELET2MAP constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS constexpr uint64_t POINTS_TRANSFORMER_FRONT constexpr uint64_t POINTS_TRANSFORMER_REAR constexpr uint64_t VOXEL_GRID_DOWNSAMPLER constexpr uint64_t POINT_CLOUD_MAP_LOADER constexpr uint64_t RAY_GROUND_FILTER constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR constexpr uint64_t EUCLIDEAN_INTERSECTION constexpr uint64_t OBJECT_COLLISION_ESTIMATOR constexpr uint64_t MPC_CONTROLLER constexpr uint64_t PARKING_PLANNER constexpr uint64_t LANE_PLANNER constexpr uint64_t POINT_CLOUD_FUSION constexpr uint64_t NDT_LOCALIZER constexpr uint64_t VEHICLE_INTERFACE constexpr uint64_t LANELET_2_GLOBAL_PLANNER constexpr uint64_t LANELET_2_MAP_LOADER constexpr uint64_t BEHAVIOR_PLANNER constexpr time_t BEHAVIOR_PLANNER_CYCLE","title":"Public Attributes"},{"location":"Classes/structnodes_1_1timing_1_1Default/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Classes/structnodes_1_1timing_1_1Default/#using-time_t","text":"using nodes::timing::Default::time_t = std::chrono::nanoseconds;","title":"using time_t"},{"location":"Classes/structnodes_1_1timing_1_1Default/#using-milliseconds","text":"using nodes::timing::Default::milliseconds = std::chrono::milliseconds;","title":"using milliseconds"},{"location":"Classes/structnodes_1_1timing_1_1Default/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-front_lidar_driver","text":"static constexpr time_t FRONT_LIDAR_DRIVER = milliseconds(100);","title":"variable FRONT_LIDAR_DRIVER"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-rear_lidar_driver","text":"static constexpr time_t REAR_LIDAR_DRIVER = milliseconds(100);","title":"variable REAR_LIDAR_DRIVER"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-point_cloud_map","text":"static constexpr time_t POINT_CLOUD_MAP = milliseconds(120);","title":"variable POINT_CLOUD_MAP"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-visualizer","text":"static constexpr time_t VISUALIZER = milliseconds(60);","title":"variable VISUALIZER"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-lanelet2map","text":"static constexpr time_t LANELET2MAP = milliseconds(100);","title":"variable LANELET2MAP"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-euclidean_cluster_settings","text":"static constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS = milliseconds(25);","title":"variable EUCLIDEAN_CLUSTER_SETTINGS"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-points_transformer_front","text":"static constexpr uint64_t POINTS_TRANSFORMER_FRONT = 65536;","title":"variable POINTS_TRANSFORMER_FRONT"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-points_transformer_rear","text":"static constexpr uint64_t POINTS_TRANSFORMER_REAR = 65536;","title":"variable POINTS_TRANSFORMER_REAR"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-voxel_grid_downsampler","text":"static constexpr uint64_t VOXEL_GRID_DOWNSAMPLER = 65536;","title":"variable VOXEL_GRID_DOWNSAMPLER"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-point_cloud_map_loader","text":"static constexpr uint64_t POINT_CLOUD_MAP_LOADER = 65536;","title":"variable POINT_CLOUD_MAP_LOADER"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-ray_ground_filter","text":"static constexpr uint64_t RAY_GROUND_FILTER = 65536;","title":"variable RAY_GROUND_FILTER"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-euclidean_cluster_detector","text":"static constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR = 65536;","title":"variable EUCLIDEAN_CLUSTER_DETECTOR"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-euclidean_intersection","text":"static constexpr uint64_t EUCLIDEAN_INTERSECTION = 65536;","title":"variable EUCLIDEAN_INTERSECTION"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-object_collision_estimator","text":"static constexpr uint64_t OBJECT_COLLISION_ESTIMATOR = 65536;","title":"variable OBJECT_COLLISION_ESTIMATOR"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-mpc_controller","text":"static constexpr uint64_t MPC_CONTROLLER = 65536;","title":"variable MPC_CONTROLLER"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-parking_planner","text":"static constexpr uint64_t PARKING_PLANNER = 65536;","title":"variable PARKING_PLANNER"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-lane_planner","text":"static constexpr uint64_t LANE_PLANNER = 65536;","title":"variable LANE_PLANNER"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-point_cloud_fusion","text":"static constexpr uint64_t POINT_CLOUD_FUSION = 65536;","title":"variable POINT_CLOUD_FUSION"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-ndt_localizer","text":"static constexpr uint64_t NDT_LOCALIZER = 65536;","title":"variable NDT_LOCALIZER"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-vehicle_interface","text":"static constexpr uint64_t VEHICLE_INTERFACE = 65536;","title":"variable VEHICLE_INTERFACE"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-lanelet_2_global_planner","text":"static constexpr uint64_t LANELET_2_GLOBAL_PLANNER = 65536;","title":"variable LANELET_2_GLOBAL_PLANNER"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-lanelet_2_map_loader","text":"static constexpr uint64_t LANELET_2_MAP_LOADER = 65536;","title":"variable LANELET_2_MAP_LOADER"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-behavior_planner","text":"static constexpr uint64_t BEHAVIOR_PLANNER = 65536;","title":"variable BEHAVIOR_PLANNER"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-behavior_planner_cycle","text":"static constexpr time_t BEHAVIOR_PLANNER_CYCLE = milliseconds(100); Updated on 2021-12-24 at 17:45:36 +0000","title":"variable BEHAVIOR_PLANNER_CYCLE"},{"location":"Classes/structreference__interfaces_1_1msg_1_1Message4kb/","text":"reference_interfaces::msg::Message4kb Public Attributes Name uint64 size reference_interfaces::msg::TransmissionStats stats int64 data Public Attributes Documentation variable size uint64 size; variable stats reference_interfaces::msg::TransmissionStats stats; variable data int64 data; Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_interfaces::msg::Message4kb"},{"location":"Classes/structreference__interfaces_1_1msg_1_1Message4kb/#reference_interfacesmsgmessage4kb","text":"","title":"reference_interfaces::msg::Message4kb"},{"location":"Classes/structreference__interfaces_1_1msg_1_1Message4kb/#public-attributes","text":"Name uint64 size reference_interfaces::msg::TransmissionStats stats int64 data","title":"Public Attributes"},{"location":"Classes/structreference__interfaces_1_1msg_1_1Message4kb/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structreference__interfaces_1_1msg_1_1Message4kb/#variable-size","text":"uint64 size;","title":"variable size"},{"location":"Classes/structreference__interfaces_1_1msg_1_1Message4kb/#variable-stats","text":"reference_interfaces::msg::TransmissionStats stats;","title":"variable stats"},{"location":"Classes/structreference__interfaces_1_1msg_1_1Message4kb/#variable-data","text":"int64 data; Updated on 2021-12-24 at 17:45:36 +0000","title":"variable data"},{"location":"Classes/structreference__interfaces_1_1msg_1_1TransmissionStats/","text":"reference_interfaces::msg::TransmissionStats Public Attributes Name uint64 timestamp uint32 sequence_number uint32 dropped_samples char node_name Public Attributes Documentation variable timestamp uint64 timestamp; variable sequence_number uint32 sequence_number; variable dropped_samples uint32 dropped_samples; variable node_name char node_name; Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_interfaces::msg::TransmissionStats"},{"location":"Classes/structreference__interfaces_1_1msg_1_1TransmissionStats/#reference_interfacesmsgtransmissionstats","text":"","title":"reference_interfaces::msg::TransmissionStats"},{"location":"Classes/structreference__interfaces_1_1msg_1_1TransmissionStats/#public-attributes","text":"Name uint64 timestamp uint32 sequence_number uint32 dropped_samples char node_name","title":"Public Attributes"},{"location":"Classes/structreference__interfaces_1_1msg_1_1TransmissionStats/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structreference__interfaces_1_1msg_1_1TransmissionStats/#variable-timestamp","text":"uint64 timestamp;","title":"variable timestamp"},{"location":"Classes/structreference__interfaces_1_1msg_1_1TransmissionStats/#variable-sequence_number","text":"uint32 sequence_number;","title":"variable sequence_number"},{"location":"Classes/structreference__interfaces_1_1msg_1_1TransmissionStats/#variable-dropped_samples","text":"uint32 dropped_samples;","title":"variable dropped_samples"},{"location":"Classes/structreference__interfaces_1_1msg_1_1TransmissionStats/#variable-node_name","text":"char node_name; Updated on 2021-12-24 at 17:45:36 +0000","title":"variable node_name"},{"location":"Classes/structsample__statistic__t/","text":"sample_statistic_t Public Attributes Name uint64_t timepoint_of_first_received_sample uint32_t previous_behavior_planner_sequence uint64_t previous_behavior_planner_time_stamp statistic_value_t latency statistic_value_t hot_path_latency statistic_value_t behavior_planner_period Public Attributes Documentation variable timepoint_of_first_received_sample uint64_t timepoint_of_first_received_sample = 0; variable previous_behavior_planner_sequence uint32_t previous_behavior_planner_sequence = 0; variable previous_behavior_planner_time_stamp uint64_t previous_behavior_planner_time_stamp = 0; variable latency statistic_value_t latency; variable hot_path_latency statistic_value_t hot_path_latency; variable behavior_planner_period statistic_value_t behavior_planner_period; Updated on 2021-12-24 at 17:45:36 +0000","title":"sample_statistic_t"},{"location":"Classes/structsample__statistic__t/#sample_statistic_t","text":"","title":"sample_statistic_t"},{"location":"Classes/structsample__statistic__t/#public-attributes","text":"Name uint64_t timepoint_of_first_received_sample uint32_t previous_behavior_planner_sequence uint64_t previous_behavior_planner_time_stamp statistic_value_t latency statistic_value_t hot_path_latency statistic_value_t behavior_planner_period","title":"Public Attributes"},{"location":"Classes/structsample__statistic__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structsample__statistic__t/#variable-timepoint_of_first_received_sample","text":"uint64_t timepoint_of_first_received_sample = 0;","title":"variable timepoint_of_first_received_sample"},{"location":"Classes/structsample__statistic__t/#variable-previous_behavior_planner_sequence","text":"uint32_t previous_behavior_planner_sequence = 0;","title":"variable previous_behavior_planner_sequence"},{"location":"Classes/structsample__statistic__t/#variable-previous_behavior_planner_time_stamp","text":"uint64_t previous_behavior_planner_time_stamp = 0;","title":"variable previous_behavior_planner_time_stamp"},{"location":"Classes/structsample__statistic__t/#variable-latency","text":"statistic_value_t latency;","title":"variable latency"},{"location":"Classes/structsample__statistic__t/#variable-hot_path_latency","text":"statistic_value_t hot_path_latency;","title":"variable hot_path_latency"},{"location":"Classes/structsample__statistic__t/#variable-behavior_planner_period","text":"statistic_value_t behavior_planner_period; Updated on 2021-12-24 at 17:45:36 +0000","title":"variable behavior_planner_period"},{"location":"Classes/structstatistic__value__t/","text":"statistic_value_t Public Functions Name void set (const uint64_t value) Public Attributes Name double average double deviation uint64_t min uint64_t max uint64_t current uint64_t total_number std::string suffix double adjustment double m2 Public Functions Documentation function set inline void set( const uint64_t value ) Public Attributes Documentation variable average double average = 0.0; variable deviation double deviation = 0.0; variable min uint64_t min = std::numeric_limits<uint64_t>::max(); variable max uint64_t max = 0; variable current uint64_t current = 0; variable total_number uint64_t total_number = 0; variable suffix std::string suffix; variable adjustment double adjustment = 0.0; variable m2 double m2 = 0.0; Updated on 2021-12-24 at 17:45:36 +0000","title":"statistic_value_t"},{"location":"Classes/structstatistic__value__t/#statistic_value_t","text":"","title":"statistic_value_t"},{"location":"Classes/structstatistic__value__t/#public-functions","text":"Name void set (const uint64_t value)","title":"Public Functions"},{"location":"Classes/structstatistic__value__t/#public-attributes","text":"Name double average double deviation uint64_t min uint64_t max uint64_t current uint64_t total_number std::string suffix double adjustment double m2","title":"Public Attributes"},{"location":"Classes/structstatistic__value__t/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/structstatistic__value__t/#function-set","text":"inline void set( const uint64_t value )","title":"function set"},{"location":"Classes/structstatistic__value__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structstatistic__value__t/#variable-average","text":"double average = 0.0;","title":"variable average"},{"location":"Classes/structstatistic__value__t/#variable-deviation","text":"double deviation = 0.0;","title":"variable deviation"},{"location":"Classes/structstatistic__value__t/#variable-min","text":"uint64_t min = std::numeric_limits<uint64_t>::max();","title":"variable min"},{"location":"Classes/structstatistic__value__t/#variable-max","text":"uint64_t max = 0;","title":"variable max"},{"location":"Classes/structstatistic__value__t/#variable-current","text":"uint64_t current = 0;","title":"variable current"},{"location":"Classes/structstatistic__value__t/#variable-total_number","text":"uint64_t total_number = 0;","title":"variable total_number"},{"location":"Classes/structstatistic__value__t/#variable-suffix","text":"std::string suffix;","title":"variable suffix"},{"location":"Classes/structstatistic__value__t/#variable-adjustment","text":"double adjustment = 0.0;","title":"variable adjustment"},{"location":"Classes/structstatistic__value__t/#variable-m2","text":"double m2 = 0.0; Updated on 2021-12-24 at 17:45:36 +0000","title":"variable m2"},{"location":"Examples/","text":"Examples Updated on 2021-12-24 at 17:45:36 +0000","title":"Examples"},{"location":"Examples/#examples","text":"Updated on 2021-12-24 at 17:45:36 +0000","title":"Examples"},{"location":"Files/","text":"Files file CMakeLists.txt file CMakeLists.txt file CMakeLists.txt file README.md file README.md file README.md dir autoware_reference_system dir autoware_reference_system/include dir autoware_reference_system/include/autoware_reference_system dir autoware_reference_system/include/autoware_reference_system/system dir autoware_reference_system/include/autoware_reference_system/system/timing file autoware_reference_system/include/autoware_reference_system/system/timing/benchmark.hpp file autoware_reference_system/include/autoware_reference_system/system/timing/default.hpp file autoware_reference_system/include/autoware_reference_system/autoware_system_builder.hpp file autoware_reference_system/include/autoware_reference_system/autoware_system_builder_utils.hpp dir autoware_reference_system/src dir autoware_reference_system/src/ros2 dir autoware_reference_system/src/ros2/executor file autoware_reference_system/src/ros2/executor/autoware_default_cbg.cpp file autoware_reference_system/src/ros2/executor/autoware_default_multithreaded.cpp file autoware_reference_system/src/ros2/executor/autoware_default_prioritized.cpp file autoware_reference_system/src/ros2/executor/autoware_default_singlethreaded.cpp file autoware_reference_system/src/ros2/executor/autoware_default_staticsinglethreaded.cpp file autoware_reference_system/src/ros2/number_cruncher_benchmark.cpp dir autoware_reference_system/test file autoware_reference_system/test/callback_duration.py file autoware_reference_system/test/constants.py file autoware_reference_system/test/dropped_messages.py file autoware_reference_system/test/errors.py file autoware_reference_system/test/generate_callback_traces.py file autoware_reference_system/test/generate_reports.py file autoware_reference_system/test/generate_std_traces.py file autoware_reference_system/test/generate_summary_reports.py file autoware_reference_system/test/memory_usage.py file autoware_reference_system/test/std_latency.py file autoware_reference_system/test/test_autoware_reference_system.cpp file autoware_reference_system/test/test_platform.py file autoware_reference_system/test/test_requirements.py file autoware_reference_system/test/trace_utils.py file autoware_reference_system/test/utils.py dir reference_interfaces dir reference_interfaces/msg file reference_interfaces/msg/Message4kb.idl file reference_interfaces/msg/TransmissionStats.idl dir reference_system dir reference_system/include dir reference_system/include/reference_system file reference_system/include/reference_system/msg_types.hpp file reference_system/include/reference_system/number_cruncher.hpp dir reference_system/include/reference_system/nodes dir reference_system/include/reference_system/nodes/rclcpp file reference_system/include/reference_system/nodes/rclcpp/command.hpp file reference_system/include/reference_system/nodes/rclcpp/cyclic.hpp file reference_system/include/reference_system/nodes/rclcpp/fusion.hpp file reference_system/include/reference_system/nodes/rclcpp/intersection.hpp file reference_system/include/reference_system/nodes/rclcpp/sensor.hpp file reference_system/include/reference_system/nodes/rclcpp/transform.hpp file reference_system/include/reference_system/nodes/settings.hpp dir reference_system/include/reference_system/system dir reference_system/include/reference_system/system/type file reference_system/include/reference_system/system/type/rclcpp_system.hpp file reference_system/include/reference_system/system/systems.hpp file reference_system/include/reference_system/sample_management.hpp dir reference_system/test file reference_system/test/gtest_main.cpp file reference_system/test/test_fixtures.hpp file reference_system/test/test_number_cruncher.cpp file reference_system/test/test_reference_system_rclcpp.cpp file reference_system/test/test_sample_management.cpp Updated on 2021-12-24 at 17:45:36 +0000","title":"Files"},{"location":"Files/#files","text":"file CMakeLists.txt file CMakeLists.txt file CMakeLists.txt file README.md file README.md file README.md dir autoware_reference_system dir autoware_reference_system/include dir autoware_reference_system/include/autoware_reference_system dir autoware_reference_system/include/autoware_reference_system/system dir autoware_reference_system/include/autoware_reference_system/system/timing file autoware_reference_system/include/autoware_reference_system/system/timing/benchmark.hpp file autoware_reference_system/include/autoware_reference_system/system/timing/default.hpp file autoware_reference_system/include/autoware_reference_system/autoware_system_builder.hpp file autoware_reference_system/include/autoware_reference_system/autoware_system_builder_utils.hpp dir autoware_reference_system/src dir autoware_reference_system/src/ros2 dir autoware_reference_system/src/ros2/executor file autoware_reference_system/src/ros2/executor/autoware_default_cbg.cpp file autoware_reference_system/src/ros2/executor/autoware_default_multithreaded.cpp file autoware_reference_system/src/ros2/executor/autoware_default_prioritized.cpp file autoware_reference_system/src/ros2/executor/autoware_default_singlethreaded.cpp file autoware_reference_system/src/ros2/executor/autoware_default_staticsinglethreaded.cpp file autoware_reference_system/src/ros2/number_cruncher_benchmark.cpp dir autoware_reference_system/test file autoware_reference_system/test/callback_duration.py file autoware_reference_system/test/constants.py file autoware_reference_system/test/dropped_messages.py file autoware_reference_system/test/errors.py file autoware_reference_system/test/generate_callback_traces.py file autoware_reference_system/test/generate_reports.py file autoware_reference_system/test/generate_std_traces.py file autoware_reference_system/test/generate_summary_reports.py file autoware_reference_system/test/memory_usage.py file autoware_reference_system/test/std_latency.py file autoware_reference_system/test/test_autoware_reference_system.cpp file autoware_reference_system/test/test_platform.py file autoware_reference_system/test/test_requirements.py file autoware_reference_system/test/trace_utils.py file autoware_reference_system/test/utils.py dir reference_interfaces dir reference_interfaces/msg file reference_interfaces/msg/Message4kb.idl file reference_interfaces/msg/TransmissionStats.idl dir reference_system dir reference_system/include dir reference_system/include/reference_system file reference_system/include/reference_system/msg_types.hpp file reference_system/include/reference_system/number_cruncher.hpp dir reference_system/include/reference_system/nodes dir reference_system/include/reference_system/nodes/rclcpp file reference_system/include/reference_system/nodes/rclcpp/command.hpp file reference_system/include/reference_system/nodes/rclcpp/cyclic.hpp file reference_system/include/reference_system/nodes/rclcpp/fusion.hpp file reference_system/include/reference_system/nodes/rclcpp/intersection.hpp file reference_system/include/reference_system/nodes/rclcpp/sensor.hpp file reference_system/include/reference_system/nodes/rclcpp/transform.hpp file reference_system/include/reference_system/nodes/settings.hpp dir reference_system/include/reference_system/system dir reference_system/include/reference_system/system/type file reference_system/include/reference_system/system/type/rclcpp_system.hpp file reference_system/include/reference_system/system/systems.hpp file reference_system/include/reference_system/sample_management.hpp dir reference_system/test file reference_system/test/gtest_main.cpp file reference_system/test/test_fixtures.hpp file reference_system/test/test_number_cruncher.cpp file reference_system/test/test_reference_system_rclcpp.cpp file reference_system/test/test_sample_management.cpp Updated on 2021-12-24 at 17:45:36 +0000","title":"Files"},{"location":"Files/Message4kb_8idl/","text":"reference_interfaces/msg/Message4kb.idl Namespaces Name reference_interfaces reference_interfaces::msg reference_interfaces::msg::Message4kb_Constants Classes Name struct reference_interfaces::msg::Message4kb Source code #include \"reference_interfaces/msg/TransmissionStats.idl\" module reference_interfaces { module msg { module Message4kb_Constants { const uint64 STATS_CAPACITY = 63; }; struct Message4kb { uint64 size; // 8 reference_interfaces::msg::TransmissionStats stats[63]; // + 4032 = 63 * 64 int64 data[7]; // + 56 = 7 * 8 //----------------- // 4096 }; }; }; Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_interfaces/msg/Message4kb.idl"},{"location":"Files/Message4kb_8idl/#reference_interfacesmsgmessage4kbidl","text":"","title":"reference_interfaces/msg/Message4kb.idl"},{"location":"Files/Message4kb_8idl/#namespaces","text":"Name reference_interfaces reference_interfaces::msg reference_interfaces::msg::Message4kb_Constants","title":"Namespaces"},{"location":"Files/Message4kb_8idl/#classes","text":"Name struct reference_interfaces::msg::Message4kb","title":"Classes"},{"location":"Files/Message4kb_8idl/#source-code","text":"#include \"reference_interfaces/msg/TransmissionStats.idl\" module reference_interfaces { module msg { module Message4kb_Constants { const uint64 STATS_CAPACITY = 63; }; struct Message4kb { uint64 size; // 8 reference_interfaces::msg::TransmissionStats stats[63]; // + 4032 = 63 * 64 int64 data[7]; // + 56 = 7 * 8 //----------------- // 4096 }; }; }; Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/README_8md/","text":"README.md Source code # Overview [![CI status](https://github.com/ros-realtime/reference-system/actions/workflows/colcon-build.yml/badge.svg)](https://github.com/ros-realtime/reference-system/actions/workflows/colcon-build.yml) With the distributed development of ROS across many different organizations it is sometimes hard to benchmark and concretely show how a certain change to a certain system improves or reduces the performance of that system. For example did a change from one executor to another actually reduce the CPU or was it something else entirely? In order to try and address this problem we at [Apex.AI](https://apex.ai) would like to propose a definition of a [_reference system_](#reference-system) that simulates a real world scenario - in this first case Autoware.Auto and its lidar data pipeline - that can be repeated no matter the underlying change of any piece of the full stack (i.e. executor, DDS or even RMW). ![Node graph of reference-system-autoware](content/img/autoware_reference_system.svg) Future _reference systems_ could be proposed that are more complex using the same basic node building blocks within the `reference_system` package. ## Reference System A _reference system_ is defined by: - A [platform](#supported-platforms) is defined by: - Hardware (e.g. an off-the-shelf single-board computer, embedded ECU, etc.) - if there are multiple configurations available for such hardware, ensure it is specified - Operating System (OS) like RT linux, QNX, etc. along with any special configurations made - for simplicity and ease of benchmarking, **all nodes must run on a single process** - a fixed number of nodes - each node with: - a fixed number of publishers and subscribers - a fixed _processing time_ or a fixed _publishing rate_ - a fixed _message type_ of fixed size to be used for every _node_. With these defined attributes the _reference system_ can be replicated across many different possible configurations to be used to benchmark each configuration against the other in a reliable and fair manner. With this approach [portable and repeatable tests](#testing) can also be defined to reliably confirm if a given _reference system_ meets the requirements. ## Supported Platforms To enable as many people as possible to replicate this reference system, the platform(s) were chosen to be easily accessible (inexpensive, high volume), have lots of documentation, large community use and will be supported well into the future. Platforms were not chosen for performance of the reference system - we know we could run \u201cfaster\u201d with a more powerful CPU or GPU but then it would be harder for others to validate findings and test their own configurations. Accessibility is the key here and will be considered if more platforms want to be added to this benchmark list. **Platforms:** - [Raspberry Pi 4B](https://www.raspberrypi.org/products/raspberry-pi-4-model-b/): - 4 GB RAM version is the assumed default - other versions could also be tested / added by the community - [real-time linux kernel](https://github.com/ros-realtime/rt-kernel-docker-builder) *Note: create an [issue](https://github.com/ros-realtime/reference-system-autoware/issues/) to add more platforms to the list, keeping in mind the above criteria* ## Concept Overview Rather than trying to write code to cover all potential variations of executors, APIs, and future features we cannot even imagine today we have chosen instead to define what we call a \u201creference system\u201d based on part of a real-world system, [Autoware.Auto](https://www.autoware.org/autoware-auto). The above node graph can be boiled down to only a handful of node \"types\" that are replicated to make this complex system: **Node Types:** 1. [**Sensor Node**](reference_system/include/reference_system/nodes/rclcpp/sensor.hpp) - input node to system - one publisher, zero subscribers - publishes message cyclically at some fixed frequency 2. [**Transform Node**](reference_system/include/reference_system/nodes/rclcpp/transform.hpp) - one subscriber, one publisher - starts processing for N milliseconds after a message is received - publishes message after processing is complete 3. [**Fusion Node**](reference_system/include/reference_system/nodes/rclcpp/fusion.hpp) - 2 subscribers, one publisher - starts processing for N milliseconds after a message is received **from all** subscriptions - publishes message after processing is complete 4. [**Cyclic Node**](reference_system/include/reference_system/nodes/rclcpp/cyclic.hpp) - N subscribers, one publisher - cyclically processes all received messages since the last cycle for N milliseconds - publishes message after processing is complete 5. [**Command Node**](reference_system/include/reference_system/nodes/rclcpp/command.hpp) - prints output stats everytime a message is received 6. [**Intersection Node**](reference_system/include/reference_system/nodes/rclcpp/intersection.hpp) - behaves like N transform nodes - N subscribers, N publisher bundled together in one-to-one connections - starts processing on connection where sample was received - publishes message after processing is complete These basic building-block nodes can be mixed-and-matched to create quite complex systems that replicate real-world scenarios to benchmark different configurations against each other. ## Reference Systems Overview The first reference system benchmark proposed is based on the *Autoware.Auto* lidar data pipeline as stated above and shown in the node graph image above as well. 1. [**Autoware Reference System**](autoware_reference_system/README.md) - ROS2: - Executors: - Default: - [Single Threaded](autoware_reference_system/src/ros2/executor/autoware_default_singlethreaded.cpp) - [Static Single Threaded](autoware_reference_system/src/ros2/executor/autoware_default_staticsinglethreaded.cpp) - [Multithreaded](autoware_reference_system/src/ros2/executor/autoware_default_multithreaded.cpp) Results below show various characteristics of the same simulated system (Autoware.Auto). To add your own executor to the list above follow the [*how to add your custom executor*](#how-to-implement-your-custom-executor) section below. ## Benchmark Results Results will be added to different tagged releases along with the specific configurations ran during the tests. ## Testing and Dependencies Tests and dependencies will be written uniquely for each _reference system._ Please go to the `README.md` file specific for the _reference system_ you would like to run to view the instructions on how to set it up and run yourself. - [Autoware Reference System](autoware_reference_system/README.md) ## Contributing If you see a missing configuration on the list above that you would like to see benchmarked against please follow the steps below to request it to be added. - look over the open / closed [issues](https://github.com/ros-realtime/reference-system-autoware/issues/) to make sure there isn't already an open ticket for the configuration you are looking for create `include/reference_system/MY_EXECUTOR_NAME_nodes` ## How to Implement Your Custom Executor 1. Read over [the above documentation](#concept-overview) on the base node types 2. Review the base [`rclcpp nodes`](reference_system/include/reference_system/nodes/rclcpp) that are provided and determine if your executor can use them 3. If you cannot, implment your own version of each base node type and place the source in [with the other nodes in the `reference_system`.](reference_system/include/reference_system/nodes) 4. Add your new nodes as a seperate `node system` in [the `reference_system` package](reference_system/include/reference_system/system/systems.hpp) 5. Copy one of the provided example `.cpp` files from the [`src/ros2/executor`](autoware_reference_system/src/ros2/executor) directory and replace the `create_autoware_nodes` template type with your new `node system` which should be in the `system/systems.hpp` file already included 6. Add new `.cpp` source file as a new executable in the `CMakelist.txt` 7. Add new executable to test wtihin the `CMakelist.txt` 8. Build and run tests! ## Setup Raspberry Pi 4 for the test The goal is to provide a clean computation environment for the test avoiding an interference of other Ubuntu components. ### Setup a constant CPU frequency Frequency is setup to 1.50 GHz for all CPUs ```bash # run it as root sudo su echo -n \"setup constant CPU frequency to 1.50 GHz ... \" # disable ondemand governor systemctl disable ondemand # set performance governor for all cpus echo performance | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor >/dev/null # set constant frequency echo 1500000 | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_min_freq >/dev/null echo 1500000 | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_max_freq >/dev/null # reset frequency counters echo 1 | tee /sys/devices/system/cpu/cpu*/cpufreq/stats/reset >/dev/null echo done sleep 1 # get freq info echo `cpufreq-info | grep stats | cut -d ' ' -f 23-25` Isolate CPUs CPU 2,3 are isolated to run tests. sudo apt install -y sysstat u-boot-tools # modify kernel cmdline cd ~ dd if=/boot/firmware/boot.scr of=boot.script bs=72 skip=1 # edit boot.script and modify bootargs to ubuntu@ubuntu:~$ cat boot.script | grep \"setenv bootargs\" | head -1 setenv bootargs \" ${bootargs} rcu_nocbs=2,3 nohz_full=2,3 isolcpus=2,3 irqaffinity=0,1 audit=0 watchdog=0 skew_tick=1 quiet splash\" # generate boot.scr mkimage -A arm64 -O linux -T script -C none -d boot.script boot.scr # replace boot.scr sudo cp boot.scr /boot/firmware/boot.scr sudo reboot # check cmdline ubuntu@ubuntu:~$ cat /proc/cmdline coherent_pool=1M 8250.nr_uarts=1 snd_bcm2835.enable_compat_alsa=0 snd_bcm2835.enable_hdmi=1 bcm2708_fb.fbwidth=0 bcm2708_fb.fbheight=0 bcm2708_fb.fbswap=1 smsc95xx.macaddr=DC:A6:32:2E:5 4:97 vc_mem.mem_base=0x3ec00000 vc_mem.mem_size=0x40000000 net.ifnames=0 dwc_otg.lpm_enable=0 console=ttyS0,115200 console=tty1 root=LABEL=writable rootfstype=ext4 elevator=deadline roo twait fixrtc rcu_nocbs=2,3 nohz_full=2,3 isolcpus=2,3 irqaffinity=0,1 audit=0 watchdog=0 skew_tick=1 quiet splash # check interrupts # Only the number of interrupts handled by CPU 0,1 increases. watch -n1 cat /proc/interrupts # check soft interrupts watch -n1 cat /proc/softirqs # check isolated CPUs cat /sys/devices/system/cpu/isolated 2-3 cat /sys/devices/system/cpu/present 0-3 # run reference system on CPU2 taskset -c 2 install/autoware_reference_system/lib/autoware_reference_system/autoware_default_singlethreaded > /dev/null # get pid RF_PID=`pidof autoware_default_singlethreaded` && cat /proc/$RF_PID/status | grep ^Cpu # check how many threads are running ps -aL | grep $RF_PID 3835 3835 ttyS0 00:03:46 autoware_defaul 3835 3836 ttyS0 00:00:00 autoware_defaul 3835 3837 ttyS0 00:00:00 autoware_defaul 3835 3838 ttyS0 00:00:00 autoware_defaul 3835 3839 ttyS0 00:00:00 gc 3835 3840 ttyS0 00:00:00 dq.builtins 3835 3841 ttyS0 00:00:00 dq.user 3835 3842 ttyS0 00:00:00 tev 3835 3843 ttyS0 00:00:00 recv 3835 3844 ttyS0 00:00:00 recvMC 3835 3845 ttyS0 00:00:00 recvUC 3835 3846 ttyS0 00:00:00 autoware_defaul Hints If you run colcon build on a Raspberry Pi 4 with little memory, use export MAKEFLAGS=\"-j 1\" to inhibit parallelism. Otherwise, the system could hang due to memory swapping. ``` Updated on 2021-12-24 at 17:45:36 +0000","title":"README.md"},{"location":"Files/README_8md/#readmemd","text":"","title":"README.md"},{"location":"Files/README_8md/#source-code","text":"# Overview [![CI status](https://github.com/ros-realtime/reference-system/actions/workflows/colcon-build.yml/badge.svg)](https://github.com/ros-realtime/reference-system/actions/workflows/colcon-build.yml) With the distributed development of ROS across many different organizations it is sometimes hard to benchmark and concretely show how a certain change to a certain system improves or reduces the performance of that system. For example did a change from one executor to another actually reduce the CPU or was it something else entirely? In order to try and address this problem we at [Apex.AI](https://apex.ai) would like to propose a definition of a [_reference system_](#reference-system) that simulates a real world scenario - in this first case Autoware.Auto and its lidar data pipeline - that can be repeated no matter the underlying change of any piece of the full stack (i.e. executor, DDS or even RMW). ![Node graph of reference-system-autoware](content/img/autoware_reference_system.svg) Future _reference systems_ could be proposed that are more complex using the same basic node building blocks within the `reference_system` package. ## Reference System A _reference system_ is defined by: - A [platform](#supported-platforms) is defined by: - Hardware (e.g. an off-the-shelf single-board computer, embedded ECU, etc.) - if there are multiple configurations available for such hardware, ensure it is specified - Operating System (OS) like RT linux, QNX, etc. along with any special configurations made - for simplicity and ease of benchmarking, **all nodes must run on a single process** - a fixed number of nodes - each node with: - a fixed number of publishers and subscribers - a fixed _processing time_ or a fixed _publishing rate_ - a fixed _message type_ of fixed size to be used for every _node_. With these defined attributes the _reference system_ can be replicated across many different possible configurations to be used to benchmark each configuration against the other in a reliable and fair manner. With this approach [portable and repeatable tests](#testing) can also be defined to reliably confirm if a given _reference system_ meets the requirements. ## Supported Platforms To enable as many people as possible to replicate this reference system, the platform(s) were chosen to be easily accessible (inexpensive, high volume), have lots of documentation, large community use and will be supported well into the future. Platforms were not chosen for performance of the reference system - we know we could run \u201cfaster\u201d with a more powerful CPU or GPU but then it would be harder for others to validate findings and test their own configurations. Accessibility is the key here and will be considered if more platforms want to be added to this benchmark list. **Platforms:** - [Raspberry Pi 4B](https://www.raspberrypi.org/products/raspberry-pi-4-model-b/): - 4 GB RAM version is the assumed default - other versions could also be tested / added by the community - [real-time linux kernel](https://github.com/ros-realtime/rt-kernel-docker-builder) *Note: create an [issue](https://github.com/ros-realtime/reference-system-autoware/issues/) to add more platforms to the list, keeping in mind the above criteria* ## Concept Overview Rather than trying to write code to cover all potential variations of executors, APIs, and future features we cannot even imagine today we have chosen instead to define what we call a \u201creference system\u201d based on part of a real-world system, [Autoware.Auto](https://www.autoware.org/autoware-auto). The above node graph can be boiled down to only a handful of node \"types\" that are replicated to make this complex system: **Node Types:** 1. [**Sensor Node**](reference_system/include/reference_system/nodes/rclcpp/sensor.hpp) - input node to system - one publisher, zero subscribers - publishes message cyclically at some fixed frequency 2. [**Transform Node**](reference_system/include/reference_system/nodes/rclcpp/transform.hpp) - one subscriber, one publisher - starts processing for N milliseconds after a message is received - publishes message after processing is complete 3. [**Fusion Node**](reference_system/include/reference_system/nodes/rclcpp/fusion.hpp) - 2 subscribers, one publisher - starts processing for N milliseconds after a message is received **from all** subscriptions - publishes message after processing is complete 4. [**Cyclic Node**](reference_system/include/reference_system/nodes/rclcpp/cyclic.hpp) - N subscribers, one publisher - cyclically processes all received messages since the last cycle for N milliseconds - publishes message after processing is complete 5. [**Command Node**](reference_system/include/reference_system/nodes/rclcpp/command.hpp) - prints output stats everytime a message is received 6. [**Intersection Node**](reference_system/include/reference_system/nodes/rclcpp/intersection.hpp) - behaves like N transform nodes - N subscribers, N publisher bundled together in one-to-one connections - starts processing on connection where sample was received - publishes message after processing is complete These basic building-block nodes can be mixed-and-matched to create quite complex systems that replicate real-world scenarios to benchmark different configurations against each other. ## Reference Systems Overview The first reference system benchmark proposed is based on the *Autoware.Auto* lidar data pipeline as stated above and shown in the node graph image above as well. 1. [**Autoware Reference System**](autoware_reference_system/README.md) - ROS2: - Executors: - Default: - [Single Threaded](autoware_reference_system/src/ros2/executor/autoware_default_singlethreaded.cpp) - [Static Single Threaded](autoware_reference_system/src/ros2/executor/autoware_default_staticsinglethreaded.cpp) - [Multithreaded](autoware_reference_system/src/ros2/executor/autoware_default_multithreaded.cpp) Results below show various characteristics of the same simulated system (Autoware.Auto). To add your own executor to the list above follow the [*how to add your custom executor*](#how-to-implement-your-custom-executor) section below. ## Benchmark Results Results will be added to different tagged releases along with the specific configurations ran during the tests. ## Testing and Dependencies Tests and dependencies will be written uniquely for each _reference system._ Please go to the `README.md` file specific for the _reference system_ you would like to run to view the instructions on how to set it up and run yourself. - [Autoware Reference System](autoware_reference_system/README.md) ## Contributing If you see a missing configuration on the list above that you would like to see benchmarked against please follow the steps below to request it to be added. - look over the open / closed [issues](https://github.com/ros-realtime/reference-system-autoware/issues/) to make sure there isn't already an open ticket for the configuration you are looking for create `include/reference_system/MY_EXECUTOR_NAME_nodes` ## How to Implement Your Custom Executor 1. Read over [the above documentation](#concept-overview) on the base node types 2. Review the base [`rclcpp nodes`](reference_system/include/reference_system/nodes/rclcpp) that are provided and determine if your executor can use them 3. If you cannot, implment your own version of each base node type and place the source in [with the other nodes in the `reference_system`.](reference_system/include/reference_system/nodes) 4. Add your new nodes as a seperate `node system` in [the `reference_system` package](reference_system/include/reference_system/system/systems.hpp) 5. Copy one of the provided example `.cpp` files from the [`src/ros2/executor`](autoware_reference_system/src/ros2/executor) directory and replace the `create_autoware_nodes` template type with your new `node system` which should be in the `system/systems.hpp` file already included 6. Add new `.cpp` source file as a new executable in the `CMakelist.txt` 7. Add new executable to test wtihin the `CMakelist.txt` 8. Build and run tests! ## Setup Raspberry Pi 4 for the test The goal is to provide a clean computation environment for the test avoiding an interference of other Ubuntu components. ### Setup a constant CPU frequency Frequency is setup to 1.50 GHz for all CPUs ```bash # run it as root sudo su echo -n \"setup constant CPU frequency to 1.50 GHz ... \" # disable ondemand governor systemctl disable ondemand # set performance governor for all cpus echo performance | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor >/dev/null # set constant frequency echo 1500000 | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_min_freq >/dev/null echo 1500000 | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_max_freq >/dev/null # reset frequency counters echo 1 | tee /sys/devices/system/cpu/cpu*/cpufreq/stats/reset >/dev/null echo done sleep 1 # get freq info echo `cpufreq-info | grep stats | cut -d ' ' -f 23-25`","title":"Source code"},{"location":"Files/README_8md/#isolate-cpus","text":"CPU 2,3 are isolated to run tests. sudo apt install -y sysstat u-boot-tools # modify kernel cmdline cd ~ dd if=/boot/firmware/boot.scr of=boot.script bs=72 skip=1 # edit boot.script and modify bootargs to ubuntu@ubuntu:~$ cat boot.script | grep \"setenv bootargs\" | head -1 setenv bootargs \" ${bootargs} rcu_nocbs=2,3 nohz_full=2,3 isolcpus=2,3 irqaffinity=0,1 audit=0 watchdog=0 skew_tick=1 quiet splash\" # generate boot.scr mkimage -A arm64 -O linux -T script -C none -d boot.script boot.scr # replace boot.scr sudo cp boot.scr /boot/firmware/boot.scr sudo reboot # check cmdline ubuntu@ubuntu:~$ cat /proc/cmdline coherent_pool=1M 8250.nr_uarts=1 snd_bcm2835.enable_compat_alsa=0 snd_bcm2835.enable_hdmi=1 bcm2708_fb.fbwidth=0 bcm2708_fb.fbheight=0 bcm2708_fb.fbswap=1 smsc95xx.macaddr=DC:A6:32:2E:5 4:97 vc_mem.mem_base=0x3ec00000 vc_mem.mem_size=0x40000000 net.ifnames=0 dwc_otg.lpm_enable=0 console=ttyS0,115200 console=tty1 root=LABEL=writable rootfstype=ext4 elevator=deadline roo twait fixrtc rcu_nocbs=2,3 nohz_full=2,3 isolcpus=2,3 irqaffinity=0,1 audit=0 watchdog=0 skew_tick=1 quiet splash # check interrupts # Only the number of interrupts handled by CPU 0,1 increases. watch -n1 cat /proc/interrupts # check soft interrupts watch -n1 cat /proc/softirqs # check isolated CPUs cat /sys/devices/system/cpu/isolated 2-3 cat /sys/devices/system/cpu/present 0-3 # run reference system on CPU2 taskset -c 2 install/autoware_reference_system/lib/autoware_reference_system/autoware_default_singlethreaded > /dev/null # get pid RF_PID=`pidof autoware_default_singlethreaded` && cat /proc/$RF_PID/status | grep ^Cpu # check how many threads are running ps -aL | grep $RF_PID 3835 3835 ttyS0 00:03:46 autoware_defaul 3835 3836 ttyS0 00:00:00 autoware_defaul 3835 3837 ttyS0 00:00:00 autoware_defaul 3835 3838 ttyS0 00:00:00 autoware_defaul 3835 3839 ttyS0 00:00:00 gc 3835 3840 ttyS0 00:00:00 dq.builtins 3835 3841 ttyS0 00:00:00 dq.user 3835 3842 ttyS0 00:00:00 tev 3835 3843 ttyS0 00:00:00 recv 3835 3844 ttyS0 00:00:00 recvMC 3835 3845 ttyS0 00:00:00 recvUC 3835 3846 ttyS0 00:00:00 autoware_defaul","title":"Isolate CPUs"},{"location":"Files/README_8md/#hints","text":"If you run colcon build on a Raspberry Pi 4 with little memory, use export MAKEFLAGS=\"-j 1\" to inhibit parallelism. Otherwise, the system could hang due to memory swapping. ``` Updated on 2021-12-24 at 17:45:36 +0000","title":"Hints"},{"location":"Files/TransmissionStats_8idl/","text":"reference_interfaces/msg/TransmissionStats.idl Namespaces Name reference_interfaces reference_interfaces::msg reference_interfaces::msg::TransmissionStats_Constants Classes Name struct reference_interfaces::msg::TransmissionStats Source code module reference_interfaces { module msg { module TransmissionStats_Constants { const uint64 NODE_NAME_LENGTH = 48; }; struct TransmissionStats { // 64 bytes uint64 timestamp; uint32 sequence_number; uint32 dropped_samples; char node_name[48]; }; }; }; Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_interfaces/msg/TransmissionStats.idl"},{"location":"Files/TransmissionStats_8idl/#reference_interfacesmsgtransmissionstatsidl","text":"","title":"reference_interfaces/msg/TransmissionStats.idl"},{"location":"Files/TransmissionStats_8idl/#namespaces","text":"Name reference_interfaces reference_interfaces::msg reference_interfaces::msg::TransmissionStats_Constants","title":"Namespaces"},{"location":"Files/TransmissionStats_8idl/#classes","text":"Name struct reference_interfaces::msg::TransmissionStats","title":"Classes"},{"location":"Files/TransmissionStats_8idl/#source-code","text":"module reference_interfaces { module msg { module TransmissionStats_Constants { const uint64 NODE_NAME_LENGTH = 48; }; struct TransmissionStats { // 64 bytes uint64 timestamp; uint32 sequence_number; uint32 dropped_samples; char node_name[48]; }; }; }; Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/autoware__default__cbg_8cpp/","text":"autoware_reference_system/src/ros2/executor/autoware_default_cbg.cpp Functions Name int main (int argc, char * argv[]) Functions Documentation function main int main( int argc, char * argv[] ) Source code // Copyright (c) 2021 by Robert Bosch GmbH // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <memory> #include <string> #include <vector> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/system/systems.hpp\" #include \"autoware_reference_system/autoware_system_builder.hpp\" #include \"autoware_reference_system/autoware_system_builder_utils.hpp\" #include \"autoware_reference_system/system/timing/benchmark.hpp\" #include \"autoware_reference_system/system/timing/default.hpp\" int main(int argc, char * argv[]) { rclcpp::init(argc, argv); using TimeConfig = nodes::timing::Default; // uncomment for benchmarking // using TimeConfig = nodes::timing::BenchmarkCPUUsage; // set_benchmark_mode(true); std::vector<std::shared_ptr<rclcpp::Node>> nodes = create_autoware_nodes<RclcppSystem, TimeConfig>(); rclcpp::Logger logger = nodes[0]->get_logger(); std::vector<std::string> critpath_front_node_names = {\"FrontLidarDriver\", \"PointsTransformerFront\"}; std::vector<std::string> critpath_rear_node_names = {\"RearLidarDriver\", \"PointsTransformerRear\"}; std::vector<std::string> critpath_inner_node_names = {\"PointCloudFusion\", \"RayGroundFilter\", \"ObjectCollisionEstimator\"}; rclcpp::executors::SingleThreadedExecutor critpath_front_executor; rclcpp::executors::SingleThreadedExecutor critpath_rear_executor; rclcpp::executors::SingleThreadedExecutor critpath_inner_executor; rclcpp::executors::SingleThreadedExecutor other_executor; add_nodes_to_executor_by_names(&critpath_front_executor, nodes, critpath_front_node_names); add_nodes_to_executor_by_names(&critpath_rear_executor, nodes, critpath_rear_node_names); add_nodes_to_executor_by_names(&critpath_inner_executor, nodes, critpath_inner_node_names); auto euclidean_cluster_detector_node = std::dynamic_pointer_cast<nodes::rclcpp_system::Intersection>( find_node_or_fail(nodes, \"EuclideanClusterDetector\")); critpath_inner_executor.add_callback_group( euclidean_cluster_detector_node->get_callback_group_of_subscription( \"/RayGroundFilter\"), euclidean_cluster_detector_node->get_node_base_interface()); other_executor.add_node(euclidean_cluster_detector_node->get_node_base_interface()); add_unassociated_nodes_to_executor(&other_executor, nodes); auto critpath_front_thread = std::thread( [&]() { set_nice_level_of_current_thread(-5); critpath_front_executor.spin(); }); auto critpath_rear_thread = std::thread( [&]() { set_nice_level_of_current_thread(-5); critpath_rear_executor.spin(); }); auto critpath_inner_thread = std::thread( [&]() { set_nice_level_of_current_thread(-5); critpath_inner_executor.spin(); }); auto other_thread = std::thread( [&]() { set_nice_level_of_current_thread(+5); other_executor.spin(); }); critpath_front_thread.join(); critpath_rear_thread.join(); critpath_inner_thread.join(); other_thread.join(); nodes.clear(); rclcpp::shutdown(); return 0; } Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/src/ros2/executor/autoware_default_cbg.cpp"},{"location":"Files/autoware__default__cbg_8cpp/#autoware_reference_systemsrcros2executorautoware_default_cbgcpp","text":"","title":"autoware_reference_system/src/ros2/executor/autoware_default_cbg.cpp"},{"location":"Files/autoware__default__cbg_8cpp/#functions","text":"Name int main (int argc, char * argv[])","title":"Functions"},{"location":"Files/autoware__default__cbg_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/autoware__default__cbg_8cpp/#function-main","text":"int main( int argc, char * argv[] )","title":"function main"},{"location":"Files/autoware__default__cbg_8cpp/#source-code","text":"// Copyright (c) 2021 by Robert Bosch GmbH // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <memory> #include <string> #include <vector> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/system/systems.hpp\" #include \"autoware_reference_system/autoware_system_builder.hpp\" #include \"autoware_reference_system/autoware_system_builder_utils.hpp\" #include \"autoware_reference_system/system/timing/benchmark.hpp\" #include \"autoware_reference_system/system/timing/default.hpp\" int main(int argc, char * argv[]) { rclcpp::init(argc, argv); using TimeConfig = nodes::timing::Default; // uncomment for benchmarking // using TimeConfig = nodes::timing::BenchmarkCPUUsage; // set_benchmark_mode(true); std::vector<std::shared_ptr<rclcpp::Node>> nodes = create_autoware_nodes<RclcppSystem, TimeConfig>(); rclcpp::Logger logger = nodes[0]->get_logger(); std::vector<std::string> critpath_front_node_names = {\"FrontLidarDriver\", \"PointsTransformerFront\"}; std::vector<std::string> critpath_rear_node_names = {\"RearLidarDriver\", \"PointsTransformerRear\"}; std::vector<std::string> critpath_inner_node_names = {\"PointCloudFusion\", \"RayGroundFilter\", \"ObjectCollisionEstimator\"}; rclcpp::executors::SingleThreadedExecutor critpath_front_executor; rclcpp::executors::SingleThreadedExecutor critpath_rear_executor; rclcpp::executors::SingleThreadedExecutor critpath_inner_executor; rclcpp::executors::SingleThreadedExecutor other_executor; add_nodes_to_executor_by_names(&critpath_front_executor, nodes, critpath_front_node_names); add_nodes_to_executor_by_names(&critpath_rear_executor, nodes, critpath_rear_node_names); add_nodes_to_executor_by_names(&critpath_inner_executor, nodes, critpath_inner_node_names); auto euclidean_cluster_detector_node = std::dynamic_pointer_cast<nodes::rclcpp_system::Intersection>( find_node_or_fail(nodes, \"EuclideanClusterDetector\")); critpath_inner_executor.add_callback_group( euclidean_cluster_detector_node->get_callback_group_of_subscription( \"/RayGroundFilter\"), euclidean_cluster_detector_node->get_node_base_interface()); other_executor.add_node(euclidean_cluster_detector_node->get_node_base_interface()); add_unassociated_nodes_to_executor(&other_executor, nodes); auto critpath_front_thread = std::thread( [&]() { set_nice_level_of_current_thread(-5); critpath_front_executor.spin(); }); auto critpath_rear_thread = std::thread( [&]() { set_nice_level_of_current_thread(-5); critpath_rear_executor.spin(); }); auto critpath_inner_thread = std::thread( [&]() { set_nice_level_of_current_thread(-5); critpath_inner_executor.spin(); }); auto other_thread = std::thread( [&]() { set_nice_level_of_current_thread(+5); other_executor.spin(); }); critpath_front_thread.join(); critpath_rear_thread.join(); critpath_inner_thread.join(); other_thread.join(); nodes.clear(); rclcpp::shutdown(); return 0; } Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/autoware__default__multithreaded_8cpp/","text":"autoware_reference_system/src/ros2/executor/autoware_default_multithreaded.cpp Functions Name int main (int argc, char * argv[]) Functions Documentation function main int main( int argc, char * argv[] ) Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/system/systems.hpp\" #include \"autoware_reference_system/autoware_system_builder.hpp\" #include \"autoware_reference_system/system/timing/benchmark.hpp\" #include \"autoware_reference_system/system/timing/default.hpp\" int main(int argc, char * argv[]) { rclcpp::init(argc, argv); using TimeConfig = nodes::timing::Default; // uncomment for benchmarking // using TimeConfig = nodes::timing::BenchmarkCPUUsage; // set_benchmark_mode(true); auto nodes = create_autoware_nodes<RclcppSystem, TimeConfig>(); rclcpp::executors::MultiThreadedExecutor executor; for (auto & node : nodes) { executor.add_node(node); } executor.spin(); nodes.clear(); rclcpp::shutdown(); return 0; } Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/src/ros2/executor/autoware_default_multithreaded.cpp"},{"location":"Files/autoware__default__multithreaded_8cpp/#autoware_reference_systemsrcros2executorautoware_default_multithreadedcpp","text":"","title":"autoware_reference_system/src/ros2/executor/autoware_default_multithreaded.cpp"},{"location":"Files/autoware__default__multithreaded_8cpp/#functions","text":"Name int main (int argc, char * argv[])","title":"Functions"},{"location":"Files/autoware__default__multithreaded_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/autoware__default__multithreaded_8cpp/#function-main","text":"int main( int argc, char * argv[] )","title":"function main"},{"location":"Files/autoware__default__multithreaded_8cpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/system/systems.hpp\" #include \"autoware_reference_system/autoware_system_builder.hpp\" #include \"autoware_reference_system/system/timing/benchmark.hpp\" #include \"autoware_reference_system/system/timing/default.hpp\" int main(int argc, char * argv[]) { rclcpp::init(argc, argv); using TimeConfig = nodes::timing::Default; // uncomment for benchmarking // using TimeConfig = nodes::timing::BenchmarkCPUUsage; // set_benchmark_mode(true); auto nodes = create_autoware_nodes<RclcppSystem, TimeConfig>(); rclcpp::executors::MultiThreadedExecutor executor; for (auto & node : nodes) { executor.add_node(node); } executor.spin(); nodes.clear(); rclcpp::shutdown(); return 0; } Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/autoware__default__prioritized_8cpp/","text":"autoware_reference_system/src/ros2/executor/autoware_default_prioritized.cpp Functions Name int main (int argc, char * argv[]) Functions Documentation function main int main( int argc, char * argv[] ) Source code // Copyright (c) 2021 by Robert Bosch GmbH // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <memory> #include <string> #include <vector> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/system/systems.hpp\" #include \"autoware_reference_system/autoware_system_builder.hpp\" #include \"autoware_reference_system/autoware_system_builder_utils.hpp\" #include \"autoware_reference_system/system/timing/benchmark.hpp\" #include \"autoware_reference_system/system/timing/default.hpp\" int main(int argc, char * argv[]) { rclcpp::init(argc, argv); using TimeConfig = nodes::timing::Default; // uncomment for benchmarking // using TimeConfig = nodes::timing::BenchmarkCPUUsage; // set_benchmark_mode(true); std::vector<std::shared_ptr<rclcpp::Node>> nodes = create_autoware_nodes<RclcppSystem, TimeConfig>(); rclcpp::Logger logger = nodes[0]->get_logger(); std::vector<std::string> critpath_front_node_names = {\"FrontLidarDriver\", \"PointsTransformerFront\"}; std::vector<std::string> critpath_rear_node_names = {\"RearLidarDriver\", \"PointsTransformerRear\"}; std::vector<std::string> critpath_inner_node_names = {\"PointCloudFusion\", \"RayGroundFilter\", \"EuclideanClusterDetector\", \"ObjectCollisionEstimator\"}; rclcpp::executors::SingleThreadedExecutor critpath_front_executor; rclcpp::executors::SingleThreadedExecutor critpath_rear_executor; rclcpp::executors::SingleThreadedExecutor critpath_inner_executor; rclcpp::executors::SingleThreadedExecutor other_executor; add_nodes_to_executor_by_names(&critpath_front_executor, nodes, critpath_front_node_names); add_nodes_to_executor_by_names(&critpath_rear_executor, nodes, critpath_rear_node_names); add_nodes_to_executor_by_names(&critpath_inner_executor, nodes, critpath_inner_node_names); add_unassociated_nodes_to_executor(&other_executor, nodes); auto critpath_front_thread = std::thread( [&]() { set_nice_level_of_current_thread(-5); critpath_front_executor.spin(); }); auto critpath_rear_thread = std::thread( [&]() { set_nice_level_of_current_thread(-5); critpath_rear_executor.spin(); }); auto critpath_inner_thread = std::thread( [&]() { set_nice_level_of_current_thread(-5); critpath_inner_executor.spin(); }); auto other_thread = std::thread( [&]() { set_nice_level_of_current_thread(+5); other_executor.spin(); }); critpath_front_thread.join(); critpath_rear_thread.join(); critpath_inner_thread.join(); other_thread.join(); nodes.clear(); rclcpp::shutdown(); return 0; } Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/src/ros2/executor/autoware_default_prioritized.cpp"},{"location":"Files/autoware__default__prioritized_8cpp/#autoware_reference_systemsrcros2executorautoware_default_prioritizedcpp","text":"","title":"autoware_reference_system/src/ros2/executor/autoware_default_prioritized.cpp"},{"location":"Files/autoware__default__prioritized_8cpp/#functions","text":"Name int main (int argc, char * argv[])","title":"Functions"},{"location":"Files/autoware__default__prioritized_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/autoware__default__prioritized_8cpp/#function-main","text":"int main( int argc, char * argv[] )","title":"function main"},{"location":"Files/autoware__default__prioritized_8cpp/#source-code","text":"// Copyright (c) 2021 by Robert Bosch GmbH // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <memory> #include <string> #include <vector> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/system/systems.hpp\" #include \"autoware_reference_system/autoware_system_builder.hpp\" #include \"autoware_reference_system/autoware_system_builder_utils.hpp\" #include \"autoware_reference_system/system/timing/benchmark.hpp\" #include \"autoware_reference_system/system/timing/default.hpp\" int main(int argc, char * argv[]) { rclcpp::init(argc, argv); using TimeConfig = nodes::timing::Default; // uncomment for benchmarking // using TimeConfig = nodes::timing::BenchmarkCPUUsage; // set_benchmark_mode(true); std::vector<std::shared_ptr<rclcpp::Node>> nodes = create_autoware_nodes<RclcppSystem, TimeConfig>(); rclcpp::Logger logger = nodes[0]->get_logger(); std::vector<std::string> critpath_front_node_names = {\"FrontLidarDriver\", \"PointsTransformerFront\"}; std::vector<std::string> critpath_rear_node_names = {\"RearLidarDriver\", \"PointsTransformerRear\"}; std::vector<std::string> critpath_inner_node_names = {\"PointCloudFusion\", \"RayGroundFilter\", \"EuclideanClusterDetector\", \"ObjectCollisionEstimator\"}; rclcpp::executors::SingleThreadedExecutor critpath_front_executor; rclcpp::executors::SingleThreadedExecutor critpath_rear_executor; rclcpp::executors::SingleThreadedExecutor critpath_inner_executor; rclcpp::executors::SingleThreadedExecutor other_executor; add_nodes_to_executor_by_names(&critpath_front_executor, nodes, critpath_front_node_names); add_nodes_to_executor_by_names(&critpath_rear_executor, nodes, critpath_rear_node_names); add_nodes_to_executor_by_names(&critpath_inner_executor, nodes, critpath_inner_node_names); add_unassociated_nodes_to_executor(&other_executor, nodes); auto critpath_front_thread = std::thread( [&]() { set_nice_level_of_current_thread(-5); critpath_front_executor.spin(); }); auto critpath_rear_thread = std::thread( [&]() { set_nice_level_of_current_thread(-5); critpath_rear_executor.spin(); }); auto critpath_inner_thread = std::thread( [&]() { set_nice_level_of_current_thread(-5); critpath_inner_executor.spin(); }); auto other_thread = std::thread( [&]() { set_nice_level_of_current_thread(+5); other_executor.spin(); }); critpath_front_thread.join(); critpath_rear_thread.join(); critpath_inner_thread.join(); other_thread.join(); nodes.clear(); rclcpp::shutdown(); return 0; } Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/autoware__default__singlethreaded_8cpp/","text":"autoware_reference_system/src/ros2/executor/autoware_default_singlethreaded.cpp Functions Name int main (int argc, char * argv[]) Functions Documentation function main int main( int argc, char * argv[] ) Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/system/systems.hpp\" #include \"autoware_reference_system/autoware_system_builder.hpp\" #include \"autoware_reference_system/system/timing/benchmark.hpp\" #include \"autoware_reference_system/system/timing/default.hpp\" int main(int argc, char * argv[]) { rclcpp::init(argc, argv); using TimeConfig = nodes::timing::Default; // uncomment for benchmarking // using TimeConfig = nodes::timing::BenchmarkCPUUsage; // set_benchmark_mode(true); auto nodes = create_autoware_nodes<RclcppSystem, TimeConfig>(); rclcpp::executors::SingleThreadedExecutor executor; for (auto & node : nodes) { executor.add_node(node); } executor.spin(); nodes.clear(); rclcpp::shutdown(); return 0; } Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/src/ros2/executor/autoware_default_singlethreaded.cpp"},{"location":"Files/autoware__default__singlethreaded_8cpp/#autoware_reference_systemsrcros2executorautoware_default_singlethreadedcpp","text":"","title":"autoware_reference_system/src/ros2/executor/autoware_default_singlethreaded.cpp"},{"location":"Files/autoware__default__singlethreaded_8cpp/#functions","text":"Name int main (int argc, char * argv[])","title":"Functions"},{"location":"Files/autoware__default__singlethreaded_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/autoware__default__singlethreaded_8cpp/#function-main","text":"int main( int argc, char * argv[] )","title":"function main"},{"location":"Files/autoware__default__singlethreaded_8cpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/system/systems.hpp\" #include \"autoware_reference_system/autoware_system_builder.hpp\" #include \"autoware_reference_system/system/timing/benchmark.hpp\" #include \"autoware_reference_system/system/timing/default.hpp\" int main(int argc, char * argv[]) { rclcpp::init(argc, argv); using TimeConfig = nodes::timing::Default; // uncomment for benchmarking // using TimeConfig = nodes::timing::BenchmarkCPUUsage; // set_benchmark_mode(true); auto nodes = create_autoware_nodes<RclcppSystem, TimeConfig>(); rclcpp::executors::SingleThreadedExecutor executor; for (auto & node : nodes) { executor.add_node(node); } executor.spin(); nodes.clear(); rclcpp::shutdown(); return 0; } Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/autoware__default__staticsinglethreaded_8cpp/","text":"autoware_reference_system/src/ros2/executor/autoware_default_staticsinglethreaded.cpp Functions Name int main (int argc, char * argv[]) Functions Documentation function main int main( int argc, char * argv[] ) Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/system/systems.hpp\" #include \"autoware_reference_system/autoware_system_builder.hpp\" #include \"autoware_reference_system/system/timing/benchmark.hpp\" #include \"autoware_reference_system/system/timing/default.hpp\" int main(int argc, char * argv[]) { rclcpp::init(argc, argv); using TimeConfig = nodes::timing::Default; // uncomment for benchmarking // using TimeConfig = nodes::timing::BenchmarkCPUUsage; // set_benchmark_mode(true); auto nodes = create_autoware_nodes<RclcppSystem, TimeConfig>(); rclcpp::executors::StaticSingleThreadedExecutor executor; for (auto & node : nodes) { executor.add_node(node); } executor.spin(); nodes.clear(); rclcpp::shutdown(); return 0; } Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/src/ros2/executor/autoware_default_staticsinglethreaded.cpp"},{"location":"Files/autoware__default__staticsinglethreaded_8cpp/#autoware_reference_systemsrcros2executorautoware_default_staticsinglethreadedcpp","text":"","title":"autoware_reference_system/src/ros2/executor/autoware_default_staticsinglethreaded.cpp"},{"location":"Files/autoware__default__staticsinglethreaded_8cpp/#functions","text":"Name int main (int argc, char * argv[])","title":"Functions"},{"location":"Files/autoware__default__staticsinglethreaded_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/autoware__default__staticsinglethreaded_8cpp/#function-main","text":"int main( int argc, char * argv[] )","title":"function main"},{"location":"Files/autoware__default__staticsinglethreaded_8cpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/system/systems.hpp\" #include \"autoware_reference_system/autoware_system_builder.hpp\" #include \"autoware_reference_system/system/timing/benchmark.hpp\" #include \"autoware_reference_system/system/timing/default.hpp\" int main(int argc, char * argv[]) { rclcpp::init(argc, argv); using TimeConfig = nodes::timing::Default; // uncomment for benchmarking // using TimeConfig = nodes::timing::BenchmarkCPUUsage; // set_benchmark_mode(true); auto nodes = create_autoware_nodes<RclcppSystem, TimeConfig>(); rclcpp::executors::StaticSingleThreadedExecutor executor; for (auto & node : nodes) { executor.add_node(node); } executor.spin(); nodes.clear(); rclcpp::shutdown(); return 0; } Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/","text":"CMakeLists.txt Functions Name cmake_minimum_required (VERSION 3. 5) VERSION_GREATER_EQUAL ament_auto_add_executable (autoware_default_cbg src/ros2/executor/autoware_default_cbg. cpp) find_package (ament_lint_auto REQUIRED) set (ROS_HOME $ENV{HOME}/. ros) endif () set (ROS_LOG_DIR ${CMAKE_INSTALL_PREFIX}/../../log/latest_test/${PROJECT_NAME} ) ament_add_pytest_test ( ${PROJECT_NAME} test/test_platform.py TIMEOUT) set (TEST_TARGETS autoware_default_singlethreaded autoware_default_staticsinglethreaded autoware_default_multithreaded) VERSION_GREATER_EQUAL list (APPEND TEST_TARGETS autoware_default_cbg) VERSION_GREATER_EQUAL Skipping autoware_default_cbg as it requires ROS distro Galactic or later Skipping autoware_default_prioritized due to missing super user right message (WARNING , \"Skipping autoware_default_cbg due to missing super \" \"user right!\" ) message (STATUS \"Removing callback trace tests\" ) MATCHES OFF list (REVERSE rmws_available) list (LENGTH rmws_available COUNT) cmake test_requirements cmake include ( ${CMAKE_CURRENT_SOURCE_DIR}/cmake/generate_traces.) test_requirements ( ${exe}) foreach (rmw_implementation ${rmws_available} ) REQUIRED foreach (time ${RUN_TIMES} ) generate_traces ( ${exe} ${type} ${time}) Functions Documentation function cmake_minimum_required cmake_minimum_required( VERSION 3. 5 ) function ament_auto_add_executable VERSION_GREATER_EQUAL ament_auto_add_executable( autoware_default_cbg src/ros2/executor/autoware_default_cbg. cpp ) function find_package find_package( ament_lint_auto REQUIRED ) function set set( ROS_HOME $ENV{HOME}/. ros ) function endif endif() function set set( ROS_LOG_DIR ${CMAKE_INSTALL_PREFIX}/../../log/latest_test/${PROJECT_NAME} ) function ament_add_pytest_test ament_add_pytest_test( ${PROJECT_NAME} test/test_platform.py TIMEOUT ) function set set( TEST_TARGETS autoware_default_singlethreaded autoware_default_staticsinglethreaded autoware_default_multithreaded ) function list VERSION_GREATER_EQUAL list( APPEND TEST_TARGETS autoware_default_cbg ) function message VERSION_GREATER_EQUAL Skipping autoware_default_cbg as it requires ROS distro Galactic or later Skipping autoware_default_prioritized due to missing super user right message( WARNING , \"Skipping autoware_default_cbg due to missing super \" \"user right!\" ) function message message( STATUS \"Removing callback trace tests\" ) function list MATCHES OFF list( REVERSE rmws_available ) function list list( LENGTH rmws_available COUNT ) function include cmake test_requirements cmake include( ${CMAKE_CURRENT_SOURCE_DIR}/cmake/generate_traces. ) function test_requirements test_requirements( ${exe} ) function foreach foreach( rmw_implementation ${rmws_available} ) function foreach REQUIRED foreach( time ${RUN_TIMES} ) function generate_traces generate_traces( ${exe} ${type} ${time} ) Source code cmake_minimum_required(VERSION 3.5) project(autoware_reference_system) option(RUN_BENCHMARK \"Run the full benchmark tests\" OFF) # default to off for CI purposes option(SKIP_TRACING \"Skip the ros2_tracing (LTTng) tests\" ON) # default to off unitl #35 is closed option(TEST_PLATFORM \"Test if running on a supported platform\" OFF) # default to off for development purposes option(ALL_RMWS \"Run tests for all available RMWs\" OFF) # default to off so only one RMW is tested by default if(NOT CMAKE_CXX_STANDARD) set(CMAKE_CXX_STANDARD 17) endif() if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\") add_compile_options(-Wall -Wextra -Wpedantic) endif() find_package(ament_cmake_auto REQUIRED) ament_auto_find_build_dependencies() # Single Threaded Executor ament_auto_add_executable(autoware_default_singlethreaded src/ros2/executor/autoware_default_singlethreaded.cpp ) # Static Single Threaded Executor ament_auto_add_executable(autoware_default_staticsinglethreaded src/ros2/executor/autoware_default_staticsinglethreaded.cpp ) # Multi Threaded Executor ament_auto_add_executable(autoware_default_multithreaded src/ros2/executor/autoware_default_multithreaded.cpp ) # Number Cruncher Benchmark ament_auto_add_executable(number_cruncher_benchmark src/ros2/number_cruncher_benchmark.cpp ) # Multiple executors with suitable prioritization of critical path. ament_auto_add_executable(autoware_default_prioritized src/ros2/executor/autoware_default_prioritized.cpp ) if(\"${rclcpp_VERSION}\" VERSION_GREATER_EQUAL \"9.0.0\") # i.e. from Galactic on # Multiple executors on callback-group-level with suitable prioritization of critical path. ament_auto_add_executable(autoware_default_cbg src/ros2/executor/autoware_default_cbg.cpp ) endif() # Add new executors to test here #ament_auto_add_executable(autoware_default_custom # src/ros2/executor/autoware_default_custom.cpp #) if(${BUILD_TESTING}) find_package(ament_lint_auto REQUIRED) ament_lint_auto_find_test_dependencies() # tracetools uses ROS_HOME to place tracing data if(NOT DEFINED $ENV{ROS_HOME}) set(ROS_HOME $ENV{HOME}/.ros) else() set(ROS_HOME $ENV{ROS_HOME}) endif() # std trace type uses LOG directory if(NOT DEFINED $ENV{ROS_LOG_DIR}) set(ROS_LOG_DIR ${CMAKE_INSTALL_PREFIX}/../../log/latest_test/${PROJECT_NAME}) else() set(ROS_LOG_DIR $ENV{ROS_LOG_DIR}) endif() set(DEFAULT_TIMEOUT 300) # seconds, 300 = roughly 5min if(${TEST_PLATFORM}) # check current platform ament_add_pytest_test(${PROJECT_NAME} test/test_platform.py TIMEOUT 5 ) endif() if(${RUN_BENCHMARK}) # Add executables here to test set(TEST_TARGETS autoware_default_singlethreaded autoware_default_staticsinglethreaded autoware_default_multithreaded #autoware_default_custom ) execute_process(COMMAND bash -c \"id -u\" OUTPUT_VARIABLE CURRENT_UID) if(CURRENT_UID EQUAL \"0\") list(APPEND TEST_TARGETS autoware_default_prioritized) if(\"${rclcpp_VERSION}\" VERSION_GREATER_EQUAL \"9.0.0\") # i.e. from Galactic on list(APPEND TEST_TARGETS autoware_default_cbg) else() message(WARNING, \"Skipping autoware_default_cbg as it requires ROS \" \"distro Galactic or later!\") endif() else() message(WARNING, \"Skipping autoware_default_prioritized due to missing \" \"super user right!\") message(WARNING, \"Skipping autoware_default_cbg due to missing super \" \"user right!\") endif() # Add more run times here (time to run traces for) set(RUN_TIMES 5 # 10 # 30 # 60 ) # Add more trace types here # had to seperate out traces due to dropped events # see https://github.com/ros-realtime/reference-system/pull/33#issuecomment-928264240 set(TRACE_TYPES callback # uses ros2_tracing, LTTng memory # uses psrecord std # parses the log files that include the prints from std::cout # cpu # built into memory tests using psrecord ) # remove ros2_tracing trace_types if SKIP_TRACING is ON if(${SKIP_TRACING}) message(STATUS \"Removing callback trace tests\") list(REMOVE_ITEM TRACE_TYPES \"callback\") endif() find_package(ros_testing REQUIRED) # get available rmw implementations find_package(rmw_implementation_cmake REQUIRED) get_available_rmw_implementations(rmws_available) # only use default RMW by default if(${ALL_RMWS} MATCHES OFF) list(REVERSE rmws_available) foreach(rmw ${rmws_available}) list(LENGTH rmws_available COUNT) if(NOT COUNT MATCHES 1) # message(\"Removing ${rmw} from tests\") list(REMOVE_AT rmws_available COUNT) endif() endforeach() endif() # include cmake functions to use later on include(${CMAKE_CURRENT_SOURCE_DIR}/cmake/test_requirements.cmake) include(${CMAKE_CURRENT_SOURCE_DIR}/cmake/generate_traces.cmake) include(${CMAKE_CURRENT_SOURCE_DIR}/cmake/generate_report.cmake) include(${CMAKE_CURRENT_SOURCE_DIR}/cmake/generate_summary_report.cmake) # check each executable matches the system requirements foreach(exe ${TEST_TARGETS}) test_requirements(${exe} 3) endforeach() # generate traces for each executable foreach(exe ${TEST_TARGETS}) # loop over each rmw implmentation foreach(rmw_implementation ${rmws_available}) find_package(\"${rmw_implementation}\" REQUIRED) foreach(time ${RUN_TIMES}) foreach(type ${TRACE_TYPES}) generate_traces(${exe} ${type} ${time}) generate_report(${exe} ${type} ${time}) endforeach() endforeach() endforeach() endforeach() foreach(trace_type ${TRACE_TYPES}) foreach(time ${RUN_TIMES}) generate_summary_report(${trace_type} ${time}) endforeach() endforeach() endif() endif() ament_auto_package( INSTALL_TO_SHARE test scripts ) Updated on 2021-12-24 at 17:45:36 +0000","title":"CMakeLists.txt"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#cmakeliststxt","text":"","title":"CMakeLists.txt"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#functions","text":"Name cmake_minimum_required (VERSION 3. 5) VERSION_GREATER_EQUAL ament_auto_add_executable (autoware_default_cbg src/ros2/executor/autoware_default_cbg. cpp) find_package (ament_lint_auto REQUIRED) set (ROS_HOME $ENV{HOME}/. ros) endif () set (ROS_LOG_DIR ${CMAKE_INSTALL_PREFIX}/../../log/latest_test/${PROJECT_NAME} ) ament_add_pytest_test ( ${PROJECT_NAME} test/test_platform.py TIMEOUT) set (TEST_TARGETS autoware_default_singlethreaded autoware_default_staticsinglethreaded autoware_default_multithreaded) VERSION_GREATER_EQUAL list (APPEND TEST_TARGETS autoware_default_cbg) VERSION_GREATER_EQUAL Skipping autoware_default_cbg as it requires ROS distro Galactic or later Skipping autoware_default_prioritized due to missing super user right message (WARNING , \"Skipping autoware_default_cbg due to missing super \" \"user right!\" ) message (STATUS \"Removing callback trace tests\" ) MATCHES OFF list (REVERSE rmws_available) list (LENGTH rmws_available COUNT) cmake test_requirements cmake include ( ${CMAKE_CURRENT_SOURCE_DIR}/cmake/generate_traces.) test_requirements ( ${exe}) foreach (rmw_implementation ${rmws_available} ) REQUIRED foreach (time ${RUN_TIMES} ) generate_traces ( ${exe} ${type} ${time})","title":"Functions"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#function-cmake_minimum_required","text":"cmake_minimum_required( VERSION 3. 5 )","title":"function cmake_minimum_required"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#function-ament_auto_add_executable","text":"VERSION_GREATER_EQUAL ament_auto_add_executable( autoware_default_cbg src/ros2/executor/autoware_default_cbg. cpp )","title":"function ament_auto_add_executable"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#function-find_package","text":"find_package( ament_lint_auto REQUIRED )","title":"function find_package"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#function-set","text":"set( ROS_HOME $ENV{HOME}/. ros )","title":"function set"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#function-endif","text":"endif()","title":"function endif"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#function-set_1","text":"set( ROS_LOG_DIR ${CMAKE_INSTALL_PREFIX}/../../log/latest_test/${PROJECT_NAME} )","title":"function set"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#function-ament_add_pytest_test","text":"ament_add_pytest_test( ${PROJECT_NAME} test/test_platform.py TIMEOUT )","title":"function ament_add_pytest_test"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#function-set_2","text":"set( TEST_TARGETS autoware_default_singlethreaded autoware_default_staticsinglethreaded autoware_default_multithreaded )","title":"function set"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#function-list","text":"VERSION_GREATER_EQUAL list( APPEND TEST_TARGETS autoware_default_cbg )","title":"function list"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#function-message","text":"VERSION_GREATER_EQUAL Skipping autoware_default_cbg as it requires ROS distro Galactic or later Skipping autoware_default_prioritized due to missing super user right message( WARNING , \"Skipping autoware_default_cbg due to missing super \" \"user right!\" )","title":"function message"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#function-message_1","text":"message( STATUS \"Removing callback trace tests\" )","title":"function message"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#function-list_1","text":"MATCHES OFF list( REVERSE rmws_available )","title":"function list"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#function-list_2","text":"list( LENGTH rmws_available COUNT )","title":"function list"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#function-include","text":"cmake test_requirements cmake include( ${CMAKE_CURRENT_SOURCE_DIR}/cmake/generate_traces. )","title":"function include"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#function-test_requirements","text":"test_requirements( ${exe} )","title":"function test_requirements"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#function-foreach","text":"foreach( rmw_implementation ${rmws_available} )","title":"function foreach"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#function-foreach_1","text":"REQUIRED foreach( time ${RUN_TIMES} )","title":"function foreach"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#function-generate_traces","text":"generate_traces( ${exe} ${type} ${time} )","title":"function generate_traces"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#source-code","text":"cmake_minimum_required(VERSION 3.5) project(autoware_reference_system) option(RUN_BENCHMARK \"Run the full benchmark tests\" OFF) # default to off for CI purposes option(SKIP_TRACING \"Skip the ros2_tracing (LTTng) tests\" ON) # default to off unitl #35 is closed option(TEST_PLATFORM \"Test if running on a supported platform\" OFF) # default to off for development purposes option(ALL_RMWS \"Run tests for all available RMWs\" OFF) # default to off so only one RMW is tested by default if(NOT CMAKE_CXX_STANDARD) set(CMAKE_CXX_STANDARD 17) endif() if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\") add_compile_options(-Wall -Wextra -Wpedantic) endif() find_package(ament_cmake_auto REQUIRED) ament_auto_find_build_dependencies() # Single Threaded Executor ament_auto_add_executable(autoware_default_singlethreaded src/ros2/executor/autoware_default_singlethreaded.cpp ) # Static Single Threaded Executor ament_auto_add_executable(autoware_default_staticsinglethreaded src/ros2/executor/autoware_default_staticsinglethreaded.cpp ) # Multi Threaded Executor ament_auto_add_executable(autoware_default_multithreaded src/ros2/executor/autoware_default_multithreaded.cpp ) # Number Cruncher Benchmark ament_auto_add_executable(number_cruncher_benchmark src/ros2/number_cruncher_benchmark.cpp ) # Multiple executors with suitable prioritization of critical path. ament_auto_add_executable(autoware_default_prioritized src/ros2/executor/autoware_default_prioritized.cpp ) if(\"${rclcpp_VERSION}\" VERSION_GREATER_EQUAL \"9.0.0\") # i.e. from Galactic on # Multiple executors on callback-group-level with suitable prioritization of critical path. ament_auto_add_executable(autoware_default_cbg src/ros2/executor/autoware_default_cbg.cpp ) endif() # Add new executors to test here #ament_auto_add_executable(autoware_default_custom # src/ros2/executor/autoware_default_custom.cpp #) if(${BUILD_TESTING}) find_package(ament_lint_auto REQUIRED) ament_lint_auto_find_test_dependencies() # tracetools uses ROS_HOME to place tracing data if(NOT DEFINED $ENV{ROS_HOME}) set(ROS_HOME $ENV{HOME}/.ros) else() set(ROS_HOME $ENV{ROS_HOME}) endif() # std trace type uses LOG directory if(NOT DEFINED $ENV{ROS_LOG_DIR}) set(ROS_LOG_DIR ${CMAKE_INSTALL_PREFIX}/../../log/latest_test/${PROJECT_NAME}) else() set(ROS_LOG_DIR $ENV{ROS_LOG_DIR}) endif() set(DEFAULT_TIMEOUT 300) # seconds, 300 = roughly 5min if(${TEST_PLATFORM}) # check current platform ament_add_pytest_test(${PROJECT_NAME} test/test_platform.py TIMEOUT 5 ) endif() if(${RUN_BENCHMARK}) # Add executables here to test set(TEST_TARGETS autoware_default_singlethreaded autoware_default_staticsinglethreaded autoware_default_multithreaded #autoware_default_custom ) execute_process(COMMAND bash -c \"id -u\" OUTPUT_VARIABLE CURRENT_UID) if(CURRENT_UID EQUAL \"0\") list(APPEND TEST_TARGETS autoware_default_prioritized) if(\"${rclcpp_VERSION}\" VERSION_GREATER_EQUAL \"9.0.0\") # i.e. from Galactic on list(APPEND TEST_TARGETS autoware_default_cbg) else() message(WARNING, \"Skipping autoware_default_cbg as it requires ROS \" \"distro Galactic or later!\") endif() else() message(WARNING, \"Skipping autoware_default_prioritized due to missing \" \"super user right!\") message(WARNING, \"Skipping autoware_default_cbg due to missing super \" \"user right!\") endif() # Add more run times here (time to run traces for) set(RUN_TIMES 5 # 10 # 30 # 60 ) # Add more trace types here # had to seperate out traces due to dropped events # see https://github.com/ros-realtime/reference-system/pull/33#issuecomment-928264240 set(TRACE_TYPES callback # uses ros2_tracing, LTTng memory # uses psrecord std # parses the log files that include the prints from std::cout # cpu # built into memory tests using psrecord ) # remove ros2_tracing trace_types if SKIP_TRACING is ON if(${SKIP_TRACING}) message(STATUS \"Removing callback trace tests\") list(REMOVE_ITEM TRACE_TYPES \"callback\") endif() find_package(ros_testing REQUIRED) # get available rmw implementations find_package(rmw_implementation_cmake REQUIRED) get_available_rmw_implementations(rmws_available) # only use default RMW by default if(${ALL_RMWS} MATCHES OFF) list(REVERSE rmws_available) foreach(rmw ${rmws_available}) list(LENGTH rmws_available COUNT) if(NOT COUNT MATCHES 1) # message(\"Removing ${rmw} from tests\") list(REMOVE_AT rmws_available COUNT) endif() endforeach() endif() # include cmake functions to use later on include(${CMAKE_CURRENT_SOURCE_DIR}/cmake/test_requirements.cmake) include(${CMAKE_CURRENT_SOURCE_DIR}/cmake/generate_traces.cmake) include(${CMAKE_CURRENT_SOURCE_DIR}/cmake/generate_report.cmake) include(${CMAKE_CURRENT_SOURCE_DIR}/cmake/generate_summary_report.cmake) # check each executable matches the system requirements foreach(exe ${TEST_TARGETS}) test_requirements(${exe} 3) endforeach() # generate traces for each executable foreach(exe ${TEST_TARGETS}) # loop over each rmw implmentation foreach(rmw_implementation ${rmws_available}) find_package(\"${rmw_implementation}\" REQUIRED) foreach(time ${RUN_TIMES}) foreach(type ${TRACE_TYPES}) generate_traces(${exe} ${type} ${time}) generate_report(${exe} ${type} ${time}) endforeach() endforeach() endforeach() endforeach() foreach(trace_type ${TRACE_TYPES}) foreach(time ${RUN_TIMES}) generate_summary_report(${trace_type} ${time}) endforeach() endforeach() endif() endif() ament_auto_package( INSTALL_TO_SHARE test scripts ) Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/autoware__reference__system_2README_8md/","text":"README.md Source code # autoware_reference_system This file is meant to define the Autoware Reference System and all of its nodes, topics and message types. ![Node graph of reference-system-autoware](../content/img/autoware_reference_system.svg) To get started and test this system yourself, head down to [the _Quick Start section_](#quick-start) and follow the instructions there. _See the [generating a node graph](#generate-node-graph) using graphviz section on how to generate the above image_ ## Evaluation Criteria The _autoware reference system_ was made with a few goals in mind. See the list below to get the complete picture of why certian tests are run and why this system was chosen as a good system to benchmark different executors. Each item below should have a corresponding test report with it or be able to be extracted from an existing test report. See the [testing](#running-the-tests) section for more details on how to generate your own test reports. If you believe we are missing another metric to measure executors by, please create an issue and let us know! ### **Key Performance Indicators (KPIs)** - **CPU utilization** - In general a lower CPU utilization is better since it enables you to choose a smaller CPU or have more functionality on a larger CPU for other things. - **The lower CPU utilization the better** - **Memory utilization** - In general a lower memory utilization is better since it enables you to choose a smaller memory or have more space for other things - **The lower memory utilization the better** - **Use latest samples, count dropped samples** - This is representative of the real-world where old sensor data is much less valuable than new sensor data - For example an image from 30 seconds ago wont help you to drive down the road as much as an image from 0.1 seconds ago) - If there is more than one new sample, the old ones will be dropped in favor of the newest sample - As a result, dropped messages may mean that information was lost - Fusion Nodes may drop messages by design if their inputs have different frequencies, do not count dropped messages for these nodes - Transform nodes should not drop messages though, and these should be counted - **The lower number of dropped samples the better** - **Every Front Lidar sample should cause update in Object Collision Estimator** - The Front and Rear Lidars have the same publishing frequency - This means Object Collision Estimator should run for every lidar sample - Count number of executions of Object Collision Estimator and Front Lidar and report any difference - **The smaller the difference in executions, the better** - **Lowest possible latency from Front Lidar to Object Collision Estimator** - As in the real world, we want to know as soon as possible if the reference system will collide with something - Measure the mean and max latency for this chain of nodes - **The lower latency of the signal chain the better** - **The Behavior Planner should be as cyclical as possible** - The desired behavior of the Behavior Planner is to be as cyclical as possible, meaning it should be executed as close to its set frequency of _100ms_ as possible - Measure the jitter and drift over time of the timer callback - **The lower the jitter and drift of the Behavior Node timer callback the better** ## Message Types A **single message type** is used for the entire _reference system_ when generating results in order to simplify the setup as well as make it more repeatible and extensible. This means **only one _message type_** from the list below is used during any given experimental run for every node in the reference system. 1. [**Message4kB**](../reference_interfaces/msg/Message4kb.idl) - reference message with a fixed size of 4 kilobytes (kB) Other messages with different fixed sizes could be added here in the future. When reporting results it will be important to include the _message type_ used duing the experiement so that comparisons can be done \"apples to apples\" and not \"apples to pears\". ## Autoware Reference System Built from [a handful of building-block node types](../README.md#concept-overview), each one of these nodes are meant to simulate a real-world node from the Autoware.Auto project lidar data pipeline. Under each node type are the requirements used for _this specific reference system_, `autoware_reference_system`. Future reference systems could have slightly different requirements and still use the same building-block node types. For simplicity's sake, every node except for the _command nodes_ only ever publishes one topic and this topic has the same name as the node that publishes it. However, each topic can be subscribed to by multiple different nodes. 1. [**Message Type**](#message-types) - all nodes use the same message type during any single test run - default _message type_: - [Message4kB](../reference_system/include/reference_system/msg_types.hpp#L21) - to be implemented: - Message64kB - Message256kB - Message512kB - Message1024kB - Message5120kB 2. [**Sensor Nodes**](../reference_system/include/reference_system/nodes/rclcpp/sensor.hpp) - all _sensor nodes_ have a publishing rate (cycle time) of [**100 milliseconds**](include/reference_system/system/timing/default.hpp#L26) - all _sensor_nodes_ publish the same _message type_ - total of **5 _sensor nodes_**: - [Front Lidar Driver](include/autoware_reference_system/autoware_system_builder.hpp#L38) - [Rear Lidar Driver](include/autoware_reference_system/autoware_system_builder.hpp#L44) - [Point Cloud Map](include/autoware_reference_system/autoware_system_builder.hpp#L50) - [Visualizer](include/autoware_reference_system/autoware_system_builder.hpp#L56) - [Lanelet2Map](include/autoware_reference_system/autoware_system_builder.hpp#62) 3. [**Transform Nodes**](../reference_system/include/reference_system/nodes/rclcpp/transform.hpp) - all _transform nodes_ have one subscriber and one publisher - all _transform nodes_ start processing for [**50 milliseconds**](include/autoware_reference_system/system/timing/default.hpp#L28) after a message is received - publishes message after processing is complete - total of **10 _transform nodes_:** - [Front Points Transformer](include/autoware_reference_system/autoware_system_builder.hpp#L69) - [Rear Points Transformer](include/autoware_reference_system/autoware_system_builder.hpp#L78) - [Voxel Grid Downsampler](include/autoware_reference_system/autoware_system_builder.hpp#L87) - [Point Cloud Map Loader](include/autoware_reference_system/autoware_system_builder.hpp#L96) - [Ray Ground Filter](include/autoware_reference_system/autoware_system_builder.hpp#L105) - [Object Collision Estimator](include/autoware_reference_system/autoware_system_builder.hpp#L123) - [MPC Controller](include/autoware_reference_system/autoware_system_builder.hpp#L132) - [Parking Planner](include/autoware_reference_system/autoware_system_builder.hpp#L141) - [Lane Planner](include/autoware_reference_system/autoware_system_builder.hpp#L150) 4. [**Fusion Nodes**](../reference_system/include/reference_system/nodes/rclcpp/fusion.hpp) - all _fusion nodes_ have **two subscribers** and one publisher for this _reference system_ - all _fusion nodes_ start processing for [**25 milliseconds**](include/autoware_reference_system/system/timing/default.hpp#L30) after a message is received **from all** subscriptions - all _fusion nodes_ have a max input time difference between the first input received and last input received before publishing of [**9999** seconds](include/autoware_reference_system/system/timing/benchmark.hpp) - publishes message after processing is complete - total of **5 _fusion nodes_:** - [Point Cloud Fusion](include/autoware_reference_system/autoware_system_builder.hpp#L160) - [NDT Localizer](include/autoware_reference_system/autoware_system_builder.hpp#L169) - [Vehicle Interface](include/autoware_reference_system/autoware_system_builder.hpp#L178) - [Lanelet2 Global Planner](include/autoware_reference_system/autoware_system_builder.hpp#L187) - [Lanelet 2 Map Loader](include/autoware_reference_system/autoware_system_builder.hpp#L196) 5. [**Cyclic Nodes**](../reference_system/include/reference_system/nodes/rclcpp/cyclic.hpp) - for this _reference system_ there is only [**1 _cyclic node_**](include/autoware_reference_system/autoware_system_builder.hpp#L206) - this _cyclic node_ has **6 subscribers**and one publisher - this _cyclic node_ starts processing for [**1 millisecond**](include/autoware_reference_system/system/timing/default.hpp#L32) after a message is received **from any** single subscription - publishes message after processing is complete 6. [**Command Nodes**](../reference_system/include/reference_system/nodes/rclcpp/command.hpp) - all _command nodes_ have **1 subscriber** and zero publishers - all _command nodes_ prints out the final latency statistics after a message is received on the specified topic - total of **2 _command nodes_:** - [VehicleDBWSystem](include/autoware_reference_system/autoware_system_builder.hpp#L222) - [IntersectionOutput](include/autoware_reference_system/autoware_system_builder.hpp#L227) 7. [**Intersection Nodes**](../reference_system/include/reference_system/nodes/rclcpp/intersection.hpp) - for this _reference system_ there is only [EuclideanClusterDetector](include/autoware_reference_system/autoware_system_builder.hpp#L206) - this _intersection node_ has **2 subscribers** and **2 publishers** - publishes message after processing is complete on the correspoding publisher ## Quick Start This section will go over how to clone, build and run the `autoware_reference_system` in order to generate your own test reports. ### Dependencies Before running the tests there are a few prerequisites to complete: - Install python depedencies used during test runs and report generation - `python3 -m pip install psrecord bokeh networkx numpy pandas` - Install dependencies using the following command from the `colcon_ws` directory: - `rosdep install --from-paths src --ignore-src -y` - Install LTTng and `ros2_tracing` [following the instructions in `ros2_tracing`](https://gitlab.com/ros-tracing/ros2_tracing#building) - _Note:_ if you are setting up [ a realtime linux kernel for a raspberry pi using this docker file](https://github.com/ros-realtime/rt-kernel-docker-builder#raspberry-pi-4-rt-linux-kernel), it should [already include LTTng](https://github.com/ros-realtime/rt-kernel-docker-builder/pull/18) - _Note:_ make sure to clone `ros2_tracing` into **the same workspace as where you put the `reference-system`**, the tests will not properly run if they are not in the same directory. **Tests will fail** if any of the above dependencies are missing on the machine. Once the above steps are complete you sould be ready to configure the setup for your platform and run the tests to generate some results. ## Configure Processing Time Many nodes in the reference system are actually performing some _psuedo work_ by finding prime numbers up until some _maximum value_. Depending on the platform, this _maximum value_ will need to be changed so that these nodes do not take an absurd amount of time. This _maximum value_ should be chosen on a platform-by-platform basis so that the total _run time_ of this work takes some desired length of time. In order to make finding this _maximum value_ a bit easier across many different platforms a simple [**number_cruncher_benchmark**](src/ros2/number_cruncher_benchmark.cpp) is provided that will loop over various _maximum values_ and spit out how long each one takes to run. After running this executable on your platform you should have a good idea what _maximum value_ you should use in your [timing configuration](include/autoware_reference_system/system/timing/default.hpp) so that each node does some measurable work for some desired amount of time. Here is an example output of the `number_cruncher_benchmark` run on a typical development platform (Intel 9i7): ros2 run autoware_reference_system number_cruncher_benchmark maximum_number run time 64 0.001609ms 128 0.002896ms 256 0.006614ms 512 0.035036ms 1024 0.050957ms 2048 0.092732ms 4096 0.22837ms 8192 0.566779ms 16384 1.48837ms 32768 3.64588ms 65536 9.6687ms 131072 24.1154ms 262144 62.3475ms 524288 162.762ms 1048576 429.882ms 2097152 1149.79ms Run the above command on your system, select your desired `run_time` and place the corresponding `maximum_number` in the [timing configuration file](include/autoware_reference_system/system/timing/default.hpp) for the desired nodes. ## Running the Tests Source your ROS distribution as well as your `ros2_tracing` overlay, compile this repository using the proper CMake arguments and generate some test results: **Make sure you've installed the required dependencies** as [outlined above](#dependencies) before trying to run these tests. ### Supported CMake Arguments - `RUN_BENCHMARK` - Tell CMake to build the benchmark tests that will check the reference system against its requirements before running a sweep of tests to generate trace files and reports - Without the `RUN_BENCHMARK` variable set to `ON` only the standard linter tests will be run - `TEST_PLATFORM` - Test CMake to build the tests to check if the tests are being run from a [supported platform](../README.md#supported-platforms) or not - This flag can be ommited if you would like to run the tests on a development system before running them on a supported platform - The platform tests themselves can and should be improved going forward and are only some simple checks today (architecture, number of CPUs, PREEMPT_RT flag, etc.) - Set this to `ON` to check if the current platform is supported - `SKIP_TRACING` - Set to `ON` to skip the `ros2_tracing` tests, aka the `callback` tests - This can greatly reduce the length of time the `colcon test` command takes to run - `ALL_RMWS` - Set this to `ON` if you'd like to run tests on all available RMWS as well - Otherwise use only default RMW (first one listed by CMake function `get_available_rmw_implementations`) - Defaults to `OFF` **Make sure you've installed the required dependencies** as [outlined above](#dependencies) before trying to run these tests. source your ROS distribution source /opt/ros/galactic/setup.bash cd to your colcon_ws with this repo and ros2_tracing inside cd /path/to/colcon_ws build packages with benchmark tests enabled colcon build --cmake-args -DRUN_BENCHMARK=TRUE -DTEST_PLATFORM=TRUE IMPORTANT source the newly built workspace to make sure to use the updated tracetools package source install/local_setup.bash run tests, generate traces and reports colcon test **Note 1:** some of the tests require super user privileges, to change thread priorities. If super user privileges are not available, these tests are excluded automatically. Run the above lines from a `sudo bash` or similar to include those tests. **Note 2:** during the testing _trace data_ generated from `LTTng` will be placed in `$ROS_HOME/tracing`. If the `$ROS_HOME/tracing` directory is missing the tests will automatically generate it for you. This directory should now hold tracing data and reports for all `ros2_tracing` tests performed. Additionally, CPU and Memory Usage tests generate data and reports and saves them to `$ROS_HOME/memory`. ### Test Results and Reports Reports are automatically generated depending on which tests are run. Below are the locations where each report is stored after successfully running the tests as described above. - CPU and Memory Tests - results are stored in your `${ROS_HOME}/memory` directory - if `${ROS_HOME}` is not set, it defaults to `${HOME}/.ros/memory` - Executor KPI tests (Latency, Dropped Messages and Jitter) - results are generated directly to the tests `streams.log` file using `std::cout` prints - reports are generated and stored in the `log/latest_test/autoware_reference_system` directory - `ros2_tracing` Tests - results and reports are stored in your `${ROS_HOME}/tracing` directory - if `${ROS_HOME}` is not set, it defaults to `${HOME}/.ros/tracing` More reports can be added going forward. ## Generating Node Graph Image To generate the image shown above you can take advantage of [a program called `graphviz`](https://graphviz.org/doc/info/command.html) that has a command line interface (CLI) command `dot`. First, check out the provided `.dot` file [within this directory](autoware_reference_system.dot) to get an idea of how the `dot` syntax works (feel free to modify it for your use case or future _reference systems_). To generate the `.dot` file into an `.svg` image, run the following command: dot -Tsvg autoware_reference_system.dot _Note:_ you can change the generated image type to any of [the supported type parameters](https://graphviz.org/docs/outputs/) if you would like a different filetype. Updated on 2021-12-24 at 17:45:36 +0000","title":"README.md"},{"location":"Files/autoware__reference__system_2README_8md/#readmemd","text":"","title":"README.md"},{"location":"Files/autoware__reference__system_2README_8md/#source-code","text":"# autoware_reference_system This file is meant to define the Autoware Reference System and all of its nodes, topics and message types. ![Node graph of reference-system-autoware](../content/img/autoware_reference_system.svg) To get started and test this system yourself, head down to [the _Quick Start section_](#quick-start) and follow the instructions there. _See the [generating a node graph](#generate-node-graph) using graphviz section on how to generate the above image_ ## Evaluation Criteria The _autoware reference system_ was made with a few goals in mind. See the list below to get the complete picture of why certian tests are run and why this system was chosen as a good system to benchmark different executors. Each item below should have a corresponding test report with it or be able to be extracted from an existing test report. See the [testing](#running-the-tests) section for more details on how to generate your own test reports. If you believe we are missing another metric to measure executors by, please create an issue and let us know! ### **Key Performance Indicators (KPIs)** - **CPU utilization** - In general a lower CPU utilization is better since it enables you to choose a smaller CPU or have more functionality on a larger CPU for other things. - **The lower CPU utilization the better** - **Memory utilization** - In general a lower memory utilization is better since it enables you to choose a smaller memory or have more space for other things - **The lower memory utilization the better** - **Use latest samples, count dropped samples** - This is representative of the real-world where old sensor data is much less valuable than new sensor data - For example an image from 30 seconds ago wont help you to drive down the road as much as an image from 0.1 seconds ago) - If there is more than one new sample, the old ones will be dropped in favor of the newest sample - As a result, dropped messages may mean that information was lost - Fusion Nodes may drop messages by design if their inputs have different frequencies, do not count dropped messages for these nodes - Transform nodes should not drop messages though, and these should be counted - **The lower number of dropped samples the better** - **Every Front Lidar sample should cause update in Object Collision Estimator** - The Front and Rear Lidars have the same publishing frequency - This means Object Collision Estimator should run for every lidar sample - Count number of executions of Object Collision Estimator and Front Lidar and report any difference - **The smaller the difference in executions, the better** - **Lowest possible latency from Front Lidar to Object Collision Estimator** - As in the real world, we want to know as soon as possible if the reference system will collide with something - Measure the mean and max latency for this chain of nodes - **The lower latency of the signal chain the better** - **The Behavior Planner should be as cyclical as possible** - The desired behavior of the Behavior Planner is to be as cyclical as possible, meaning it should be executed as close to its set frequency of _100ms_ as possible - Measure the jitter and drift over time of the timer callback - **The lower the jitter and drift of the Behavior Node timer callback the better** ## Message Types A **single message type** is used for the entire _reference system_ when generating results in order to simplify the setup as well as make it more repeatible and extensible. This means **only one _message type_** from the list below is used during any given experimental run for every node in the reference system. 1. [**Message4kB**](../reference_interfaces/msg/Message4kb.idl) - reference message with a fixed size of 4 kilobytes (kB) Other messages with different fixed sizes could be added here in the future. When reporting results it will be important to include the _message type_ used duing the experiement so that comparisons can be done \"apples to apples\" and not \"apples to pears\". ## Autoware Reference System Built from [a handful of building-block node types](../README.md#concept-overview), each one of these nodes are meant to simulate a real-world node from the Autoware.Auto project lidar data pipeline. Under each node type are the requirements used for _this specific reference system_, `autoware_reference_system`. Future reference systems could have slightly different requirements and still use the same building-block node types. For simplicity's sake, every node except for the _command nodes_ only ever publishes one topic and this topic has the same name as the node that publishes it. However, each topic can be subscribed to by multiple different nodes. 1. [**Message Type**](#message-types) - all nodes use the same message type during any single test run - default _message type_: - [Message4kB](../reference_system/include/reference_system/msg_types.hpp#L21) - to be implemented: - Message64kB - Message256kB - Message512kB - Message1024kB - Message5120kB 2. [**Sensor Nodes**](../reference_system/include/reference_system/nodes/rclcpp/sensor.hpp) - all _sensor nodes_ have a publishing rate (cycle time) of [**100 milliseconds**](include/reference_system/system/timing/default.hpp#L26) - all _sensor_nodes_ publish the same _message type_ - total of **5 _sensor nodes_**: - [Front Lidar Driver](include/autoware_reference_system/autoware_system_builder.hpp#L38) - [Rear Lidar Driver](include/autoware_reference_system/autoware_system_builder.hpp#L44) - [Point Cloud Map](include/autoware_reference_system/autoware_system_builder.hpp#L50) - [Visualizer](include/autoware_reference_system/autoware_system_builder.hpp#L56) - [Lanelet2Map](include/autoware_reference_system/autoware_system_builder.hpp#62) 3. [**Transform Nodes**](../reference_system/include/reference_system/nodes/rclcpp/transform.hpp) - all _transform nodes_ have one subscriber and one publisher - all _transform nodes_ start processing for [**50 milliseconds**](include/autoware_reference_system/system/timing/default.hpp#L28) after a message is received - publishes message after processing is complete - total of **10 _transform nodes_:** - [Front Points Transformer](include/autoware_reference_system/autoware_system_builder.hpp#L69) - [Rear Points Transformer](include/autoware_reference_system/autoware_system_builder.hpp#L78) - [Voxel Grid Downsampler](include/autoware_reference_system/autoware_system_builder.hpp#L87) - [Point Cloud Map Loader](include/autoware_reference_system/autoware_system_builder.hpp#L96) - [Ray Ground Filter](include/autoware_reference_system/autoware_system_builder.hpp#L105) - [Object Collision Estimator](include/autoware_reference_system/autoware_system_builder.hpp#L123) - [MPC Controller](include/autoware_reference_system/autoware_system_builder.hpp#L132) - [Parking Planner](include/autoware_reference_system/autoware_system_builder.hpp#L141) - [Lane Planner](include/autoware_reference_system/autoware_system_builder.hpp#L150) 4. [**Fusion Nodes**](../reference_system/include/reference_system/nodes/rclcpp/fusion.hpp) - all _fusion nodes_ have **two subscribers** and one publisher for this _reference system_ - all _fusion nodes_ start processing for [**25 milliseconds**](include/autoware_reference_system/system/timing/default.hpp#L30) after a message is received **from all** subscriptions - all _fusion nodes_ have a max input time difference between the first input received and last input received before publishing of [**9999** seconds](include/autoware_reference_system/system/timing/benchmark.hpp) - publishes message after processing is complete - total of **5 _fusion nodes_:** - [Point Cloud Fusion](include/autoware_reference_system/autoware_system_builder.hpp#L160) - [NDT Localizer](include/autoware_reference_system/autoware_system_builder.hpp#L169) - [Vehicle Interface](include/autoware_reference_system/autoware_system_builder.hpp#L178) - [Lanelet2 Global Planner](include/autoware_reference_system/autoware_system_builder.hpp#L187) - [Lanelet 2 Map Loader](include/autoware_reference_system/autoware_system_builder.hpp#L196) 5. [**Cyclic Nodes**](../reference_system/include/reference_system/nodes/rclcpp/cyclic.hpp) - for this _reference system_ there is only [**1 _cyclic node_**](include/autoware_reference_system/autoware_system_builder.hpp#L206) - this _cyclic node_ has **6 subscribers**and one publisher - this _cyclic node_ starts processing for [**1 millisecond**](include/autoware_reference_system/system/timing/default.hpp#L32) after a message is received **from any** single subscription - publishes message after processing is complete 6. [**Command Nodes**](../reference_system/include/reference_system/nodes/rclcpp/command.hpp) - all _command nodes_ have **1 subscriber** and zero publishers - all _command nodes_ prints out the final latency statistics after a message is received on the specified topic - total of **2 _command nodes_:** - [VehicleDBWSystem](include/autoware_reference_system/autoware_system_builder.hpp#L222) - [IntersectionOutput](include/autoware_reference_system/autoware_system_builder.hpp#L227) 7. [**Intersection Nodes**](../reference_system/include/reference_system/nodes/rclcpp/intersection.hpp) - for this _reference system_ there is only [EuclideanClusterDetector](include/autoware_reference_system/autoware_system_builder.hpp#L206) - this _intersection node_ has **2 subscribers** and **2 publishers** - publishes message after processing is complete on the correspoding publisher ## Quick Start This section will go over how to clone, build and run the `autoware_reference_system` in order to generate your own test reports. ### Dependencies Before running the tests there are a few prerequisites to complete: - Install python depedencies used during test runs and report generation - `python3 -m pip install psrecord bokeh networkx numpy pandas` - Install dependencies using the following command from the `colcon_ws` directory: - `rosdep install --from-paths src --ignore-src -y` - Install LTTng and `ros2_tracing` [following the instructions in `ros2_tracing`](https://gitlab.com/ros-tracing/ros2_tracing#building) - _Note:_ if you are setting up [ a realtime linux kernel for a raspberry pi using this docker file](https://github.com/ros-realtime/rt-kernel-docker-builder#raspberry-pi-4-rt-linux-kernel), it should [already include LTTng](https://github.com/ros-realtime/rt-kernel-docker-builder/pull/18) - _Note:_ make sure to clone `ros2_tracing` into **the same workspace as where you put the `reference-system`**, the tests will not properly run if they are not in the same directory. **Tests will fail** if any of the above dependencies are missing on the machine. Once the above steps are complete you sould be ready to configure the setup for your platform and run the tests to generate some results. ## Configure Processing Time Many nodes in the reference system are actually performing some _psuedo work_ by finding prime numbers up until some _maximum value_. Depending on the platform, this _maximum value_ will need to be changed so that these nodes do not take an absurd amount of time. This _maximum value_ should be chosen on a platform-by-platform basis so that the total _run time_ of this work takes some desired length of time. In order to make finding this _maximum value_ a bit easier across many different platforms a simple [**number_cruncher_benchmark**](src/ros2/number_cruncher_benchmark.cpp) is provided that will loop over various _maximum values_ and spit out how long each one takes to run. After running this executable on your platform you should have a good idea what _maximum value_ you should use in your [timing configuration](include/autoware_reference_system/system/timing/default.hpp) so that each node does some measurable work for some desired amount of time. Here is an example output of the `number_cruncher_benchmark` run on a typical development platform (Intel 9i7): ros2 run autoware_reference_system number_cruncher_benchmark maximum_number run time 64 0.001609ms 128 0.002896ms 256 0.006614ms 512 0.035036ms 1024 0.050957ms 2048 0.092732ms 4096 0.22837ms 8192 0.566779ms 16384 1.48837ms 32768 3.64588ms 65536 9.6687ms 131072 24.1154ms 262144 62.3475ms 524288 162.762ms 1048576 429.882ms 2097152 1149.79ms Run the above command on your system, select your desired `run_time` and place the corresponding `maximum_number` in the [timing configuration file](include/autoware_reference_system/system/timing/default.hpp) for the desired nodes. ## Running the Tests Source your ROS distribution as well as your `ros2_tracing` overlay, compile this repository using the proper CMake arguments and generate some test results: **Make sure you've installed the required dependencies** as [outlined above](#dependencies) before trying to run these tests. ### Supported CMake Arguments - `RUN_BENCHMARK` - Tell CMake to build the benchmark tests that will check the reference system against its requirements before running a sweep of tests to generate trace files and reports - Without the `RUN_BENCHMARK` variable set to `ON` only the standard linter tests will be run - `TEST_PLATFORM` - Test CMake to build the tests to check if the tests are being run from a [supported platform](../README.md#supported-platforms) or not - This flag can be ommited if you would like to run the tests on a development system before running them on a supported platform - The platform tests themselves can and should be improved going forward and are only some simple checks today (architecture, number of CPUs, PREEMPT_RT flag, etc.) - Set this to `ON` to check if the current platform is supported - `SKIP_TRACING` - Set to `ON` to skip the `ros2_tracing` tests, aka the `callback` tests - This can greatly reduce the length of time the `colcon test` command takes to run - `ALL_RMWS` - Set this to `ON` if you'd like to run tests on all available RMWS as well - Otherwise use only default RMW (first one listed by CMake function `get_available_rmw_implementations`) - Defaults to `OFF` **Make sure you've installed the required dependencies** as [outlined above](#dependencies) before trying to run these tests.","title":"Source code"},{"location":"Files/autoware__reference__system_2README_8md/#source-your-ros-distribution","text":"source /opt/ros/galactic/setup.bash","title":"source your ROS distribution"},{"location":"Files/autoware__reference__system_2README_8md/#cd-to-your-colcon_ws-with-this-repo-and-ros2_tracing-inside","text":"cd /path/to/colcon_ws","title":"cd to your colcon_ws with this repo and ros2_tracing inside"},{"location":"Files/autoware__reference__system_2README_8md/#build-packages-with-benchmark-tests-enabled","text":"colcon build --cmake-args -DRUN_BENCHMARK=TRUE -DTEST_PLATFORM=TRUE","title":"build packages with benchmark tests enabled"},{"location":"Files/autoware__reference__system_2README_8md/#important","text":"","title":"IMPORTANT"},{"location":"Files/autoware__reference__system_2README_8md/#source-the-newly-built-workspace-to-make-sure-to-use-the-updated-tracetools-package","text":"source install/local_setup.bash","title":"source the newly built workspace to make sure to use the updated tracetools package"},{"location":"Files/autoware__reference__system_2README_8md/#run-tests-generate-traces-and-reports","text":"colcon test **Note 1:** some of the tests require super user privileges, to change thread priorities. If super user privileges are not available, these tests are excluded automatically. Run the above lines from a `sudo bash` or similar to include those tests. **Note 2:** during the testing _trace data_ generated from `LTTng` will be placed in `$ROS_HOME/tracing`. If the `$ROS_HOME/tracing` directory is missing the tests will automatically generate it for you. This directory should now hold tracing data and reports for all `ros2_tracing` tests performed. Additionally, CPU and Memory Usage tests generate data and reports and saves them to `$ROS_HOME/memory`. ### Test Results and Reports Reports are automatically generated depending on which tests are run. Below are the locations where each report is stored after successfully running the tests as described above. - CPU and Memory Tests - results are stored in your `${ROS_HOME}/memory` directory - if `${ROS_HOME}` is not set, it defaults to `${HOME}/.ros/memory` - Executor KPI tests (Latency, Dropped Messages and Jitter) - results are generated directly to the tests `streams.log` file using `std::cout` prints - reports are generated and stored in the `log/latest_test/autoware_reference_system` directory - `ros2_tracing` Tests - results and reports are stored in your `${ROS_HOME}/tracing` directory - if `${ROS_HOME}` is not set, it defaults to `${HOME}/.ros/tracing` More reports can be added going forward. ## Generating Node Graph Image To generate the image shown above you can take advantage of [a program called `graphviz`](https://graphviz.org/doc/info/command.html) that has a command line interface (CLI) command `dot`. First, check out the provided `.dot` file [within this directory](autoware_reference_system.dot) to get an idea of how the `dot` syntax works (feel free to modify it for your use case or future _reference systems_). To generate the `.dot` file into an `.svg` image, run the following command: dot -Tsvg autoware_reference_system.dot _Note:_ you can change the generated image type to any of [the supported type parameters](https://graphviz.org/docs/outputs/) if you would like a different filetype. Updated on 2021-12-24 at 17:45:36 +0000","title":"run tests, generate traces and reports"},{"location":"Files/autoware__system__builder_8hpp/","text":"autoware_reference_system/include/autoware_reference_system/autoware_system_builder.hpp Namespaces Name std::chrono_literals Functions Name template <typename SystemType ,typename TimingConfig > auto create_autoware_nodes () Functions Documentation function create_autoware_nodes template <typename SystemType , typename TimingConfig > auto create_autoware_nodes() Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef AUTOWARE_REFERENCE_SYSTEM__AUTOWARE_SYSTEM_BUILDER_HPP_ #define AUTOWARE_REFERENCE_SYSTEM__AUTOWARE_SYSTEM_BUILDER_HPP_ #include <chrono> #include <memory> #include <vector> #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/system/systems.hpp\" using namespace std::chrono_literals; // NOLINT template<typename SystemType, typename TimingConfig> auto create_autoware_nodes() ->std::vector<std::shared_ptr<typename SystemType::NodeBaseType>> { std::vector<std::shared_ptr<typename SystemType::NodeBaseType>> nodes; // ignore the warning about designated initializers - they make the code much // more readable #pragma GCC diagnostic push #pragma GCC diagnostic ignored \"-Wpedantic\" // setup communication graph // sensor nodes nodes.emplace_back( std::make_shared<typename SystemType::Sensor>( nodes::SensorSettings{.node_name = \"FrontLidarDriver\", .topic_name = \"FrontLidarDriver\", .cycle_time = TimingConfig::FRONT_LIDAR_DRIVER})); nodes.emplace_back( std::make_shared<typename SystemType::Sensor>( nodes::SensorSettings{.node_name = \"RearLidarDriver\", .topic_name = \"RearLidarDriver\", .cycle_time = TimingConfig::REAR_LIDAR_DRIVER})); nodes.emplace_back( std::make_shared<typename SystemType::Sensor>( nodes::SensorSettings{.node_name = \"PointCloudMap\", .topic_name = \"PointCloudMap\", .cycle_time = TimingConfig::POINT_CLOUD_MAP})); nodes.emplace_back( std::make_shared<typename SystemType::Sensor>( nodes::SensorSettings{.node_name = \"Visualizer\", .topic_name = \"Visualizer\", .cycle_time = TimingConfig::VISUALIZER})); nodes.emplace_back( std::make_shared<typename SystemType::Sensor>( nodes::SensorSettings{.node_name = \"Lanelet2Map\", .topic_name = \"Lanelet2Map\", .cycle_time = TimingConfig::LANELET2MAP})); nodes.emplace_back( std::make_shared<typename SystemType::Sensor>( nodes::SensorSettings{.node_name = \"EuclideanClusterSettings\", .topic_name = \"EuclideanClusterSettings\", .cycle_time = TimingConfig::EUCLIDEAN_CLUSTER_SETTINGS})); // transform nodes nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"PointsTransformerFront\", .input_topic = \"FrontLidarDriver\", .output_topic = \"PointsTransformerFront\", .number_crunch_limit = TimingConfig::POINTS_TRANSFORMER_FRONT})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"PointsTransformerRear\", .input_topic = \"RearLidarDriver\", .output_topic = \"PointsTransformerRear\", .number_crunch_limit = TimingConfig::POINTS_TRANSFORMER_REAR})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"VoxelGridDownsampler\", .input_topic = \"PointCloudFusion\", .output_topic = \"VoxelGridDownsampler\", .number_crunch_limit = TimingConfig::VOXEL_GRID_DOWNSAMPLER})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"PointCloudMapLoader\", .input_topic = \"PointCloudMap\", .output_topic = \"PointCloudMapLoader\", .number_crunch_limit = TimingConfig::POINT_CLOUD_MAP_LOADER})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"RayGroundFilter\", .input_topic = \"PointCloudFusion\", .output_topic = \"RayGroundFilter\", .number_crunch_limit = TimingConfig::RAY_GROUND_FILTER})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"ObjectCollisionEstimator\", .input_topic = \"EuclideanClusterDetector\", .output_topic = \"ObjectCollisionEstimator\", .number_crunch_limit = TimingConfig::OBJECT_COLLISION_ESTIMATOR})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"MPCController\", .input_topic = \"BehaviorPlanner\", .output_topic = \"MPCController\", .number_crunch_limit = TimingConfig::MPC_CONTROLLER})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"ParkingPlanner\", .input_topic = \"Lanelet2MapLoader\", .output_topic = \"ParkingPlanner\", .number_crunch_limit = TimingConfig::PARKING_PLANNER})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"LanePlanner\", .input_topic = \"Lanelet2MapLoader\", .output_topic = \"LanePlanner\", .number_crunch_limit = TimingConfig::LANE_PLANNER})); // fusion nodes nodes.emplace_back( std::make_shared<typename SystemType::Fusion>( nodes::FusionSettings{ .node_name = \"PointCloudFusion\", .input_0 = \"PointsTransformerFront\", .input_1 = \"PointsTransformerRear\", .output_topic = \"PointCloudFusion\", .number_crunch_limit = TimingConfig::POINT_CLOUD_FUSION})); nodes.emplace_back( std::make_shared<typename SystemType::Fusion>( nodes::FusionSettings{ .node_name = \"NDTLocalizer\", .input_0 = \"VoxelGridDownsampler\", .input_1 = \"PointCloudMapLoader\", .output_topic = \"NDTLocalizer\", .number_crunch_limit = TimingConfig::NDT_LOCALIZER})); nodes.emplace_back( std::make_shared<typename SystemType::Fusion>( nodes::FusionSettings{ .node_name = \"VehicleInterface\", .input_0 = \"MPCController\", .input_1 = \"BehaviorPlanner\", .output_topic = \"VehicleInterface\", .number_crunch_limit = TimingConfig::VEHICLE_INTERFACE})); nodes.emplace_back( std::make_shared<typename SystemType::Fusion>( nodes::FusionSettings{ .node_name = \"Lanelet2GlobalPlanner\", .input_0 = \"Visualizer\", .input_1 = \"NDTLocalizer\", .output_topic = \"Lanelet2GlobalPlanner\", .number_crunch_limit = TimingConfig::LANELET_2_GLOBAL_PLANNER})); nodes.emplace_back( std::make_shared<typename SystemType::Fusion>( nodes::FusionSettings{ .node_name = \"Lanelet2MapLoader\", .input_0 = \"Lanelet2Map\", .input_1 = \"Lanelet2GlobalPlanner\", .output_topic = \"Lanelet2MapLoader\", .number_crunch_limit = TimingConfig::LANELET_2_MAP_LOADER})); // cyclic node nodes.emplace_back( std::make_shared<typename SystemType::Cyclic>( nodes::CyclicSettings{ .node_name = \"BehaviorPlanner\", .inputs = {\"ObjectCollisionEstimator\", \"NDTLocalizer\", \"Lanelet2GlobalPlanner\", \"Lanelet2MapLoader\", \"ParkingPlanner\", \"LanePlanner\"}, .output_topic = \"BehaviorPlanner\", .number_crunch_limit = TimingConfig::BEHAVIOR_PLANNER, .cycle_time = TimingConfig::BEHAVIOR_PLANNER_CYCLE})); // intersection node nodes.emplace_back( std::make_shared<typename SystemType::Intersection>( nodes::IntersectionSettings{ .node_name = \"EuclideanClusterDetector\", .connections = { {.input_topic = \"RayGroundFilter\", .output_topic = \"EuclideanClusterDetector\", .number_crunch_limit = TimingConfig::EUCLIDEAN_CLUSTER_DETECTOR}, {.input_topic = \"EuclideanClusterSettings\", .output_topic = \"EuclideanIntersection\", .number_crunch_limit = TimingConfig::EUCLIDEAN_INTERSECTION } }} )); // command node nodes.emplace_back( std::make_shared<typename SystemType::Command>( nodes::CommandSettings{ .node_name = \"VehicleDBWSystem\", .input_topic = \"VehicleInterface\"})); nodes.emplace_back( std::make_shared<typename SystemType::Command>( nodes::CommandSettings{ .node_name = \"IntersectionOutput\", .input_topic = \"EuclideanIntersection\"})); #pragma GCC diagnostic pop return nodes; } #endif // AUTOWARE_REFERENCE_SYSTEM__AUTOWARE_SYSTEM_BUILDER_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/include/autoware_reference_system/autoware_system_builder.hpp"},{"location":"Files/autoware__system__builder_8hpp/#autoware_reference_systemincludeautoware_reference_systemautoware_system_builderhpp","text":"","title":"autoware_reference_system/include/autoware_reference_system/autoware_system_builder.hpp"},{"location":"Files/autoware__system__builder_8hpp/#namespaces","text":"Name std::chrono_literals","title":"Namespaces"},{"location":"Files/autoware__system__builder_8hpp/#functions","text":"Name template <typename SystemType ,typename TimingConfig > auto create_autoware_nodes ()","title":"Functions"},{"location":"Files/autoware__system__builder_8hpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/autoware__system__builder_8hpp/#function-create_autoware_nodes","text":"template <typename SystemType , typename TimingConfig > auto create_autoware_nodes()","title":"function create_autoware_nodes"},{"location":"Files/autoware__system__builder_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef AUTOWARE_REFERENCE_SYSTEM__AUTOWARE_SYSTEM_BUILDER_HPP_ #define AUTOWARE_REFERENCE_SYSTEM__AUTOWARE_SYSTEM_BUILDER_HPP_ #include <chrono> #include <memory> #include <vector> #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/system/systems.hpp\" using namespace std::chrono_literals; // NOLINT template<typename SystemType, typename TimingConfig> auto create_autoware_nodes() ->std::vector<std::shared_ptr<typename SystemType::NodeBaseType>> { std::vector<std::shared_ptr<typename SystemType::NodeBaseType>> nodes; // ignore the warning about designated initializers - they make the code much // more readable #pragma GCC diagnostic push #pragma GCC diagnostic ignored \"-Wpedantic\" // setup communication graph // sensor nodes nodes.emplace_back( std::make_shared<typename SystemType::Sensor>( nodes::SensorSettings{.node_name = \"FrontLidarDriver\", .topic_name = \"FrontLidarDriver\", .cycle_time = TimingConfig::FRONT_LIDAR_DRIVER})); nodes.emplace_back( std::make_shared<typename SystemType::Sensor>( nodes::SensorSettings{.node_name = \"RearLidarDriver\", .topic_name = \"RearLidarDriver\", .cycle_time = TimingConfig::REAR_LIDAR_DRIVER})); nodes.emplace_back( std::make_shared<typename SystemType::Sensor>( nodes::SensorSettings{.node_name = \"PointCloudMap\", .topic_name = \"PointCloudMap\", .cycle_time = TimingConfig::POINT_CLOUD_MAP})); nodes.emplace_back( std::make_shared<typename SystemType::Sensor>( nodes::SensorSettings{.node_name = \"Visualizer\", .topic_name = \"Visualizer\", .cycle_time = TimingConfig::VISUALIZER})); nodes.emplace_back( std::make_shared<typename SystemType::Sensor>( nodes::SensorSettings{.node_name = \"Lanelet2Map\", .topic_name = \"Lanelet2Map\", .cycle_time = TimingConfig::LANELET2MAP})); nodes.emplace_back( std::make_shared<typename SystemType::Sensor>( nodes::SensorSettings{.node_name = \"EuclideanClusterSettings\", .topic_name = \"EuclideanClusterSettings\", .cycle_time = TimingConfig::EUCLIDEAN_CLUSTER_SETTINGS})); // transform nodes nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"PointsTransformerFront\", .input_topic = \"FrontLidarDriver\", .output_topic = \"PointsTransformerFront\", .number_crunch_limit = TimingConfig::POINTS_TRANSFORMER_FRONT})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"PointsTransformerRear\", .input_topic = \"RearLidarDriver\", .output_topic = \"PointsTransformerRear\", .number_crunch_limit = TimingConfig::POINTS_TRANSFORMER_REAR})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"VoxelGridDownsampler\", .input_topic = \"PointCloudFusion\", .output_topic = \"VoxelGridDownsampler\", .number_crunch_limit = TimingConfig::VOXEL_GRID_DOWNSAMPLER})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"PointCloudMapLoader\", .input_topic = \"PointCloudMap\", .output_topic = \"PointCloudMapLoader\", .number_crunch_limit = TimingConfig::POINT_CLOUD_MAP_LOADER})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"RayGroundFilter\", .input_topic = \"PointCloudFusion\", .output_topic = \"RayGroundFilter\", .number_crunch_limit = TimingConfig::RAY_GROUND_FILTER})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"ObjectCollisionEstimator\", .input_topic = \"EuclideanClusterDetector\", .output_topic = \"ObjectCollisionEstimator\", .number_crunch_limit = TimingConfig::OBJECT_COLLISION_ESTIMATOR})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"MPCController\", .input_topic = \"BehaviorPlanner\", .output_topic = \"MPCController\", .number_crunch_limit = TimingConfig::MPC_CONTROLLER})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"ParkingPlanner\", .input_topic = \"Lanelet2MapLoader\", .output_topic = \"ParkingPlanner\", .number_crunch_limit = TimingConfig::PARKING_PLANNER})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"LanePlanner\", .input_topic = \"Lanelet2MapLoader\", .output_topic = \"LanePlanner\", .number_crunch_limit = TimingConfig::LANE_PLANNER})); // fusion nodes nodes.emplace_back( std::make_shared<typename SystemType::Fusion>( nodes::FusionSettings{ .node_name = \"PointCloudFusion\", .input_0 = \"PointsTransformerFront\", .input_1 = \"PointsTransformerRear\", .output_topic = \"PointCloudFusion\", .number_crunch_limit = TimingConfig::POINT_CLOUD_FUSION})); nodes.emplace_back( std::make_shared<typename SystemType::Fusion>( nodes::FusionSettings{ .node_name = \"NDTLocalizer\", .input_0 = \"VoxelGridDownsampler\", .input_1 = \"PointCloudMapLoader\", .output_topic = \"NDTLocalizer\", .number_crunch_limit = TimingConfig::NDT_LOCALIZER})); nodes.emplace_back( std::make_shared<typename SystemType::Fusion>( nodes::FusionSettings{ .node_name = \"VehicleInterface\", .input_0 = \"MPCController\", .input_1 = \"BehaviorPlanner\", .output_topic = \"VehicleInterface\", .number_crunch_limit = TimingConfig::VEHICLE_INTERFACE})); nodes.emplace_back( std::make_shared<typename SystemType::Fusion>( nodes::FusionSettings{ .node_name = \"Lanelet2GlobalPlanner\", .input_0 = \"Visualizer\", .input_1 = \"NDTLocalizer\", .output_topic = \"Lanelet2GlobalPlanner\", .number_crunch_limit = TimingConfig::LANELET_2_GLOBAL_PLANNER})); nodes.emplace_back( std::make_shared<typename SystemType::Fusion>( nodes::FusionSettings{ .node_name = \"Lanelet2MapLoader\", .input_0 = \"Lanelet2Map\", .input_1 = \"Lanelet2GlobalPlanner\", .output_topic = \"Lanelet2MapLoader\", .number_crunch_limit = TimingConfig::LANELET_2_MAP_LOADER})); // cyclic node nodes.emplace_back( std::make_shared<typename SystemType::Cyclic>( nodes::CyclicSettings{ .node_name = \"BehaviorPlanner\", .inputs = {\"ObjectCollisionEstimator\", \"NDTLocalizer\", \"Lanelet2GlobalPlanner\", \"Lanelet2MapLoader\", \"ParkingPlanner\", \"LanePlanner\"}, .output_topic = \"BehaviorPlanner\", .number_crunch_limit = TimingConfig::BEHAVIOR_PLANNER, .cycle_time = TimingConfig::BEHAVIOR_PLANNER_CYCLE})); // intersection node nodes.emplace_back( std::make_shared<typename SystemType::Intersection>( nodes::IntersectionSettings{ .node_name = \"EuclideanClusterDetector\", .connections = { {.input_topic = \"RayGroundFilter\", .output_topic = \"EuclideanClusterDetector\", .number_crunch_limit = TimingConfig::EUCLIDEAN_CLUSTER_DETECTOR}, {.input_topic = \"EuclideanClusterSettings\", .output_topic = \"EuclideanIntersection\", .number_crunch_limit = TimingConfig::EUCLIDEAN_INTERSECTION } }} )); // command node nodes.emplace_back( std::make_shared<typename SystemType::Command>( nodes::CommandSettings{ .node_name = \"VehicleDBWSystem\", .input_topic = \"VehicleInterface\"})); nodes.emplace_back( std::make_shared<typename SystemType::Command>( nodes::CommandSettings{ .node_name = \"IntersectionOutput\", .input_topic = \"EuclideanIntersection\"})); #pragma GCC diagnostic pop return nodes; } #endif // AUTOWARE_REFERENCE_SYSTEM__AUTOWARE_SYSTEM_BUILDER_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/autoware__system__builder__utils_8hpp/","text":"autoware_reference_system/include/autoware_reference_system/autoware_system_builder_utils.hpp Functions Name template <typename NODES > std::shared_ptr< rclcpp::Node > find_node_or_fail (const NODES & nodes, const std::string & name) template <typename NODES ,typename NAMES > void add_nodes_to_executor_by_names (rclcpp::Executor * executor, const NODES & nodes, const NAMES & names) template <typename NODES > void add_unassociated_nodes_to_executor (rclcpp::Executor * executor, const NODES & nodes) void set_nice_level_of_current_thread (const int level) Functions Documentation function find_node_or_fail template <typename NODES > std::shared_ptr< rclcpp::Node > find_node_or_fail( const NODES & nodes, const std::string & name ) From the given container of pointers to Node instances, the one with the given name is returned. If no such node exists, the function fails with RCLCPP_FATAL . function add_nodes_to_executor_by_names template <typename NODES , typename NAMES > void add_nodes_to_executor_by_names( rclcpp::Executor * executor, const NODES & nodes, const NAMES & names ) Adds those Nodes from nodes to the given Executor whose names appear in names . If a name cannot be found or if a node has been already associated with an Executor, the function fails with RCLCPP_FATAL . function add_unassociated_nodes_to_executor template <typename NODES > void add_unassociated_nodes_to_executor( rclcpp::Executor * executor, const NODES & nodes ) Associated those nodes from nodes with the given Executor that have not been associated to an Executor previously. function set_nice_level_of_current_thread void set_nice_level_of_current_thread( const int level ) Changes the nice level of the current thread. If the operation fails, the function prints a prominent warning. Source code // Copyright (c) 2021 by Robert Bosch GmbH // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef AUTOWARE_REFERENCE_SYSTEM__AUTOWARE_SYSTEM_BUILDER_UTILS_HPP_ #define AUTOWARE_REFERENCE_SYSTEM__AUTOWARE_SYSTEM_BUILDER_UTILS_HPP_ #include <unistd.h> #include <sys/time.h> #include <sys/resource.h> #include <algorithm> #include <atomic> #include <memory> #include <string> #include \"rclcpp/rclcpp.hpp\" template<typename NODES> std::shared_ptr<rclcpp::Node> find_node_or_fail( const NODES & nodes, const std::string & name) { static_assert(std::is_same<typename NODES::value_type, std::shared_ptr<rclcpp::Node>>::value); for (auto & node : nodes) { if (name == node->get_name()) { return node; } } RCLCPP_FATAL(rclcpp::get_logger(\"main\"), \"Node '%s' was not found!\", name.c_str()); std::exit(1); } template<typename NODES, typename NAMES> void add_nodes_to_executor_by_names( rclcpp::Executor * executor, const NODES & nodes, const NAMES & names) { static_assert(std::is_same<typename NODES::value_type, std::shared_ptr<rclcpp::Node>>::value); static_assert(std::is_same<typename NAMES::value_type, std::string>::value); for (const std::string & name : names) { bool was_added = false; for (auto & node : nodes) { if (name == node->get_name()) { if (node->get_node_base_interface()->get_associated_with_executor_atomic().load()) { RCLCPP_FATAL( rclcpp::get_logger( \"main\"), \"Node '%s' is already associated with an executor!\", name.c_str()); std::exit(0); } executor->add_node(node); was_added = true; } } if (!was_added) { RCLCPP_FATAL(rclcpp::get_logger(\"main\"), \"Node with name '%s' not found!\", name.c_str()); std::exit(0); } } } template<typename NODES> void add_unassociated_nodes_to_executor( rclcpp::Executor * executor, const NODES & nodes) { static_assert(std::is_same<typename NODES::value_type, std::shared_ptr<rclcpp::Node>>::value); for (auto & node : nodes) { if (!node->get_node_base_interface()->get_associated_with_executor_atomic().load()) { executor->add_node(node); } } } void set_nice_level_of_current_thread(const int level) { const auto tid = gettid(); int rval = setpriority(PRIO_PROCESS, tid, level); if (rval != 0) { auto logger = rclcpp::get_logger(\"main\"); RCLCPP_WARN(logger, \"Could not change nice level of thread %d! Are you super user?\", tid); } } #endif // AUTOWARE_REFERENCE_SYSTEM__AUTOWARE_SYSTEM_BUILDER_UTILS_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/include/autoware_reference_system/autoware_system_builder_utils.hpp"},{"location":"Files/autoware__system__builder__utils_8hpp/#autoware_reference_systemincludeautoware_reference_systemautoware_system_builder_utilshpp","text":"","title":"autoware_reference_system/include/autoware_reference_system/autoware_system_builder_utils.hpp"},{"location":"Files/autoware__system__builder__utils_8hpp/#functions","text":"Name template <typename NODES > std::shared_ptr< rclcpp::Node > find_node_or_fail (const NODES & nodes, const std::string & name) template <typename NODES ,typename NAMES > void add_nodes_to_executor_by_names (rclcpp::Executor * executor, const NODES & nodes, const NAMES & names) template <typename NODES > void add_unassociated_nodes_to_executor (rclcpp::Executor * executor, const NODES & nodes) void set_nice_level_of_current_thread (const int level)","title":"Functions"},{"location":"Files/autoware__system__builder__utils_8hpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/autoware__system__builder__utils_8hpp/#function-find_node_or_fail","text":"template <typename NODES > std::shared_ptr< rclcpp::Node > find_node_or_fail( const NODES & nodes, const std::string & name ) From the given container of pointers to Node instances, the one with the given name is returned. If no such node exists, the function fails with RCLCPP_FATAL .","title":"function find_node_or_fail"},{"location":"Files/autoware__system__builder__utils_8hpp/#function-add_nodes_to_executor_by_names","text":"template <typename NODES , typename NAMES > void add_nodes_to_executor_by_names( rclcpp::Executor * executor, const NODES & nodes, const NAMES & names ) Adds those Nodes from nodes to the given Executor whose names appear in names . If a name cannot be found or if a node has been already associated with an Executor, the function fails with RCLCPP_FATAL .","title":"function add_nodes_to_executor_by_names"},{"location":"Files/autoware__system__builder__utils_8hpp/#function-add_unassociated_nodes_to_executor","text":"template <typename NODES > void add_unassociated_nodes_to_executor( rclcpp::Executor * executor, const NODES & nodes ) Associated those nodes from nodes with the given Executor that have not been associated to an Executor previously.","title":"function add_unassociated_nodes_to_executor"},{"location":"Files/autoware__system__builder__utils_8hpp/#function-set_nice_level_of_current_thread","text":"void set_nice_level_of_current_thread( const int level ) Changes the nice level of the current thread. If the operation fails, the function prints a prominent warning.","title":"function set_nice_level_of_current_thread"},{"location":"Files/autoware__system__builder__utils_8hpp/#source-code","text":"// Copyright (c) 2021 by Robert Bosch GmbH // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef AUTOWARE_REFERENCE_SYSTEM__AUTOWARE_SYSTEM_BUILDER_UTILS_HPP_ #define AUTOWARE_REFERENCE_SYSTEM__AUTOWARE_SYSTEM_BUILDER_UTILS_HPP_ #include <unistd.h> #include <sys/time.h> #include <sys/resource.h> #include <algorithm> #include <atomic> #include <memory> #include <string> #include \"rclcpp/rclcpp.hpp\" template<typename NODES> std::shared_ptr<rclcpp::Node> find_node_or_fail( const NODES & nodes, const std::string & name) { static_assert(std::is_same<typename NODES::value_type, std::shared_ptr<rclcpp::Node>>::value); for (auto & node : nodes) { if (name == node->get_name()) { return node; } } RCLCPP_FATAL(rclcpp::get_logger(\"main\"), \"Node '%s' was not found!\", name.c_str()); std::exit(1); } template<typename NODES, typename NAMES> void add_nodes_to_executor_by_names( rclcpp::Executor * executor, const NODES & nodes, const NAMES & names) { static_assert(std::is_same<typename NODES::value_type, std::shared_ptr<rclcpp::Node>>::value); static_assert(std::is_same<typename NAMES::value_type, std::string>::value); for (const std::string & name : names) { bool was_added = false; for (auto & node : nodes) { if (name == node->get_name()) { if (node->get_node_base_interface()->get_associated_with_executor_atomic().load()) { RCLCPP_FATAL( rclcpp::get_logger( \"main\"), \"Node '%s' is already associated with an executor!\", name.c_str()); std::exit(0); } executor->add_node(node); was_added = true; } } if (!was_added) { RCLCPP_FATAL(rclcpp::get_logger(\"main\"), \"Node with name '%s' not found!\", name.c_str()); std::exit(0); } } } template<typename NODES> void add_unassociated_nodes_to_executor( rclcpp::Executor * executor, const NODES & nodes) { static_assert(std::is_same<typename NODES::value_type, std::shared_ptr<rclcpp::Node>>::value); for (auto & node : nodes) { if (!node->get_node_base_interface()->get_associated_with_executor_atomic().load()) { executor->add_node(node); } } } void set_nice_level_of_current_thread(const int level) { const auto tid = gettid(); int rval = setpriority(PRIO_PROCESS, tid, level); if (rval != 0) { auto logger = rclcpp::get_logger(\"main\"); RCLCPP_WARN(logger, \"Could not change nice level of thread %d! Are you super user?\", tid); } } #endif // AUTOWARE_REFERENCE_SYSTEM__AUTOWARE_SYSTEM_BUILDER_UTILS_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/benchmark_8hpp/","text":"autoware_reference_system/include/autoware_reference_system/system/timing/benchmark.hpp Namespaces Name nodes nodes::timing Classes Name struct nodes::timing::BenchmarkThroughput struct nodes::timing::BenchmarkCPUUsage Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef AUTOWARE_REFERENCE_SYSTEM__SYSTEM__TIMING__BENCHMARK_HPP_ #define AUTOWARE_REFERENCE_SYSTEM__SYSTEM__TIMING__BENCHMARK_HPP_ #include <chrono> #include \"default.hpp\" namespace nodes { namespace timing { struct BenchmarkThroughput { using time_t = std::chrono::nanoseconds; using milliseconds = std::chrono::milliseconds; using seconds = std::chrono::seconds; // sensors static constexpr time_t FRONT_LIDAR_DRIVER = milliseconds(0); static constexpr time_t REAR_LIDAR_DRIVER = milliseconds(0); static constexpr time_t POINT_CLOUD_MAP = milliseconds(0); static constexpr time_t VISUALIZER = milliseconds(0); static constexpr time_t LANELET2MAP = milliseconds(0); static constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS = milliseconds(0); // the following values are used as the number_cruncher_limit // to search for primes up to starting at 3 // for your platform, run the `number_cruncher_benchmark` executable // to figure out what values to place here corresponding to the run_time // you would like to run each node for // processing static constexpr uint64_t POINTS_TRANSFORMER_FRONT = 0; static constexpr uint64_t POINTS_TRANSFORMER_REAR = 0; static constexpr uint64_t VOXEL_GRID_DOWNSAMPLER = 0; static constexpr uint64_t POINT_CLOUD_MAP_LOADER = 0; static constexpr uint64_t RAY_GROUND_FILTER = 0; static constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR = 0; static constexpr uint64_t EUCLIDEAN_INTERSECTION = 0; static constexpr uint64_t OBJECT_COLLISION_ESTIMATOR = 0; static constexpr uint64_t MPC_CONTROLLER = 0; static constexpr uint64_t PARKING_PLANNER = 0; static constexpr uint64_t LANE_PLANNER = 0; // fusion static constexpr uint64_t POINT_CLOUD_FUSION = 0; static constexpr uint64_t NDT_LOCALIZER = 0; static constexpr uint64_t VEHICLE_INTERFACE = 0; static constexpr uint64_t LANELET_2_GLOBAL_PLANNER = 0; static constexpr uint64_t LANELET_2_MAP_LOADER = 0; // cyclic static constexpr uint64_t BEHAVIOR_PLANNER = 0; static constexpr time_t BEHAVIOR_PLANNER_CYCLE = milliseconds(0); }; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::FRONT_LIDAR_DRIVER; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::REAR_LIDAR_DRIVER; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::POINT_CLOUD_MAP; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::VISUALIZER; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::LANELET2MAP; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::EUCLIDEAN_CLUSTER_SETTINGS; constexpr uint64_t BenchmarkThroughput::POINTS_TRANSFORMER_FRONT; constexpr uint64_t BenchmarkThroughput::POINTS_TRANSFORMER_REAR; constexpr uint64_t BenchmarkThroughput::VOXEL_GRID_DOWNSAMPLER; constexpr uint64_t BenchmarkThroughput::POINT_CLOUD_MAP_LOADER; constexpr uint64_t BenchmarkThroughput::RAY_GROUND_FILTER; constexpr uint64_t BenchmarkThroughput::EUCLIDEAN_CLUSTER_DETECTOR; constexpr uint64_t BenchmarkThroughput::EUCLIDEAN_INTERSECTION; constexpr uint64_t BenchmarkThroughput::OBJECT_COLLISION_ESTIMATOR; constexpr uint64_t BenchmarkThroughput::MPC_CONTROLLER; constexpr uint64_t BenchmarkThroughput::PARKING_PLANNER; constexpr uint64_t BenchmarkThroughput::LANE_PLANNER; constexpr uint64_t BenchmarkThroughput::POINT_CLOUD_FUSION; constexpr uint64_t BenchmarkThroughput::NDT_LOCALIZER; constexpr uint64_t BenchmarkThroughput::VEHICLE_INTERFACE; constexpr uint64_t BenchmarkThroughput::LANELET_2_GLOBAL_PLANNER; constexpr uint64_t BenchmarkThroughput::LANELET_2_MAP_LOADER; constexpr uint64_t BenchmarkThroughput::BEHAVIOR_PLANNER; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::BEHAVIOR_PLANNER_CYCLE; struct BenchmarkCPUUsage { using time_t = std::chrono::nanoseconds; using milliseconds = std::chrono::milliseconds; using seconds = std::chrono::seconds; // sensors static constexpr time_t FRONT_LIDAR_DRIVER = Default::FRONT_LIDAR_DRIVER; static constexpr time_t REAR_LIDAR_DRIVER = Default::REAR_LIDAR_DRIVER; static constexpr time_t POINT_CLOUD_MAP = Default::POINT_CLOUD_MAP; static constexpr time_t VISUALIZER = Default::VISUALIZER; static constexpr time_t LANELET2MAP = Default::LANELET2MAP; static constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS = Default::EUCLIDEAN_CLUSTER_SETTINGS; // the following values are used as the number_cruncher_limit // to search for primes up to starting at 3 // for your platform, run the `number_cruncher_benchmark` executable // to figure out what values to place here corresponding to the run_time // you would like to run each node for // processing static constexpr uint64_t POINTS_TRANSFORMER_FRONT = 0; static constexpr uint64_t POINTS_TRANSFORMER_REAR = 0; static constexpr uint64_t VOXEL_GRID_DOWNSAMPLER = 0; static constexpr uint64_t POINT_CLOUD_MAP_LOADER = 0; static constexpr uint64_t RAY_GROUND_FILTER = 0; static constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR = 0; static constexpr uint64_t EUCLIDEAN_INTERSECTION = 0; static constexpr uint64_t OBJECT_COLLISION_ESTIMATOR = 0; static constexpr uint64_t MPC_CONTROLLER = 0; static constexpr uint64_t PARKING_PLANNER = 0; static constexpr uint64_t LANE_PLANNER = 0; // fusion static constexpr uint64_t POINT_CLOUD_FUSION = 0; static constexpr uint64_t NDT_LOCALIZER = 0; static constexpr uint64_t VEHICLE_INTERFACE = 0; static constexpr uint64_t LANELET_2_GLOBAL_PLANNER = 0; static constexpr uint64_t LANELET_2_MAP_LOADER = 0; // cyclic static constexpr uint64_t BEHAVIOR_PLANNER = 0; static constexpr time_t BEHAVIOR_PLANNER_CYCLE = Default::BEHAVIOR_PLANNER_CYCLE; }; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::FRONT_LIDAR_DRIVER; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::REAR_LIDAR_DRIVER; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::POINT_CLOUD_MAP; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::VISUALIZER; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::LANELET2MAP; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::EUCLIDEAN_CLUSTER_SETTINGS; constexpr uint64_t BenchmarkCPUUsage::POINTS_TRANSFORMER_FRONT; constexpr uint64_t BenchmarkCPUUsage::POINTS_TRANSFORMER_REAR; constexpr uint64_t BenchmarkCPUUsage::VOXEL_GRID_DOWNSAMPLER; constexpr uint64_t BenchmarkCPUUsage::POINT_CLOUD_MAP_LOADER; constexpr uint64_t BenchmarkCPUUsage::RAY_GROUND_FILTER; constexpr uint64_t BenchmarkCPUUsage::EUCLIDEAN_CLUSTER_DETECTOR; constexpr uint64_t BenchmarkCPUUsage::EUCLIDEAN_INTERSECTION; constexpr uint64_t BenchmarkCPUUsage::OBJECT_COLLISION_ESTIMATOR; constexpr uint64_t BenchmarkCPUUsage::MPC_CONTROLLER; constexpr uint64_t BenchmarkCPUUsage::PARKING_PLANNER; constexpr uint64_t BenchmarkCPUUsage::LANE_PLANNER; constexpr uint64_t BenchmarkCPUUsage::POINT_CLOUD_FUSION; constexpr uint64_t BenchmarkCPUUsage::NDT_LOCALIZER; constexpr uint64_t BenchmarkCPUUsage::VEHICLE_INTERFACE; constexpr uint64_t BenchmarkCPUUsage::LANELET_2_GLOBAL_PLANNER; constexpr uint64_t BenchmarkCPUUsage::LANELET_2_MAP_LOADER; constexpr uint64_t BenchmarkCPUUsage::BEHAVIOR_PLANNER; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::BEHAVIOR_PLANNER_CYCLE; } // namespace timing } // namespace nodes #endif // AUTOWARE_REFERENCE_SYSTEM__SYSTEM__TIMING__BENCHMARK_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/include/autoware_reference_system/system/timing/benchmark.hpp"},{"location":"Files/benchmark_8hpp/#autoware_reference_systemincludeautoware_reference_systemsystemtimingbenchmarkhpp","text":"","title":"autoware_reference_system/include/autoware_reference_system/system/timing/benchmark.hpp"},{"location":"Files/benchmark_8hpp/#namespaces","text":"Name nodes nodes::timing","title":"Namespaces"},{"location":"Files/benchmark_8hpp/#classes","text":"Name struct nodes::timing::BenchmarkThroughput struct nodes::timing::BenchmarkCPUUsage","title":"Classes"},{"location":"Files/benchmark_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef AUTOWARE_REFERENCE_SYSTEM__SYSTEM__TIMING__BENCHMARK_HPP_ #define AUTOWARE_REFERENCE_SYSTEM__SYSTEM__TIMING__BENCHMARK_HPP_ #include <chrono> #include \"default.hpp\" namespace nodes { namespace timing { struct BenchmarkThroughput { using time_t = std::chrono::nanoseconds; using milliseconds = std::chrono::milliseconds; using seconds = std::chrono::seconds; // sensors static constexpr time_t FRONT_LIDAR_DRIVER = milliseconds(0); static constexpr time_t REAR_LIDAR_DRIVER = milliseconds(0); static constexpr time_t POINT_CLOUD_MAP = milliseconds(0); static constexpr time_t VISUALIZER = milliseconds(0); static constexpr time_t LANELET2MAP = milliseconds(0); static constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS = milliseconds(0); // the following values are used as the number_cruncher_limit // to search for primes up to starting at 3 // for your platform, run the `number_cruncher_benchmark` executable // to figure out what values to place here corresponding to the run_time // you would like to run each node for // processing static constexpr uint64_t POINTS_TRANSFORMER_FRONT = 0; static constexpr uint64_t POINTS_TRANSFORMER_REAR = 0; static constexpr uint64_t VOXEL_GRID_DOWNSAMPLER = 0; static constexpr uint64_t POINT_CLOUD_MAP_LOADER = 0; static constexpr uint64_t RAY_GROUND_FILTER = 0; static constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR = 0; static constexpr uint64_t EUCLIDEAN_INTERSECTION = 0; static constexpr uint64_t OBJECT_COLLISION_ESTIMATOR = 0; static constexpr uint64_t MPC_CONTROLLER = 0; static constexpr uint64_t PARKING_PLANNER = 0; static constexpr uint64_t LANE_PLANNER = 0; // fusion static constexpr uint64_t POINT_CLOUD_FUSION = 0; static constexpr uint64_t NDT_LOCALIZER = 0; static constexpr uint64_t VEHICLE_INTERFACE = 0; static constexpr uint64_t LANELET_2_GLOBAL_PLANNER = 0; static constexpr uint64_t LANELET_2_MAP_LOADER = 0; // cyclic static constexpr uint64_t BEHAVIOR_PLANNER = 0; static constexpr time_t BEHAVIOR_PLANNER_CYCLE = milliseconds(0); }; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::FRONT_LIDAR_DRIVER; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::REAR_LIDAR_DRIVER; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::POINT_CLOUD_MAP; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::VISUALIZER; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::LANELET2MAP; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::EUCLIDEAN_CLUSTER_SETTINGS; constexpr uint64_t BenchmarkThroughput::POINTS_TRANSFORMER_FRONT; constexpr uint64_t BenchmarkThroughput::POINTS_TRANSFORMER_REAR; constexpr uint64_t BenchmarkThroughput::VOXEL_GRID_DOWNSAMPLER; constexpr uint64_t BenchmarkThroughput::POINT_CLOUD_MAP_LOADER; constexpr uint64_t BenchmarkThroughput::RAY_GROUND_FILTER; constexpr uint64_t BenchmarkThroughput::EUCLIDEAN_CLUSTER_DETECTOR; constexpr uint64_t BenchmarkThroughput::EUCLIDEAN_INTERSECTION; constexpr uint64_t BenchmarkThroughput::OBJECT_COLLISION_ESTIMATOR; constexpr uint64_t BenchmarkThroughput::MPC_CONTROLLER; constexpr uint64_t BenchmarkThroughput::PARKING_PLANNER; constexpr uint64_t BenchmarkThroughput::LANE_PLANNER; constexpr uint64_t BenchmarkThroughput::POINT_CLOUD_FUSION; constexpr uint64_t BenchmarkThroughput::NDT_LOCALIZER; constexpr uint64_t BenchmarkThroughput::VEHICLE_INTERFACE; constexpr uint64_t BenchmarkThroughput::LANELET_2_GLOBAL_PLANNER; constexpr uint64_t BenchmarkThroughput::LANELET_2_MAP_LOADER; constexpr uint64_t BenchmarkThroughput::BEHAVIOR_PLANNER; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::BEHAVIOR_PLANNER_CYCLE; struct BenchmarkCPUUsage { using time_t = std::chrono::nanoseconds; using milliseconds = std::chrono::milliseconds; using seconds = std::chrono::seconds; // sensors static constexpr time_t FRONT_LIDAR_DRIVER = Default::FRONT_LIDAR_DRIVER; static constexpr time_t REAR_LIDAR_DRIVER = Default::REAR_LIDAR_DRIVER; static constexpr time_t POINT_CLOUD_MAP = Default::POINT_CLOUD_MAP; static constexpr time_t VISUALIZER = Default::VISUALIZER; static constexpr time_t LANELET2MAP = Default::LANELET2MAP; static constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS = Default::EUCLIDEAN_CLUSTER_SETTINGS; // the following values are used as the number_cruncher_limit // to search for primes up to starting at 3 // for your platform, run the `number_cruncher_benchmark` executable // to figure out what values to place here corresponding to the run_time // you would like to run each node for // processing static constexpr uint64_t POINTS_TRANSFORMER_FRONT = 0; static constexpr uint64_t POINTS_TRANSFORMER_REAR = 0; static constexpr uint64_t VOXEL_GRID_DOWNSAMPLER = 0; static constexpr uint64_t POINT_CLOUD_MAP_LOADER = 0; static constexpr uint64_t RAY_GROUND_FILTER = 0; static constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR = 0; static constexpr uint64_t EUCLIDEAN_INTERSECTION = 0; static constexpr uint64_t OBJECT_COLLISION_ESTIMATOR = 0; static constexpr uint64_t MPC_CONTROLLER = 0; static constexpr uint64_t PARKING_PLANNER = 0; static constexpr uint64_t LANE_PLANNER = 0; // fusion static constexpr uint64_t POINT_CLOUD_FUSION = 0; static constexpr uint64_t NDT_LOCALIZER = 0; static constexpr uint64_t VEHICLE_INTERFACE = 0; static constexpr uint64_t LANELET_2_GLOBAL_PLANNER = 0; static constexpr uint64_t LANELET_2_MAP_LOADER = 0; // cyclic static constexpr uint64_t BEHAVIOR_PLANNER = 0; static constexpr time_t BEHAVIOR_PLANNER_CYCLE = Default::BEHAVIOR_PLANNER_CYCLE; }; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::FRONT_LIDAR_DRIVER; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::REAR_LIDAR_DRIVER; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::POINT_CLOUD_MAP; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::VISUALIZER; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::LANELET2MAP; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::EUCLIDEAN_CLUSTER_SETTINGS; constexpr uint64_t BenchmarkCPUUsage::POINTS_TRANSFORMER_FRONT; constexpr uint64_t BenchmarkCPUUsage::POINTS_TRANSFORMER_REAR; constexpr uint64_t BenchmarkCPUUsage::VOXEL_GRID_DOWNSAMPLER; constexpr uint64_t BenchmarkCPUUsage::POINT_CLOUD_MAP_LOADER; constexpr uint64_t BenchmarkCPUUsage::RAY_GROUND_FILTER; constexpr uint64_t BenchmarkCPUUsage::EUCLIDEAN_CLUSTER_DETECTOR; constexpr uint64_t BenchmarkCPUUsage::EUCLIDEAN_INTERSECTION; constexpr uint64_t BenchmarkCPUUsage::OBJECT_COLLISION_ESTIMATOR; constexpr uint64_t BenchmarkCPUUsage::MPC_CONTROLLER; constexpr uint64_t BenchmarkCPUUsage::PARKING_PLANNER; constexpr uint64_t BenchmarkCPUUsage::LANE_PLANNER; constexpr uint64_t BenchmarkCPUUsage::POINT_CLOUD_FUSION; constexpr uint64_t BenchmarkCPUUsage::NDT_LOCALIZER; constexpr uint64_t BenchmarkCPUUsage::VEHICLE_INTERFACE; constexpr uint64_t BenchmarkCPUUsage::LANELET_2_GLOBAL_PLANNER; constexpr uint64_t BenchmarkCPUUsage::LANELET_2_MAP_LOADER; constexpr uint64_t BenchmarkCPUUsage::BEHAVIOR_PLANNER; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::BEHAVIOR_PLANNER_CYCLE; } // namespace timing } // namespace nodes #endif // AUTOWARE_REFERENCE_SYSTEM__SYSTEM__TIMING__BENCHMARK_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/callback__duration_8py/","text":"autoware_reference_system/test/callback_duration.py Namespaces Name callback_duration Source code # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import random from bokeh.models import ColumnDataSource from bokeh.models import DatetimeTickFormatter from bokeh.models import Legend from bokeh.models.tools import HoverTool from bokeh.plotting import figure import numpy as np import pandas as pd def summary(data_model, size): callback_symbols = data_model.get_callback_symbols() colours = [] # Adds random colours for each callback colour_i = 0 earliest_date = None fname = '' for obj, symbol in callback_symbols.items(): duration_df = data_model.get_callback_durations(obj) thedate = duration_df.loc[:, 'timestamp'].iloc[0] if earliest_date is None or thedate <= earliest_date: earliest_date = thedate starttime = earliest_date.strftime('%Y-%m-%d %H:%M') duration = figure( title='Callback Durations Summary', x_axis_label=f'start ({starttime})', y_axis_label='duration (ms)', plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) legend_it = [] for obj, symbol in callback_symbols.items(): # Filter out internal subscriptions and get node information owner_info = data_model.get_callback_owner_info(obj) if not owner_info or '/parameter_events' in owner_info: continue if(len(colours) <= colour_i): colours.append('#%06X' % random.randint(0, 256**3-1)) duration_df = data_model.get_callback_durations(obj) source = ColumnDataSource(duration_df) duration.title.align = 'center' substr = 'node: ' index = str.find(owner_info, substr) if index >= 0: index += len(substr) fname = 'node_' + owner_info[index:(str.find(owner_info, ','))] substr = 'topic: /' index = str.find(owner_info, substr) if index >= 0: index += len(substr) fname += '_topic_' + owner_info[index:] c = duration.line( x='timestamp', y='duration', line_width=2, source=source, line_color=colours[colour_i], alpha=0.8, muted_color=colours[colour_i], muted_alpha=0.2, name=fname ) legend_it.append((fname, [c])) colour_i += 1 # duration.legend.label_text_font_size = '11px' duration.xaxis[0].formatter = DatetimeTickFormatter(seconds=['%Ss']) legend = Legend( items=legend_it, label_text_font_size='8pt', label_standoff=1, padding=1, spacing=1 ) legend.click_policy = 'hide' duration.add_layout(legend, 'right') # add hover tool hover = HoverTool() hover.tooltips = [ ('Callback', '$name'), ('Duration', '@duration{0.000}' + 's'), ('Timestamp', '@timestamp{%S.%3Ns}') ] hover.formatters = { '@timestamp': 'datetime' } duration.add_tools(hover) return duration # show(duration) # export_png(duration, filename=path + 'callback_duration_summary.png') def individual(data_model, size): # returns a list of individual plots for each callback symbol callback_symbols = data_model.get_callback_symbols() colours = [] # Adds random colours for each callback colour_i = 0 fname = '' figs = [] for obj, symbol in callback_symbols.items(): owner_info = data_model.get_callback_owner_info(obj) if owner_info is None: owner_info = '[unknown]' # Filter out internal subscriptions if '/parameter_events' in owner_info: continue substr = 'node: ' index = str.find(owner_info, substr) if index >= 0: index += len(substr) fname = 'node_' + owner_info[index:(str.find(owner_info, ','))] substr = 'topic: /' index = str.find(owner_info, substr) if index >= 0: index += len(substr) fname += '_topic_' + owner_info[index:] # Duration duration_df = data_model.get_callback_durations(obj) starttime = duration_df.loc[:, 'timestamp'].iloc[0].strftime('%Y-%m-%d %H:%M') source = ColumnDataSource(duration_df) duration = figure( title='Callback Duration Over time', x_axis_label=f'start ({starttime})', y_axis_label='duration (ms)', plot_width=int(size * 1.2), plot_height=size, margin=(10, 10, 10, 175) # Top, R, Bottom, L ) duration.title.align = 'center' if(len(colours) <= colour_i): colours.append('#%06X' % random.randint(0, 256**3-1)) duration.line( x='timestamp', y='duration', legend_label=fname, line_width=2, source=source, line_color=colours[colour_i] ) # duration.legend_label.text_font_size = '11px' duration.xaxis[0].formatter = DatetimeTickFormatter(seconds=['%Ss']) # add hover tool hover = HoverTool() hover.tooltips = [ ('Duration', '@duration{0.000}' + 's'), ('Timestamp', '@timestamp{%S.%3Ns}') ] hover.formatters = { '@timestamp': 'datetime' } duration.add_tools(hover) # Histogram # (convert to milliseconds) dur_hist, edges = np.histogram(duration_df['duration'] * 1000 / np.timedelta64(1, 's')) duration_hist = pd.DataFrame({ 'duration': dur_hist, 'left': edges[:-1], 'right': edges[1:], }) hist = figure( title='Frequency of Callback Duration', x_axis_label='duration (ms)', y_axis_label='frequency', plot_width=int(size * 1.2), plot_height=size, margin=(10, 10, 10, 25) # Top, R, Bottom, L ) hist.title.align = 'center' hist.quad( bottom=0, top=duration_hist['duration'], left=duration_hist['left'], right=duration_hist['right'], fill_color=colours[colour_i], line_color=colours[colour_i], legend_label=fname ) colour_i += 1 figs.append([duration, hist]) return figs Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/test/callback_duration.py"},{"location":"Files/callback__duration_8py/#autoware_reference_systemtestcallback_durationpy","text":"","title":"autoware_reference_system/test/callback_duration.py"},{"location":"Files/callback__duration_8py/#namespaces","text":"Name callback_duration","title":"Namespaces"},{"location":"Files/callback__duration_8py/#source-code","text":"# Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import random from bokeh.models import ColumnDataSource from bokeh.models import DatetimeTickFormatter from bokeh.models import Legend from bokeh.models.tools import HoverTool from bokeh.plotting import figure import numpy as np import pandas as pd def summary(data_model, size): callback_symbols = data_model.get_callback_symbols() colours = [] # Adds random colours for each callback colour_i = 0 earliest_date = None fname = '' for obj, symbol in callback_symbols.items(): duration_df = data_model.get_callback_durations(obj) thedate = duration_df.loc[:, 'timestamp'].iloc[0] if earliest_date is None or thedate <= earliest_date: earliest_date = thedate starttime = earliest_date.strftime('%Y-%m-%d %H:%M') duration = figure( title='Callback Durations Summary', x_axis_label=f'start ({starttime})', y_axis_label='duration (ms)', plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) legend_it = [] for obj, symbol in callback_symbols.items(): # Filter out internal subscriptions and get node information owner_info = data_model.get_callback_owner_info(obj) if not owner_info or '/parameter_events' in owner_info: continue if(len(colours) <= colour_i): colours.append('#%06X' % random.randint(0, 256**3-1)) duration_df = data_model.get_callback_durations(obj) source = ColumnDataSource(duration_df) duration.title.align = 'center' substr = 'node: ' index = str.find(owner_info, substr) if index >= 0: index += len(substr) fname = 'node_' + owner_info[index:(str.find(owner_info, ','))] substr = 'topic: /' index = str.find(owner_info, substr) if index >= 0: index += len(substr) fname += '_topic_' + owner_info[index:] c = duration.line( x='timestamp', y='duration', line_width=2, source=source, line_color=colours[colour_i], alpha=0.8, muted_color=colours[colour_i], muted_alpha=0.2, name=fname ) legend_it.append((fname, [c])) colour_i += 1 # duration.legend.label_text_font_size = '11px' duration.xaxis[0].formatter = DatetimeTickFormatter(seconds=['%Ss']) legend = Legend( items=legend_it, label_text_font_size='8pt', label_standoff=1, padding=1, spacing=1 ) legend.click_policy = 'hide' duration.add_layout(legend, 'right') # add hover tool hover = HoverTool() hover.tooltips = [ ('Callback', '$name'), ('Duration', '@duration{0.000}' + 's'), ('Timestamp', '@timestamp{%S.%3Ns}') ] hover.formatters = { '@timestamp': 'datetime' } duration.add_tools(hover) return duration # show(duration) # export_png(duration, filename=path + 'callback_duration_summary.png') def individual(data_model, size): # returns a list of individual plots for each callback symbol callback_symbols = data_model.get_callback_symbols() colours = [] # Adds random colours for each callback colour_i = 0 fname = '' figs = [] for obj, symbol in callback_symbols.items(): owner_info = data_model.get_callback_owner_info(obj) if owner_info is None: owner_info = '[unknown]' # Filter out internal subscriptions if '/parameter_events' in owner_info: continue substr = 'node: ' index = str.find(owner_info, substr) if index >= 0: index += len(substr) fname = 'node_' + owner_info[index:(str.find(owner_info, ','))] substr = 'topic: /' index = str.find(owner_info, substr) if index >= 0: index += len(substr) fname += '_topic_' + owner_info[index:] # Duration duration_df = data_model.get_callback_durations(obj) starttime = duration_df.loc[:, 'timestamp'].iloc[0].strftime('%Y-%m-%d %H:%M') source = ColumnDataSource(duration_df) duration = figure( title='Callback Duration Over time', x_axis_label=f'start ({starttime})', y_axis_label='duration (ms)', plot_width=int(size * 1.2), plot_height=size, margin=(10, 10, 10, 175) # Top, R, Bottom, L ) duration.title.align = 'center' if(len(colours) <= colour_i): colours.append('#%06X' % random.randint(0, 256**3-1)) duration.line( x='timestamp', y='duration', legend_label=fname, line_width=2, source=source, line_color=colours[colour_i] ) # duration.legend_label.text_font_size = '11px' duration.xaxis[0].formatter = DatetimeTickFormatter(seconds=['%Ss']) # add hover tool hover = HoverTool() hover.tooltips = [ ('Duration', '@duration{0.000}' + 's'), ('Timestamp', '@timestamp{%S.%3Ns}') ] hover.formatters = { '@timestamp': 'datetime' } duration.add_tools(hover) # Histogram # (convert to milliseconds) dur_hist, edges = np.histogram(duration_df['duration'] * 1000 / np.timedelta64(1, 's')) duration_hist = pd.DataFrame({ 'duration': dur_hist, 'left': edges[:-1], 'right': edges[1:], }) hist = figure( title='Frequency of Callback Duration', x_axis_label='duration (ms)', y_axis_label='frequency', plot_width=int(size * 1.2), plot_height=size, margin=(10, 10, 10, 25) # Top, R, Bottom, L ) hist.title.align = 'center' hist.quad( bottom=0, top=duration_hist['duration'], left=duration_hist['left'], right=duration_hist['right'], fill_color=colours[colour_i], line_color=colours[colour_i], legend_label=fname ) colour_i += 1 figs.append([duration, hist]) return figs Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/command_8hpp/","text":"reference_system/include/reference_system/nodes/rclcpp/command.hpp Namespaces Name nodes nodes::rclcpp_system Classes Name class nodes::rclcpp_system::Command Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__RCLCPP__COMMAND_HPP_ #define REFERENCE_SYSTEM__NODES__RCLCPP__COMMAND_HPP_ #include <chrono> #include <string> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/sample_management.hpp\" #include \"reference_system/msg_types.hpp\" namespace nodes { namespace rclcpp_system { class Command : public rclcpp::Node { public: explicit Command(const CommandSettings & settings) : Node(settings.node_name) { subscription_ = this->create_subscription<message_t>( settings.input_topic, 10, [this](const message_t::SharedPtr msg) {input_callback(msg);}); } private: void input_callback(const message_t::SharedPtr input_message) { uint32_t missed_samples = get_missed_samples_and_update_seq_nr(input_message, sequence_number_); print_sample_path(this->get_name(), missed_samples, input_message); } private: rclcpp::Subscription<message_t>::SharedPtr subscription_; uint32_t sequence_number_ = 0; }; } // namespace rclcpp_system } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__RCLCPP__COMMAND_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_system/include/reference_system/nodes/rclcpp/command.hpp"},{"location":"Files/command_8hpp/#reference_systemincludereference_systemnodesrclcppcommandhpp","text":"","title":"reference_system/include/reference_system/nodes/rclcpp/command.hpp"},{"location":"Files/command_8hpp/#namespaces","text":"Name nodes nodes::rclcpp_system","title":"Namespaces"},{"location":"Files/command_8hpp/#classes","text":"Name class nodes::rclcpp_system::Command","title":"Classes"},{"location":"Files/command_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__RCLCPP__COMMAND_HPP_ #define REFERENCE_SYSTEM__NODES__RCLCPP__COMMAND_HPP_ #include <chrono> #include <string> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/sample_management.hpp\" #include \"reference_system/msg_types.hpp\" namespace nodes { namespace rclcpp_system { class Command : public rclcpp::Node { public: explicit Command(const CommandSettings & settings) : Node(settings.node_name) { subscription_ = this->create_subscription<message_t>( settings.input_topic, 10, [this](const message_t::SharedPtr msg) {input_callback(msg);}); } private: void input_callback(const message_t::SharedPtr input_message) { uint32_t missed_samples = get_missed_samples_and_update_seq_nr(input_message, sequence_number_); print_sample_path(this->get_name(), missed_samples, input_message); } private: rclcpp::Subscription<message_t>::SharedPtr subscription_; uint32_t sequence_number_ = 0; }; } // namespace rclcpp_system } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__RCLCPP__COMMAND_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/constants_8py/","text":"autoware_reference_system/test/constants.py Namespaces Name constants Source code # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. TRACE_CALLBACK = 'tracing' TRACE_MEMORY = 'memory' TRACE_STD = 'log' # TODO(flynneva): support path as just the `tracing` directory and loop over # all subdirectories that have tracing data in them TRACE_DIRECTORY = 'tracing' SIZE_SUMMARY = 800 SIZE_SUBPLOT = 500 SIZE_TABLE_ROW = 50 SIZE_TABLE_WIDTH = 1250 SIZE_TITLE = '22px' SIZE_AXIS_LABEL = '20px' SIZE_CATEGORY_LABEL = '15px' SIZE_MAJOR_LABEL = '14px' Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/test/constants.py"},{"location":"Files/constants_8py/#autoware_reference_systemtestconstantspy","text":"","title":"autoware_reference_system/test/constants.py"},{"location":"Files/constants_8py/#namespaces","text":"Name constants","title":"Namespaces"},{"location":"Files/constants_8py/#source-code","text":"# Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. TRACE_CALLBACK = 'tracing' TRACE_MEMORY = 'memory' TRACE_STD = 'log' # TODO(flynneva): support path as just the `tracing` directory and loop over # all subdirectories that have tracing data in them TRACE_DIRECTORY = 'tracing' SIZE_SUMMARY = 800 SIZE_SUBPLOT = 500 SIZE_TABLE_ROW = 50 SIZE_TABLE_WIDTH = 1250 SIZE_TITLE = '22px' SIZE_AXIS_LABEL = '20px' SIZE_CATEGORY_LABEL = '15px' SIZE_MAJOR_LABEL = '14px' Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/cyclic_8hpp/","text":"reference_system/include/reference_system/nodes/rclcpp/cyclic.hpp Namespaces Name nodes nodes::rclcpp_system Classes Name class nodes::rclcpp_system::Cyclic Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__RCLCPP__CYCLIC_HPP_ #define REFERENCE_SYSTEM__NODES__RCLCPP__CYCLIC_HPP_ #include <chrono> #include <string> #include <utility> #include <vector> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/number_cruncher.hpp\" #include \"reference_system/sample_management.hpp\" #include \"reference_system/msg_types.hpp\" namespace nodes { namespace rclcpp_system { class Cyclic : public rclcpp::Node { public: explicit Cyclic(const CyclicSettings & settings) : Node(settings.node_name), number_crunch_limit_(settings.number_crunch_limit) { uint64_t input_number = 0U; for (const auto & input_topic : settings.inputs) { subscriptions_.emplace_back( subscription_t{ this->create_subscription<message_t>( input_topic, 1, [this, input_number](const message_t::SharedPtr msg) { input_callback(input_number, msg); }), 0, message_t::SharedPtr()}); ++input_number; } publisher_ = this->create_publisher<message_t>(settings.output_topic, 1); timer_ = this->create_wall_timer( settings.cycle_time, [this] {timer_callback();}); } private: void input_callback( const uint64_t input_number, const message_t::SharedPtr input_message) { subscriptions_[input_number].cache = input_message; } void timer_callback() { uint64_t timestamp = now_as_int(); auto number_cruncher_result = number_cruncher(number_crunch_limit_); auto output_message = publisher_->borrow_loaned_message(); output_message.get().size = 0; uint32_t missed_samples = 0; for (auto & s : subscriptions_) { if (!s.cache) {continue;} missed_samples += get_missed_samples_and_update_seq_nr(s.cache, s.sequence_number); merge_history_into_sample(output_message.get(), s.cache); s.cache.reset(); } set_sample( this->get_name(), sequence_number_++, missed_samples, timestamp, output_message.get()); output_message.get().data[0] = number_cruncher_result; publisher_->publish(std::move(output_message)); } private: rclcpp::Publisher<message_t>::SharedPtr publisher_; rclcpp::TimerBase::SharedPtr timer_; struct subscription_t { rclcpp::Subscription<message_t>::SharedPtr subscription; uint32_t sequence_number = 0; message_t::SharedPtr cache; }; std::vector<subscription_t> subscriptions_; uint64_t number_crunch_limit_; uint32_t sequence_number_ = 0; }; } // namespace rclcpp_system } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__RCLCPP__CYCLIC_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_system/include/reference_system/nodes/rclcpp/cyclic.hpp"},{"location":"Files/cyclic_8hpp/#reference_systemincludereference_systemnodesrclcppcyclichpp","text":"","title":"reference_system/include/reference_system/nodes/rclcpp/cyclic.hpp"},{"location":"Files/cyclic_8hpp/#namespaces","text":"Name nodes nodes::rclcpp_system","title":"Namespaces"},{"location":"Files/cyclic_8hpp/#classes","text":"Name class nodes::rclcpp_system::Cyclic","title":"Classes"},{"location":"Files/cyclic_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__RCLCPP__CYCLIC_HPP_ #define REFERENCE_SYSTEM__NODES__RCLCPP__CYCLIC_HPP_ #include <chrono> #include <string> #include <utility> #include <vector> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/number_cruncher.hpp\" #include \"reference_system/sample_management.hpp\" #include \"reference_system/msg_types.hpp\" namespace nodes { namespace rclcpp_system { class Cyclic : public rclcpp::Node { public: explicit Cyclic(const CyclicSettings & settings) : Node(settings.node_name), number_crunch_limit_(settings.number_crunch_limit) { uint64_t input_number = 0U; for (const auto & input_topic : settings.inputs) { subscriptions_.emplace_back( subscription_t{ this->create_subscription<message_t>( input_topic, 1, [this, input_number](const message_t::SharedPtr msg) { input_callback(input_number, msg); }), 0, message_t::SharedPtr()}); ++input_number; } publisher_ = this->create_publisher<message_t>(settings.output_topic, 1); timer_ = this->create_wall_timer( settings.cycle_time, [this] {timer_callback();}); } private: void input_callback( const uint64_t input_number, const message_t::SharedPtr input_message) { subscriptions_[input_number].cache = input_message; } void timer_callback() { uint64_t timestamp = now_as_int(); auto number_cruncher_result = number_cruncher(number_crunch_limit_); auto output_message = publisher_->borrow_loaned_message(); output_message.get().size = 0; uint32_t missed_samples = 0; for (auto & s : subscriptions_) { if (!s.cache) {continue;} missed_samples += get_missed_samples_and_update_seq_nr(s.cache, s.sequence_number); merge_history_into_sample(output_message.get(), s.cache); s.cache.reset(); } set_sample( this->get_name(), sequence_number_++, missed_samples, timestamp, output_message.get()); output_message.get().data[0] = number_cruncher_result; publisher_->publish(std::move(output_message)); } private: rclcpp::Publisher<message_t>::SharedPtr publisher_; rclcpp::TimerBase::SharedPtr timer_; struct subscription_t { rclcpp::Subscription<message_t>::SharedPtr subscription; uint32_t sequence_number = 0; message_t::SharedPtr cache; }; std::vector<subscription_t> subscriptions_; uint64_t number_crunch_limit_; uint32_t sequence_number_ = 0; }; } // namespace rclcpp_system } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__RCLCPP__CYCLIC_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/default_8hpp/","text":"autoware_reference_system/include/autoware_reference_system/system/timing/default.hpp Namespaces Name nodes nodes::timing Classes Name struct nodes::timing::Default Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef AUTOWARE_REFERENCE_SYSTEM__SYSTEM__TIMING__DEFAULT_HPP_ #define AUTOWARE_REFERENCE_SYSTEM__SYSTEM__TIMING__DEFAULT_HPP_ #include <chrono> namespace nodes { namespace timing { struct Default { using time_t = std::chrono::nanoseconds; using milliseconds = std::chrono::milliseconds; // sensors static constexpr time_t FRONT_LIDAR_DRIVER = milliseconds(100); static constexpr time_t REAR_LIDAR_DRIVER = milliseconds(100); static constexpr time_t POINT_CLOUD_MAP = milliseconds(120); static constexpr time_t VISUALIZER = milliseconds(60); static constexpr time_t LANELET2MAP = milliseconds(100); static constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS = milliseconds(25); // the following values are used as the number_cruncher_limit // to search for primes up to starting at 3 // for your platform, run the `number_cruncher_benchmark` executable // to figure out what values to place here corresponding to the run_time // you would like to run each node for // processing static constexpr uint64_t POINTS_TRANSFORMER_FRONT = 65536; static constexpr uint64_t POINTS_TRANSFORMER_REAR = 65536; static constexpr uint64_t VOXEL_GRID_DOWNSAMPLER = 65536; static constexpr uint64_t POINT_CLOUD_MAP_LOADER = 65536; static constexpr uint64_t RAY_GROUND_FILTER = 65536; static constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR = 65536; static constexpr uint64_t EUCLIDEAN_INTERSECTION = 65536; static constexpr uint64_t OBJECT_COLLISION_ESTIMATOR = 65536; static constexpr uint64_t MPC_CONTROLLER = 65536; static constexpr uint64_t PARKING_PLANNER = 65536; static constexpr uint64_t LANE_PLANNER = 65536; // fusion static constexpr uint64_t POINT_CLOUD_FUSION = 65536; static constexpr uint64_t NDT_LOCALIZER = 65536; static constexpr uint64_t VEHICLE_INTERFACE = 65536; static constexpr uint64_t LANELET_2_GLOBAL_PLANNER = 65536; static constexpr uint64_t LANELET_2_MAP_LOADER = 65536; // cyclic static constexpr uint64_t BEHAVIOR_PLANNER = 65536; static constexpr time_t BEHAVIOR_PLANNER_CYCLE = milliseconds(100); }; constexpr Default::time_t Default::FRONT_LIDAR_DRIVER; constexpr Default::time_t Default::REAR_LIDAR_DRIVER; constexpr Default::time_t Default::POINT_CLOUD_MAP; constexpr Default::time_t Default::VISUALIZER; constexpr Default::time_t Default::LANELET2MAP; constexpr Default::time_t Default::EUCLIDEAN_CLUSTER_SETTINGS; constexpr uint64_t Default::POINTS_TRANSFORMER_FRONT; constexpr uint64_t Default::POINTS_TRANSFORMER_REAR; constexpr uint64_t Default::VOXEL_GRID_DOWNSAMPLER; constexpr uint64_t Default::POINT_CLOUD_MAP_LOADER; constexpr uint64_t Default::RAY_GROUND_FILTER; constexpr uint64_t Default::EUCLIDEAN_CLUSTER_DETECTOR; constexpr uint64_t Default::EUCLIDEAN_INTERSECTION; constexpr uint64_t Default::OBJECT_COLLISION_ESTIMATOR; constexpr uint64_t Default::MPC_CONTROLLER; constexpr uint64_t Default::PARKING_PLANNER; constexpr uint64_t Default::LANE_PLANNER; constexpr uint64_t Default::POINT_CLOUD_FUSION; constexpr uint64_t Default::NDT_LOCALIZER; constexpr uint64_t Default::VEHICLE_INTERFACE; constexpr uint64_t Default::LANELET_2_GLOBAL_PLANNER; constexpr uint64_t Default::LANELET_2_MAP_LOADER; constexpr uint64_t Default::BEHAVIOR_PLANNER; constexpr Default::time_t Default::BEHAVIOR_PLANNER_CYCLE; } // namespace timing } // namespace nodes #endif // AUTOWARE_REFERENCE_SYSTEM__SYSTEM__TIMING__DEFAULT_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/include/autoware_reference_system/system/timing/default.hpp"},{"location":"Files/default_8hpp/#autoware_reference_systemincludeautoware_reference_systemsystemtimingdefaulthpp","text":"","title":"autoware_reference_system/include/autoware_reference_system/system/timing/default.hpp"},{"location":"Files/default_8hpp/#namespaces","text":"Name nodes nodes::timing","title":"Namespaces"},{"location":"Files/default_8hpp/#classes","text":"Name struct nodes::timing::Default","title":"Classes"},{"location":"Files/default_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef AUTOWARE_REFERENCE_SYSTEM__SYSTEM__TIMING__DEFAULT_HPP_ #define AUTOWARE_REFERENCE_SYSTEM__SYSTEM__TIMING__DEFAULT_HPP_ #include <chrono> namespace nodes { namespace timing { struct Default { using time_t = std::chrono::nanoseconds; using milliseconds = std::chrono::milliseconds; // sensors static constexpr time_t FRONT_LIDAR_DRIVER = milliseconds(100); static constexpr time_t REAR_LIDAR_DRIVER = milliseconds(100); static constexpr time_t POINT_CLOUD_MAP = milliseconds(120); static constexpr time_t VISUALIZER = milliseconds(60); static constexpr time_t LANELET2MAP = milliseconds(100); static constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS = milliseconds(25); // the following values are used as the number_cruncher_limit // to search for primes up to starting at 3 // for your platform, run the `number_cruncher_benchmark` executable // to figure out what values to place here corresponding to the run_time // you would like to run each node for // processing static constexpr uint64_t POINTS_TRANSFORMER_FRONT = 65536; static constexpr uint64_t POINTS_TRANSFORMER_REAR = 65536; static constexpr uint64_t VOXEL_GRID_DOWNSAMPLER = 65536; static constexpr uint64_t POINT_CLOUD_MAP_LOADER = 65536; static constexpr uint64_t RAY_GROUND_FILTER = 65536; static constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR = 65536; static constexpr uint64_t EUCLIDEAN_INTERSECTION = 65536; static constexpr uint64_t OBJECT_COLLISION_ESTIMATOR = 65536; static constexpr uint64_t MPC_CONTROLLER = 65536; static constexpr uint64_t PARKING_PLANNER = 65536; static constexpr uint64_t LANE_PLANNER = 65536; // fusion static constexpr uint64_t POINT_CLOUD_FUSION = 65536; static constexpr uint64_t NDT_LOCALIZER = 65536; static constexpr uint64_t VEHICLE_INTERFACE = 65536; static constexpr uint64_t LANELET_2_GLOBAL_PLANNER = 65536; static constexpr uint64_t LANELET_2_MAP_LOADER = 65536; // cyclic static constexpr uint64_t BEHAVIOR_PLANNER = 65536; static constexpr time_t BEHAVIOR_PLANNER_CYCLE = milliseconds(100); }; constexpr Default::time_t Default::FRONT_LIDAR_DRIVER; constexpr Default::time_t Default::REAR_LIDAR_DRIVER; constexpr Default::time_t Default::POINT_CLOUD_MAP; constexpr Default::time_t Default::VISUALIZER; constexpr Default::time_t Default::LANELET2MAP; constexpr Default::time_t Default::EUCLIDEAN_CLUSTER_SETTINGS; constexpr uint64_t Default::POINTS_TRANSFORMER_FRONT; constexpr uint64_t Default::POINTS_TRANSFORMER_REAR; constexpr uint64_t Default::VOXEL_GRID_DOWNSAMPLER; constexpr uint64_t Default::POINT_CLOUD_MAP_LOADER; constexpr uint64_t Default::RAY_GROUND_FILTER; constexpr uint64_t Default::EUCLIDEAN_CLUSTER_DETECTOR; constexpr uint64_t Default::EUCLIDEAN_INTERSECTION; constexpr uint64_t Default::OBJECT_COLLISION_ESTIMATOR; constexpr uint64_t Default::MPC_CONTROLLER; constexpr uint64_t Default::PARKING_PLANNER; constexpr uint64_t Default::LANE_PLANNER; constexpr uint64_t Default::POINT_CLOUD_FUSION; constexpr uint64_t Default::NDT_LOCALIZER; constexpr uint64_t Default::VEHICLE_INTERFACE; constexpr uint64_t Default::LANELET_2_GLOBAL_PLANNER; constexpr uint64_t Default::LANELET_2_MAP_LOADER; constexpr uint64_t Default::BEHAVIOR_PLANNER; constexpr Default::time_t Default::BEHAVIOR_PLANNER_CYCLE; } // namespace timing } // namespace nodes #endif // AUTOWARE_REFERENCE_SYSTEM__SYSTEM__TIMING__DEFAULT_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/dir_0346bc0d6d902878a4b20af926e2b688/","text":"autoware_reference_system/include/autoware_reference_system/system Directories Name autoware_reference_system/include/autoware_reference_system/system/timing Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/include/autoware_reference_system/system"},{"location":"Files/dir_0346bc0d6d902878a4b20af926e2b688/#autoware_reference_systemincludeautoware_reference_systemsystem","text":"","title":"autoware_reference_system/include/autoware_reference_system/system"},{"location":"Files/dir_0346bc0d6d902878a4b20af926e2b688/#directories","text":"Name autoware_reference_system/include/autoware_reference_system/system/timing Updated on 2021-12-24 at 17:45:36 +0000","title":"Directories"},{"location":"Files/dir_09addd1cc25865acff9e93b8c10e91f0/","text":"autoware_reference_system/src Directories Name autoware_reference_system/src/ros2 Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/src"},{"location":"Files/dir_09addd1cc25865acff9e93b8c10e91f0/#autoware_reference_systemsrc","text":"","title":"autoware_reference_system/src"},{"location":"Files/dir_09addd1cc25865acff9e93b8c10e91f0/#directories","text":"Name autoware_reference_system/src/ros2 Updated on 2021-12-24 at 17:45:36 +0000","title":"Directories"},{"location":"Files/dir_127c7cc0ffcbc3e61877c07b26af2fa0/","text":"reference_system Directories Name reference_system/include reference_system/test Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_system"},{"location":"Files/dir_127c7cc0ffcbc3e61877c07b26af2fa0/#reference_system","text":"","title":"reference_system"},{"location":"Files/dir_127c7cc0ffcbc3e61877c07b26af2fa0/#directories","text":"Name reference_system/include reference_system/test Updated on 2021-12-24 at 17:45:36 +0000","title":"Directories"},{"location":"Files/dir_246fa732e08bce0b2fe7c308221868df/","text":"reference_system/include/reference_system/system/type Files Name reference_system/include/reference_system/system/type/rclcpp_system.hpp Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_system/include/reference_system/system/type"},{"location":"Files/dir_246fa732e08bce0b2fe7c308221868df/#reference_systemincludereference_systemsystemtype","text":"","title":"reference_system/include/reference_system/system/type"},{"location":"Files/dir_246fa732e08bce0b2fe7c308221868df/#files","text":"Name reference_system/include/reference_system/system/type/rclcpp_system.hpp Updated on 2021-12-24 at 17:45:36 +0000","title":"Files"},{"location":"Files/dir_42b63979f223277f39dc3319aa9a7a65/","text":"autoware_reference_system/include/autoware_reference_system Directories Name autoware_reference_system/include/autoware_reference_system/system Files Name autoware_reference_system/include/autoware_reference_system/autoware_system_builder.hpp autoware_reference_system/include/autoware_reference_system/autoware_system_builder_utils.hpp Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/include/autoware_reference_system"},{"location":"Files/dir_42b63979f223277f39dc3319aa9a7a65/#autoware_reference_systemincludeautoware_reference_system","text":"","title":"autoware_reference_system/include/autoware_reference_system"},{"location":"Files/dir_42b63979f223277f39dc3319aa9a7a65/#directories","text":"Name autoware_reference_system/include/autoware_reference_system/system","title":"Directories"},{"location":"Files/dir_42b63979f223277f39dc3319aa9a7a65/#files","text":"Name autoware_reference_system/include/autoware_reference_system/autoware_system_builder.hpp autoware_reference_system/include/autoware_reference_system/autoware_system_builder_utils.hpp Updated on 2021-12-24 at 17:45:36 +0000","title":"Files"},{"location":"Files/dir_433aa5f1c128af3100645ac07e20746d/","text":"autoware_reference_system/src/ros2/executor Files Name autoware_reference_system/src/ros2/executor/autoware_default_cbg.cpp autoware_reference_system/src/ros2/executor/autoware_default_multithreaded.cpp autoware_reference_system/src/ros2/executor/autoware_default_prioritized.cpp autoware_reference_system/src/ros2/executor/autoware_default_singlethreaded.cpp autoware_reference_system/src/ros2/executor/autoware_default_staticsinglethreaded.cpp Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/src/ros2/executor"},{"location":"Files/dir_433aa5f1c128af3100645ac07e20746d/#autoware_reference_systemsrcros2executor","text":"","title":"autoware_reference_system/src/ros2/executor"},{"location":"Files/dir_433aa5f1c128af3100645ac07e20746d/#files","text":"Name autoware_reference_system/src/ros2/executor/autoware_default_cbg.cpp autoware_reference_system/src/ros2/executor/autoware_default_multithreaded.cpp autoware_reference_system/src/ros2/executor/autoware_default_prioritized.cpp autoware_reference_system/src/ros2/executor/autoware_default_singlethreaded.cpp autoware_reference_system/src/ros2/executor/autoware_default_staticsinglethreaded.cpp Updated on 2021-12-24 at 17:45:36 +0000","title":"Files"},{"location":"Files/dir_5fa14cd5f63f76c2b01ef334fb51ab9e/","text":"autoware_reference_system/include Directories Name autoware_reference_system/include/autoware_reference_system Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/include"},{"location":"Files/dir_5fa14cd5f63f76c2b01ef334fb51ab9e/#autoware_reference_systeminclude","text":"","title":"autoware_reference_system/include"},{"location":"Files/dir_5fa14cd5f63f76c2b01ef334fb51ab9e/#directories","text":"Name autoware_reference_system/include/autoware_reference_system Updated on 2021-12-24 at 17:45:36 +0000","title":"Directories"},{"location":"Files/dir_91b0f55ce06907c9ebdd60f53551d65e/","text":"reference_system/include/reference_system/system Directories Name reference_system/include/reference_system/system/type Files Name reference_system/include/reference_system/system/systems.hpp Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_system/include/reference_system/system"},{"location":"Files/dir_91b0f55ce06907c9ebdd60f53551d65e/#reference_systemincludereference_systemsystem","text":"","title":"reference_system/include/reference_system/system"},{"location":"Files/dir_91b0f55ce06907c9ebdd60f53551d65e/#directories","text":"Name reference_system/include/reference_system/system/type","title":"Directories"},{"location":"Files/dir_91b0f55ce06907c9ebdd60f53551d65e/#files","text":"Name reference_system/include/reference_system/system/systems.hpp Updated on 2021-12-24 at 17:45:36 +0000","title":"Files"},{"location":"Files/dir_97ee88642b4fc0175cf5ceed72dfc69e/","text":"reference_system/include Directories Name reference_system/include/reference_system Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_system/include"},{"location":"Files/dir_97ee88642b4fc0175cf5ceed72dfc69e/#reference_systeminclude","text":"","title":"reference_system/include"},{"location":"Files/dir_97ee88642b4fc0175cf5ceed72dfc69e/#directories","text":"Name reference_system/include/reference_system Updated on 2021-12-24 at 17:45:36 +0000","title":"Directories"},{"location":"Files/dir_9868580a2d8949ba20aec737ffd74109/","text":"reference_system/include/reference_system Directories Name reference_system/include/reference_system/nodes reference_system/include/reference_system/system Files Name reference_system/include/reference_system/msg_types.hpp reference_system/include/reference_system/number_cruncher.hpp reference_system/include/reference_system/sample_management.hpp Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_system/include/reference_system"},{"location":"Files/dir_9868580a2d8949ba20aec737ffd74109/#reference_systemincludereference_system","text":"","title":"reference_system/include/reference_system"},{"location":"Files/dir_9868580a2d8949ba20aec737ffd74109/#directories","text":"Name reference_system/include/reference_system/nodes reference_system/include/reference_system/system","title":"Directories"},{"location":"Files/dir_9868580a2d8949ba20aec737ffd74109/#files","text":"Name reference_system/include/reference_system/msg_types.hpp reference_system/include/reference_system/number_cruncher.hpp reference_system/include/reference_system/sample_management.hpp Updated on 2021-12-24 at 17:45:36 +0000","title":"Files"},{"location":"Files/dir_9fb2e5fa41f453476f53652aa901bc10/","text":"autoware_reference_system/src/ros2 Directories Name autoware_reference_system/src/ros2/executor Files Name autoware_reference_system/src/ros2/number_cruncher_benchmark.cpp Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/src/ros2"},{"location":"Files/dir_9fb2e5fa41f453476f53652aa901bc10/#autoware_reference_systemsrcros2","text":"","title":"autoware_reference_system/src/ros2"},{"location":"Files/dir_9fb2e5fa41f453476f53652aa901bc10/#directories","text":"Name autoware_reference_system/src/ros2/executor","title":"Directories"},{"location":"Files/dir_9fb2e5fa41f453476f53652aa901bc10/#files","text":"Name autoware_reference_system/src/ros2/number_cruncher_benchmark.cpp Updated on 2021-12-24 at 17:45:36 +0000","title":"Files"},{"location":"Files/dir_a9b47c5ee89e1161970d1296c923485c/","text":"reference_system/include/reference_system/nodes/rclcpp Files Name reference_system/include/reference_system/nodes/rclcpp/command.hpp reference_system/include/reference_system/nodes/rclcpp/cyclic.hpp reference_system/include/reference_system/nodes/rclcpp/fusion.hpp reference_system/include/reference_system/nodes/rclcpp/intersection.hpp reference_system/include/reference_system/nodes/rclcpp/sensor.hpp reference_system/include/reference_system/nodes/rclcpp/transform.hpp Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_system/include/reference_system/nodes/rclcpp"},{"location":"Files/dir_a9b47c5ee89e1161970d1296c923485c/#reference_systemincludereference_systemnodesrclcpp","text":"","title":"reference_system/include/reference_system/nodes/rclcpp"},{"location":"Files/dir_a9b47c5ee89e1161970d1296c923485c/#files","text":"Name reference_system/include/reference_system/nodes/rclcpp/command.hpp reference_system/include/reference_system/nodes/rclcpp/cyclic.hpp reference_system/include/reference_system/nodes/rclcpp/fusion.hpp reference_system/include/reference_system/nodes/rclcpp/intersection.hpp reference_system/include/reference_system/nodes/rclcpp/sensor.hpp reference_system/include/reference_system/nodes/rclcpp/transform.hpp Updated on 2021-12-24 at 17:45:36 +0000","title":"Files"},{"location":"Files/dir_ade77feecc6fc14930bc6f4956def00c/","text":"reference_interfaces Directories Name reference_interfaces/msg Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_interfaces"},{"location":"Files/dir_ade77feecc6fc14930bc6f4956def00c/#reference_interfaces","text":"","title":"reference_interfaces"},{"location":"Files/dir_ade77feecc6fc14930bc6f4956def00c/#directories","text":"Name reference_interfaces/msg Updated on 2021-12-24 at 17:45:36 +0000","title":"Directories"},{"location":"Files/dir_b0fed25fe70402f2c9879f17b24b63ba/","text":"autoware_reference_system Directories Name autoware_reference_system/include autoware_reference_system/src autoware_reference_system/test Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system"},{"location":"Files/dir_b0fed25fe70402f2c9879f17b24b63ba/#autoware_reference_system","text":"","title":"autoware_reference_system"},{"location":"Files/dir_b0fed25fe70402f2c9879f17b24b63ba/#directories","text":"Name autoware_reference_system/include autoware_reference_system/src autoware_reference_system/test Updated on 2021-12-24 at 17:45:36 +0000","title":"Directories"},{"location":"Files/dir_c179573033c64836cec4bb0cc3550ee6/","text":"autoware_reference_system/test Files Name autoware_reference_system/test/callback_duration.py autoware_reference_system/test/constants.py autoware_reference_system/test/dropped_messages.py autoware_reference_system/test/errors.py autoware_reference_system/test/generate_callback_traces.py autoware_reference_system/test/generate_reports.py autoware_reference_system/test/generate_std_traces.py autoware_reference_system/test/generate_summary_reports.py autoware_reference_system/test/memory_usage.py autoware_reference_system/test/std_latency.py autoware_reference_system/test/test_autoware_reference_system.cpp autoware_reference_system/test/test_platform.py autoware_reference_system/test/test_requirements.py autoware_reference_system/test/trace_utils.py autoware_reference_system/test/utils.py Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/test"},{"location":"Files/dir_c179573033c64836cec4bb0cc3550ee6/#autoware_reference_systemtest","text":"","title":"autoware_reference_system/test"},{"location":"Files/dir_c179573033c64836cec4bb0cc3550ee6/#files","text":"Name autoware_reference_system/test/callback_duration.py autoware_reference_system/test/constants.py autoware_reference_system/test/dropped_messages.py autoware_reference_system/test/errors.py autoware_reference_system/test/generate_callback_traces.py autoware_reference_system/test/generate_reports.py autoware_reference_system/test/generate_std_traces.py autoware_reference_system/test/generate_summary_reports.py autoware_reference_system/test/memory_usage.py autoware_reference_system/test/std_latency.py autoware_reference_system/test/test_autoware_reference_system.cpp autoware_reference_system/test/test_platform.py autoware_reference_system/test/test_requirements.py autoware_reference_system/test/trace_utils.py autoware_reference_system/test/utils.py Updated on 2021-12-24 at 17:45:36 +0000","title":"Files"},{"location":"Files/dir_c3a592c969eb740d8a64341e6b9a3579/","text":"reference_system/test Files Name reference_system/test/gtest_main.cpp reference_system/test/test_fixtures.hpp reference_system/test/test_number_cruncher.cpp reference_system/test/test_reference_system_rclcpp.cpp reference_system/test/test_sample_management.cpp Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_system/test"},{"location":"Files/dir_c3a592c969eb740d8a64341e6b9a3579/#reference_systemtest","text":"","title":"reference_system/test"},{"location":"Files/dir_c3a592c969eb740d8a64341e6b9a3579/#files","text":"Name reference_system/test/gtest_main.cpp reference_system/test/test_fixtures.hpp reference_system/test/test_number_cruncher.cpp reference_system/test/test_reference_system_rclcpp.cpp reference_system/test/test_sample_management.cpp Updated on 2021-12-24 at 17:45:36 +0000","title":"Files"},{"location":"Files/dir_e1d1d57603c7889177b30ad98e438429/","text":"reference_system/include/reference_system/nodes Directories Name reference_system/include/reference_system/nodes/rclcpp Files Name reference_system/include/reference_system/nodes/settings.hpp Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_system/include/reference_system/nodes"},{"location":"Files/dir_e1d1d57603c7889177b30ad98e438429/#reference_systemincludereference_systemnodes","text":"","title":"reference_system/include/reference_system/nodes"},{"location":"Files/dir_e1d1d57603c7889177b30ad98e438429/#directories","text":"Name reference_system/include/reference_system/nodes/rclcpp","title":"Directories"},{"location":"Files/dir_e1d1d57603c7889177b30ad98e438429/#files","text":"Name reference_system/include/reference_system/nodes/settings.hpp Updated on 2021-12-24 at 17:45:36 +0000","title":"Files"},{"location":"Files/dir_e241d6a2048a09ddb4361fd2440aad67/","text":"autoware_reference_system/include/autoware_reference_system/system/timing Files Name autoware_reference_system/include/autoware_reference_system/system/timing/benchmark.hpp autoware_reference_system/include/autoware_reference_system/system/timing/default.hpp Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/include/autoware_reference_system/system/timing"},{"location":"Files/dir_e241d6a2048a09ddb4361fd2440aad67/#autoware_reference_systemincludeautoware_reference_systemsystemtiming","text":"","title":"autoware_reference_system/include/autoware_reference_system/system/timing"},{"location":"Files/dir_e241d6a2048a09ddb4361fd2440aad67/#files","text":"Name autoware_reference_system/include/autoware_reference_system/system/timing/benchmark.hpp autoware_reference_system/include/autoware_reference_system/system/timing/default.hpp Updated on 2021-12-24 at 17:45:36 +0000","title":"Files"},{"location":"Files/dir_f7c5390633b5b32c3d651a98285f1453/","text":"reference_interfaces/msg Files Name reference_interfaces/msg/Message4kb.idl reference_interfaces/msg/TransmissionStats.idl Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_interfaces/msg"},{"location":"Files/dir_f7c5390633b5b32c3d651a98285f1453/#reference_interfacesmsg","text":"","title":"reference_interfaces/msg"},{"location":"Files/dir_f7c5390633b5b32c3d651a98285f1453/#files","text":"Name reference_interfaces/msg/Message4kb.idl reference_interfaces/msg/TransmissionStats.idl Updated on 2021-12-24 at 17:45:36 +0000","title":"Files"},{"location":"Files/dropped__messages_8py/","text":"autoware_reference_system/test/dropped_messages.py Namespaces Name dropped_messages Source code # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import os import random from bokeh.io import output_file # from bokeh.layouts import layout from bokeh.models import ColumnDataSource from bokeh.models import DatetimeTickFormatter from bokeh.models.ranges import FactorRange from bokeh.models.tools import HoverTool from bokeh.models.widgets.markups import Div from bokeh.models.widgets.tables import DataTable, TableColumn from bokeh.palettes import cividis from bokeh.plotting import figure from bokeh.transform import factor_cmap import networkx as nx import numpy as np import pandas as pd from trace_utils import initDataModel from utils import getDirPath def summary(path, duration, size): fname = path + 'dropped_messages_and_latency_summary_' + duration + 's' print('Output report to ' + fname + '.html') output_file( filename=fname + '.html', title='Dropped Messages and Latency Summary Report ' + duration + 's') data_dict = {} for fname in os.listdir(path): fpath = path + fname # load tracing data data_model = initDataModel(fpath) wd = getDirPath(fpath) tmp_name = wd.find('_rmw') exe = fname[0:tmp_name] rmw = fname[tmp_name + 1:-(len(duration) + 2)] try: data_dict[exe] except KeyError: data_dict[exe] = {} try: data_dict[exe][rmw] except KeyError: data_dict[exe][rmw] = {} data_dict[exe][rmw] = parseData(data_model) x = [] for exe in data_dict: for rmw in data_dict[exe]: x.append((exe, rmw)) # print(data_dict[exe][rmw]['dropped']) def individual(data_model, size): data_dict = parseData(data_model) dropped_df = data_dict['dropped'] latency_df = data_dict['latency'] run_time = data_dict['run_time'] y = list(zip(dropped_df.node, dropped_df.topic)) latency_source = ColumnDataSource(latency_df) dropped_source = ColumnDataSource(dropped_df) dropped_source.data['y'] = y # use this for axis of figure ~0.25 of buffer max_dropped = max(dropped_df['dropped']) + 0.25 # initialize figure dropped_fig = figure( title='Dropped Messages Summary ({:.2f} s) [UNDER DEVELOPMENT]'.format(float(run_time)), y_axis_label='Callback by Node and Topic Name', x_axis_label='Dropped Messages', y_range=FactorRange(*y), x_range=(0, max_dropped), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) # add horizontal bar to figure dropped_fig.hbar( y='y', right='dropped', width=0.1, source=dropped_source, fill_color=factor_cmap( 'y', palette=cividis(dropped_df['topic'].shape[0]), factors=list(dropped_df['topic'].values.tolist()), start=1, end=2) ) dropped_fig.yaxis.major_label_orientation = 'horizontal' dropped_fig.yaxis.subgroup_label_orientation = 'horizontal' dropped_fig.yaxis.group_label_orientation = 'horizontal' # add hover tool hover = HoverTool() hover.tooltips = [ ('Callback (Node and Topic)', '@node @topic'), ('Dropped', '@dropped'), ('Expected', '@expected_count'), ('Received', '@count') ] dropped_fig.add_tools(hover) # add dropped messages table dropped_summary = dropped_df.describe().T.reset_index() columns = [TableColumn(field=col, title=col) for col in dropped_summary] dropped_table_title = Div( text='<b>Dropped Messages Summary Table [UNDER DEVELOPMENT]</b>', width=1000, height=10 ) dropped_table = [ dropped_table_title, DataTable( columns=columns, source=ColumnDataSource(dropped_summary), margin=(10, 10, 10, 10), height=150, width=size)] # add latency plot latency_fig = figure( title='Latency From Front Lidar to Collision Estimator [UNDER DEVELOPMENT]', x_axis_label='Time', y_axis_label='Latency to Object Collision Estimator (ms)', plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) latency_fig.line( x='timestamp', y='latency', source=latency_source, line_width=2 ) latency_fig.xaxis[0].formatter = DatetimeTickFormatter(seconds=['%Ss']) # add latency table latency_summary = latency_df.describe().T.reset_index() columns = [TableColumn(field=col, title=col) for col in latency_summary] latency_table_title = Div( text='<b>Latency Summary Table</b>', width=1000, height=10 ) latency_table = [ latency_table_title, DataTable( columns=columns, source=ColumnDataSource(latency_summary), margin=(10, 10, 10, 10), height=75, width=size)] return [ [dropped_table], [dropped_fig], [latency_table], [latency_fig] ] def parseData(data_model): callback_symbols = data_model.get_callback_symbols() colors = [] # Adds random colors for each callback color_i = 0 earliest_date = None latest_date = None dropped_data = [] front_lidar_data = pd.DataFrame() object_collision_data = pd.DataFrame() for obj, symbol in callback_symbols.items(): callback_df = data_model.get_callback_durations(obj) # get node information and filter out internal subscriptions owner_info = data_model.get_callback_owner_info(obj) if owner_info is not None: if '/parameter_events' in owner_info: continue period = 0.0 if 'period' in owner_info: # assume in milliseconds so convert to seconds period = float(owner_info[ owner_info.find('period: ') + len('period: '):owner_info.rfind(' ')]) / 1000 if 'FrontLidarDriver' in owner_info and 'Timer' in owner_info: front_lidar_data = callback_df if 'ObjectCollisionEstimator' in owner_info: object_collision_data = callback_df # add color to list if needed if(len(colors) <= color_i): colors.append('#%06X' % random.randint(0, 256**3-1)) # get human readable name of callback substr = 'node: ' index = str.find(owner_info, substr) if index >= 0: index += len(substr) node = owner_info[index:(str.find(owner_info, ','))] substr = 'topic: /' index = str.find(owner_info, substr) if index >= 0: index += len(substr) topic = owner_info[index:] else: topic = '' # get first and last timestamp of data thefirstdate = callback_df.loc[:, 'timestamp'].iloc[0] if earliest_date is None: earliest_date = thefirstdate elif earliest_date is not None and thefirstdate <= earliest_date: earliest_date = thefirstdate thelastdate = callback_df.loc[:, 'timestamp'].iloc[len(callback_df)-1] if latest_date is None: latest_date = thelastdate elif latest_date is not None and thelastdate >= latest_date: latest_date = thelastdate # add name of callback and count to list dropped_data.append( [str(node), str(topic), float(len(callback_df)), period, 0.0, 0.0, colors[color_i]]) color_i += 1 front_lidar_data = front_lidar_data.reset_index(drop=True) object_collision_data = object_collision_data.reset_index(drop=True) # ensure dataframes are same length for latency calc, drop extra lidar frames extra = len(front_lidar_data) - len(object_collision_data) if(extra > 0): front_lidar_data.drop(front_lidar_data.tail(extra).index, inplace=True) latency = object_collision_data['timestamp'] - front_lidar_data['timestamp'] dropped_df = pd.DataFrame( dropped_data, columns=['node', 'topic', 'count', 'period', 'dropped', 'expected_count', 'color']) latency_df = pd.DataFrame( {'index': range(0, len(latency)), 'latency': latency, 'timestamp': front_lidar_data['timestamp']}) # sort values by node and topic dropped_df = dropped_df.sort_values(by=['node', 'topic']) # generate node graph node_graph = generateNodeGraph(dropped_df) # calculate run time approx_run_time = None if earliest_date is not None and latest_date is not None: approx_run_time = getRunTime(earliest_date, latest_date) # calculate estimated count and received count dropped_df = calcTotals(approx_run_time, dropped_df) # count expected and dropped messages dropped_df = countDropped(dropped_df, node_graph) # prepare output data_dict = { 'dropped': dropped_df, 'latency': latency_df, 'node_graph': node_graph, 'start': earliest_date, 'end': latest_date, 'run_time': approx_run_time, } return data_dict def getRunTime(start, end): # calculate run time in seconds for experiment return (end - start).total_seconds() def calcTotals(run_time, dataframe): # calculate expected counts for each period mask = (dataframe['period'] != 0) period_non_zero = dataframe[mask] dataframe.loc[mask, 'expected_count'] = (run_time / period_non_zero['period']).apply(np.floor) return dataframe def generateNodeGraph(dataframe): connections = [] # for every node that has a defined period for node in dataframe.node: # assume node has sub nodes by default sub_node_exists = True # search for sub nodes of current node, assume node name is topic name current_node = node # current top-level node of fork fork_topics = [] sub_topics = [] in_fork = False while sub_node_exists: if(len(fork_topics) != 0 and not in_fork): # fork topic exists current_node = fork_topics.pop(0) in_fork = True if(len(sub_topics) != 0): # sub topics still exist current_node = sub_topics.pop(0) sub_node_df = dataframe.loc[ ((dataframe.topic == current_node) & (dataframe.expected_count == 0))] if not sub_node_df.empty: # node has sub node(s) if(sub_node_df.shape[0] > 1): # node has more than one sub node for fork in sub_node_df.node: if fork not in fork_topics: fork_topics.append(fork) for sub_node in sub_node_df.node: # add to list of tuples connections.append((current_node, sub_node)) if not dataframe.loc[dataframe.topic == sub_node].empty: if sub_node not in sub_topics: sub_topics.append(sub_node) else: # no sub nodes if(in_fork): in_fork = False continue sub_node_exists = False else: # no sub nodes if(in_fork): in_fork = False continue sub_node_exists = False # generate DAG from list of tuples graph = nx.DiGraph() graph.add_edges_from(connections) return graph def countDropped(dataframe, node_graph): mask = (dataframe['expected_count'] != 0) expected_non_zero = dataframe[mask] # for every node that has a defined period for node in expected_non_zero.node: # assume node has sub nodes by default sub_node_exists = True # search for sub nodes of current node, assume node name is topic name current_node = node # current top-level node of fork fork_topics = [] sub_topics = [] in_fork = False # pred = len(node_graph.pred[node]) # if(pred > 0): # TODO(flynneva): figure out a way to trace up the node graph # to determine if a fusion node reduces the total expected # count = expected_non_zero.expected_count.sum() # expected = count - dataframe.loc[( # (dataframe.node == node) & # (dataframe.topic == '')), # 'expected_count'].values[0] # subtract front lidar expected count due to fusion node # TODO(flynneva): figure out a better way to handle fusion nodes # expected -= dataframe.loc[( # (dataframe.node == 'FrontLidarDriver') & # (dataframe.topic == '')), # 'expected_count'].values[0] # else: # calculate dropped for current node expected = dataframe.loc[( (dataframe.node == node) & (dataframe.topic == '')), 'expected_count'].values[0] count = dataframe.loc[( (dataframe.node == current_node) & (dataframe.topic == '')), 'count'].values[0] dataframe.loc[( (dataframe.node == current_node) & (dataframe.topic == '')), 'dropped'] = abs(expected - count) while sub_node_exists: if(len(fork_topics) != 0 and not in_fork): # fork topic exists current_node = fork_topics.pop(0) in_fork = True if(len(sub_topics) != 0): # sub topics still exist current_node = sub_topics.pop(0) sub_node_df = dataframe.loc[ ((dataframe.topic == current_node) & (dataframe.expected_count == 0))] if not sub_node_df.empty: # node has sub node(s) if(sub_node_df.shape[0] > 1): # node has more than one sub node for fork in sub_node_df.node: if fork not in fork_topics: fork_topics.append(fork) for sub_node in sub_node_df.node: dataframe.loc[( (dataframe.node == sub_node) & (dataframe.topic == current_node)), 'expected_count'] = expected count = dataframe.loc[( (dataframe.node == sub_node) & (dataframe.topic == current_node)), 'count'].values[0] dataframe.loc[( (dataframe.node == sub_node) & (dataframe.topic == current_node)), 'dropped'] = abs(expected - count) if not dataframe.loc[dataframe.topic == sub_node].empty: if sub_node not in sub_topics: sub_topics.append(sub_node) else: # no sub nodes if(in_fork): in_fork = False continue sub_node_exists = False else: # no sub nodes if(in_fork): in_fork = False continue sub_node_exists = False return dataframe Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/test/dropped_messages.py"},{"location":"Files/dropped__messages_8py/#autoware_reference_systemtestdropped_messagespy","text":"","title":"autoware_reference_system/test/dropped_messages.py"},{"location":"Files/dropped__messages_8py/#namespaces","text":"Name dropped_messages","title":"Namespaces"},{"location":"Files/dropped__messages_8py/#source-code","text":"# Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import os import random from bokeh.io import output_file # from bokeh.layouts import layout from bokeh.models import ColumnDataSource from bokeh.models import DatetimeTickFormatter from bokeh.models.ranges import FactorRange from bokeh.models.tools import HoverTool from bokeh.models.widgets.markups import Div from bokeh.models.widgets.tables import DataTable, TableColumn from bokeh.palettes import cividis from bokeh.plotting import figure from bokeh.transform import factor_cmap import networkx as nx import numpy as np import pandas as pd from trace_utils import initDataModel from utils import getDirPath def summary(path, duration, size): fname = path + 'dropped_messages_and_latency_summary_' + duration + 's' print('Output report to ' + fname + '.html') output_file( filename=fname + '.html', title='Dropped Messages and Latency Summary Report ' + duration + 's') data_dict = {} for fname in os.listdir(path): fpath = path + fname # load tracing data data_model = initDataModel(fpath) wd = getDirPath(fpath) tmp_name = wd.find('_rmw') exe = fname[0:tmp_name] rmw = fname[tmp_name + 1:-(len(duration) + 2)] try: data_dict[exe] except KeyError: data_dict[exe] = {} try: data_dict[exe][rmw] except KeyError: data_dict[exe][rmw] = {} data_dict[exe][rmw] = parseData(data_model) x = [] for exe in data_dict: for rmw in data_dict[exe]: x.append((exe, rmw)) # print(data_dict[exe][rmw]['dropped']) def individual(data_model, size): data_dict = parseData(data_model) dropped_df = data_dict['dropped'] latency_df = data_dict['latency'] run_time = data_dict['run_time'] y = list(zip(dropped_df.node, dropped_df.topic)) latency_source = ColumnDataSource(latency_df) dropped_source = ColumnDataSource(dropped_df) dropped_source.data['y'] = y # use this for axis of figure ~0.25 of buffer max_dropped = max(dropped_df['dropped']) + 0.25 # initialize figure dropped_fig = figure( title='Dropped Messages Summary ({:.2f} s) [UNDER DEVELOPMENT]'.format(float(run_time)), y_axis_label='Callback by Node and Topic Name', x_axis_label='Dropped Messages', y_range=FactorRange(*y), x_range=(0, max_dropped), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) # add horizontal bar to figure dropped_fig.hbar( y='y', right='dropped', width=0.1, source=dropped_source, fill_color=factor_cmap( 'y', palette=cividis(dropped_df['topic'].shape[0]), factors=list(dropped_df['topic'].values.tolist()), start=1, end=2) ) dropped_fig.yaxis.major_label_orientation = 'horizontal' dropped_fig.yaxis.subgroup_label_orientation = 'horizontal' dropped_fig.yaxis.group_label_orientation = 'horizontal' # add hover tool hover = HoverTool() hover.tooltips = [ ('Callback (Node and Topic)', '@node @topic'), ('Dropped', '@dropped'), ('Expected', '@expected_count'), ('Received', '@count') ] dropped_fig.add_tools(hover) # add dropped messages table dropped_summary = dropped_df.describe().T.reset_index() columns = [TableColumn(field=col, title=col) for col in dropped_summary] dropped_table_title = Div( text='<b>Dropped Messages Summary Table [UNDER DEVELOPMENT]</b>', width=1000, height=10 ) dropped_table = [ dropped_table_title, DataTable( columns=columns, source=ColumnDataSource(dropped_summary), margin=(10, 10, 10, 10), height=150, width=size)] # add latency plot latency_fig = figure( title='Latency From Front Lidar to Collision Estimator [UNDER DEVELOPMENT]', x_axis_label='Time', y_axis_label='Latency to Object Collision Estimator (ms)', plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) latency_fig.line( x='timestamp', y='latency', source=latency_source, line_width=2 ) latency_fig.xaxis[0].formatter = DatetimeTickFormatter(seconds=['%Ss']) # add latency table latency_summary = latency_df.describe().T.reset_index() columns = [TableColumn(field=col, title=col) for col in latency_summary] latency_table_title = Div( text='<b>Latency Summary Table</b>', width=1000, height=10 ) latency_table = [ latency_table_title, DataTable( columns=columns, source=ColumnDataSource(latency_summary), margin=(10, 10, 10, 10), height=75, width=size)] return [ [dropped_table], [dropped_fig], [latency_table], [latency_fig] ] def parseData(data_model): callback_symbols = data_model.get_callback_symbols() colors = [] # Adds random colors for each callback color_i = 0 earliest_date = None latest_date = None dropped_data = [] front_lidar_data = pd.DataFrame() object_collision_data = pd.DataFrame() for obj, symbol in callback_symbols.items(): callback_df = data_model.get_callback_durations(obj) # get node information and filter out internal subscriptions owner_info = data_model.get_callback_owner_info(obj) if owner_info is not None: if '/parameter_events' in owner_info: continue period = 0.0 if 'period' in owner_info: # assume in milliseconds so convert to seconds period = float(owner_info[ owner_info.find('period: ') + len('period: '):owner_info.rfind(' ')]) / 1000 if 'FrontLidarDriver' in owner_info and 'Timer' in owner_info: front_lidar_data = callback_df if 'ObjectCollisionEstimator' in owner_info: object_collision_data = callback_df # add color to list if needed if(len(colors) <= color_i): colors.append('#%06X' % random.randint(0, 256**3-1)) # get human readable name of callback substr = 'node: ' index = str.find(owner_info, substr) if index >= 0: index += len(substr) node = owner_info[index:(str.find(owner_info, ','))] substr = 'topic: /' index = str.find(owner_info, substr) if index >= 0: index += len(substr) topic = owner_info[index:] else: topic = '' # get first and last timestamp of data thefirstdate = callback_df.loc[:, 'timestamp'].iloc[0] if earliest_date is None: earliest_date = thefirstdate elif earliest_date is not None and thefirstdate <= earliest_date: earliest_date = thefirstdate thelastdate = callback_df.loc[:, 'timestamp'].iloc[len(callback_df)-1] if latest_date is None: latest_date = thelastdate elif latest_date is not None and thelastdate >= latest_date: latest_date = thelastdate # add name of callback and count to list dropped_data.append( [str(node), str(topic), float(len(callback_df)), period, 0.0, 0.0, colors[color_i]]) color_i += 1 front_lidar_data = front_lidar_data.reset_index(drop=True) object_collision_data = object_collision_data.reset_index(drop=True) # ensure dataframes are same length for latency calc, drop extra lidar frames extra = len(front_lidar_data) - len(object_collision_data) if(extra > 0): front_lidar_data.drop(front_lidar_data.tail(extra).index, inplace=True) latency = object_collision_data['timestamp'] - front_lidar_data['timestamp'] dropped_df = pd.DataFrame( dropped_data, columns=['node', 'topic', 'count', 'period', 'dropped', 'expected_count', 'color']) latency_df = pd.DataFrame( {'index': range(0, len(latency)), 'latency': latency, 'timestamp': front_lidar_data['timestamp']}) # sort values by node and topic dropped_df = dropped_df.sort_values(by=['node', 'topic']) # generate node graph node_graph = generateNodeGraph(dropped_df) # calculate run time approx_run_time = None if earliest_date is not None and latest_date is not None: approx_run_time = getRunTime(earliest_date, latest_date) # calculate estimated count and received count dropped_df = calcTotals(approx_run_time, dropped_df) # count expected and dropped messages dropped_df = countDropped(dropped_df, node_graph) # prepare output data_dict = { 'dropped': dropped_df, 'latency': latency_df, 'node_graph': node_graph, 'start': earliest_date, 'end': latest_date, 'run_time': approx_run_time, } return data_dict def getRunTime(start, end): # calculate run time in seconds for experiment return (end - start).total_seconds() def calcTotals(run_time, dataframe): # calculate expected counts for each period mask = (dataframe['period'] != 0) period_non_zero = dataframe[mask] dataframe.loc[mask, 'expected_count'] = (run_time / period_non_zero['period']).apply(np.floor) return dataframe def generateNodeGraph(dataframe): connections = [] # for every node that has a defined period for node in dataframe.node: # assume node has sub nodes by default sub_node_exists = True # search for sub nodes of current node, assume node name is topic name current_node = node # current top-level node of fork fork_topics = [] sub_topics = [] in_fork = False while sub_node_exists: if(len(fork_topics) != 0 and not in_fork): # fork topic exists current_node = fork_topics.pop(0) in_fork = True if(len(sub_topics) != 0): # sub topics still exist current_node = sub_topics.pop(0) sub_node_df = dataframe.loc[ ((dataframe.topic == current_node) & (dataframe.expected_count == 0))] if not sub_node_df.empty: # node has sub node(s) if(sub_node_df.shape[0] > 1): # node has more than one sub node for fork in sub_node_df.node: if fork not in fork_topics: fork_topics.append(fork) for sub_node in sub_node_df.node: # add to list of tuples connections.append((current_node, sub_node)) if not dataframe.loc[dataframe.topic == sub_node].empty: if sub_node not in sub_topics: sub_topics.append(sub_node) else: # no sub nodes if(in_fork): in_fork = False continue sub_node_exists = False else: # no sub nodes if(in_fork): in_fork = False continue sub_node_exists = False # generate DAG from list of tuples graph = nx.DiGraph() graph.add_edges_from(connections) return graph def countDropped(dataframe, node_graph): mask = (dataframe['expected_count'] != 0) expected_non_zero = dataframe[mask] # for every node that has a defined period for node in expected_non_zero.node: # assume node has sub nodes by default sub_node_exists = True # search for sub nodes of current node, assume node name is topic name current_node = node # current top-level node of fork fork_topics = [] sub_topics = [] in_fork = False # pred = len(node_graph.pred[node]) # if(pred > 0): # TODO(flynneva): figure out a way to trace up the node graph # to determine if a fusion node reduces the total expected # count = expected_non_zero.expected_count.sum() # expected = count - dataframe.loc[( # (dataframe.node == node) & # (dataframe.topic == '')), # 'expected_count'].values[0] # subtract front lidar expected count due to fusion node # TODO(flynneva): figure out a better way to handle fusion nodes # expected -= dataframe.loc[( # (dataframe.node == 'FrontLidarDriver') & # (dataframe.topic == '')), # 'expected_count'].values[0] # else: # calculate dropped for current node expected = dataframe.loc[( (dataframe.node == node) & (dataframe.topic == '')), 'expected_count'].values[0] count = dataframe.loc[( (dataframe.node == current_node) & (dataframe.topic == '')), 'count'].values[0] dataframe.loc[( (dataframe.node == current_node) & (dataframe.topic == '')), 'dropped'] = abs(expected - count) while sub_node_exists: if(len(fork_topics) != 0 and not in_fork): # fork topic exists current_node = fork_topics.pop(0) in_fork = True if(len(sub_topics) != 0): # sub topics still exist current_node = sub_topics.pop(0) sub_node_df = dataframe.loc[ ((dataframe.topic == current_node) & (dataframe.expected_count == 0))] if not sub_node_df.empty: # node has sub node(s) if(sub_node_df.shape[0] > 1): # node has more than one sub node for fork in sub_node_df.node: if fork not in fork_topics: fork_topics.append(fork) for sub_node in sub_node_df.node: dataframe.loc[( (dataframe.node == sub_node) & (dataframe.topic == current_node)), 'expected_count'] = expected count = dataframe.loc[( (dataframe.node == sub_node) & (dataframe.topic == current_node)), 'count'].values[0] dataframe.loc[( (dataframe.node == sub_node) & (dataframe.topic == current_node)), 'dropped'] = abs(expected - count) if not dataframe.loc[dataframe.topic == sub_node].empty: if sub_node not in sub_topics: sub_topics.append(sub_node) else: # no sub nodes if(in_fork): in_fork = False continue sub_node_exists = False else: # no sub nodes if(in_fork): in_fork = False continue sub_node_exists = False return dataframe Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/errors_8py/","text":"autoware_reference_system/test/errors.py Namespaces Name errors Classes Name class errors::UnsupportedTraceTypeError Source code # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. class UnsupportedTraceTypeError(Exception): pass Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/test/errors.py"},{"location":"Files/errors_8py/#autoware_reference_systemtesterrorspy","text":"","title":"autoware_reference_system/test/errors.py"},{"location":"Files/errors_8py/#namespaces","text":"Name errors","title":"Namespaces"},{"location":"Files/errors_8py/#classes","text":"Name class errors::UnsupportedTraceTypeError","title":"Classes"},{"location":"Files/errors_8py/#source-code","text":"# Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. class UnsupportedTraceTypeError(Exception): pass Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/fusion_8hpp/","text":"reference_system/include/reference_system/nodes/rclcpp/fusion.hpp Namespaces Name nodes nodes::rclcpp_system Classes Name class nodes::rclcpp_system::Fusion Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__RCLCPP__FUSION_HPP_ #define REFERENCE_SYSTEM__NODES__RCLCPP__FUSION_HPP_ #include <chrono> #include <string> #include <utility> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/number_cruncher.hpp\" #include \"reference_system/sample_management.hpp\" #include \"reference_system/msg_types.hpp\" namespace nodes { namespace rclcpp_system { class Fusion : public rclcpp::Node { public: explicit Fusion(const FusionSettings & settings) : Node(settings.node_name), number_crunch_limit_(settings.number_crunch_limit) { subscriptions_[0].subscription = this->create_subscription<message_t>( settings.input_0, 1, [this](const message_t::SharedPtr msg) {input_callback(0U, msg);}); subscriptions_[1].subscription = this->create_subscription<message_t>( settings.input_1, 1, [this](const message_t::SharedPtr msg) {input_callback(1U, msg);}); publisher_ = this->create_publisher<message_t>(settings.output_topic, 1); } private: void input_callback( const uint64_t input_number, const message_t::SharedPtr input_message) { uint64_t timestamp = now_as_int(); subscriptions_[input_number].cache = input_message; // only process and publish when we can perform an actual fusion, this means // we have received a sample from each subscription if (!subscriptions_[0].cache || !subscriptions_[1].cache) { return; } auto number_cruncher_result = number_cruncher(number_crunch_limit_); auto output_message = publisher_->borrow_loaned_message(); uint32_t missed_samples = get_missed_samples_and_update_seq_nr( subscriptions_[0].cache, subscriptions_[0].sequence_number) + get_missed_samples_and_update_seq_nr( subscriptions_[1].cache, subscriptions_[1].sequence_number); output_message.get().size = 0; merge_history_into_sample(output_message.get(), subscriptions_[0].cache); merge_history_into_sample(output_message.get(), subscriptions_[1].cache); set_sample( this->get_name(), sequence_number_++, missed_samples, timestamp, output_message.get()); output_message.get().data[0] = number_cruncher_result; publisher_->publish(std::move(output_message)); subscriptions_[0].cache.reset(); subscriptions_[1].cache.reset(); } private: struct subscription_t { rclcpp::Subscription<message_t>::SharedPtr subscription; uint32_t sequence_number = 0; message_t::SharedPtr cache; }; rclcpp::Publisher<message_t>::SharedPtr publisher_; subscription_t subscriptions_[2]; uint64_t number_crunch_limit_; uint32_t sequence_number_ = 0; }; } // namespace rclcpp_system } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__RCLCPP__FUSION_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_system/include/reference_system/nodes/rclcpp/fusion.hpp"},{"location":"Files/fusion_8hpp/#reference_systemincludereference_systemnodesrclcppfusionhpp","text":"","title":"reference_system/include/reference_system/nodes/rclcpp/fusion.hpp"},{"location":"Files/fusion_8hpp/#namespaces","text":"Name nodes nodes::rclcpp_system","title":"Namespaces"},{"location":"Files/fusion_8hpp/#classes","text":"Name class nodes::rclcpp_system::Fusion","title":"Classes"},{"location":"Files/fusion_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__RCLCPP__FUSION_HPP_ #define REFERENCE_SYSTEM__NODES__RCLCPP__FUSION_HPP_ #include <chrono> #include <string> #include <utility> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/number_cruncher.hpp\" #include \"reference_system/sample_management.hpp\" #include \"reference_system/msg_types.hpp\" namespace nodes { namespace rclcpp_system { class Fusion : public rclcpp::Node { public: explicit Fusion(const FusionSettings & settings) : Node(settings.node_name), number_crunch_limit_(settings.number_crunch_limit) { subscriptions_[0].subscription = this->create_subscription<message_t>( settings.input_0, 1, [this](const message_t::SharedPtr msg) {input_callback(0U, msg);}); subscriptions_[1].subscription = this->create_subscription<message_t>( settings.input_1, 1, [this](const message_t::SharedPtr msg) {input_callback(1U, msg);}); publisher_ = this->create_publisher<message_t>(settings.output_topic, 1); } private: void input_callback( const uint64_t input_number, const message_t::SharedPtr input_message) { uint64_t timestamp = now_as_int(); subscriptions_[input_number].cache = input_message; // only process and publish when we can perform an actual fusion, this means // we have received a sample from each subscription if (!subscriptions_[0].cache || !subscriptions_[1].cache) { return; } auto number_cruncher_result = number_cruncher(number_crunch_limit_); auto output_message = publisher_->borrow_loaned_message(); uint32_t missed_samples = get_missed_samples_and_update_seq_nr( subscriptions_[0].cache, subscriptions_[0].sequence_number) + get_missed_samples_and_update_seq_nr( subscriptions_[1].cache, subscriptions_[1].sequence_number); output_message.get().size = 0; merge_history_into_sample(output_message.get(), subscriptions_[0].cache); merge_history_into_sample(output_message.get(), subscriptions_[1].cache); set_sample( this->get_name(), sequence_number_++, missed_samples, timestamp, output_message.get()); output_message.get().data[0] = number_cruncher_result; publisher_->publish(std::move(output_message)); subscriptions_[0].cache.reset(); subscriptions_[1].cache.reset(); } private: struct subscription_t { rclcpp::Subscription<message_t>::SharedPtr subscription; uint32_t sequence_number = 0; message_t::SharedPtr cache; }; rclcpp::Publisher<message_t>::SharedPtr publisher_; subscription_t subscriptions_[2]; uint64_t number_crunch_limit_; uint32_t sequence_number_ = 0; }; } // namespace rclcpp_system } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__RCLCPP__FUSION_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/generate__callback__traces_8py/","text":"autoware_reference_system/test/generate_callback_traces.py Namespaces Name generate_callback_traces Classes Name class generate_callback_traces::TestGenerateTracesAutowareReferenceSystem Source code # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import time import unittest from launch import LaunchDescription from launch.actions import SetEnvironmentVariable from launch_ros.actions import Node import launch_testing import launch_testing.actions from tracetools_launch.action import Trace from tracetools_trace.tools.names import DEFAULT_EVENTS_ROS # Generate traces for specified executables and RMWs # this file has @variables@ that are meant to be automatically replaced # by values using the `configure_file` CMake function during the build RUNTIME = int('@RUNTIME@') def generate_test_description(): # replaced with cmake `configure_file` function rmw_impl = '@RMW_IMPLEMENTATION@' test_exe = '@TEST_EXECUTABLE@' test_exe_name = '@TEST_EXECUTABLE_NAME@' trace_type = '@TRACE_TYPE@' launch_description = LaunchDescription() # see https://github.com/ros2/launch/issues/417 # have to use `SetEnvironmentVariable` to set env vars in launch description envvar_rcutils_action = SetEnvironmentVariable( 'RCUTILS_CONSOLE_OUTPUT_FORMAT', '[{severity}] [{name}]: {message}') envvar_rmw_action = SetEnvironmentVariable( 'RMW_IMPLEMENTATION', rmw_impl) envvar_rclassert_rmw_action = SetEnvironmentVariable( 'RCL_ASSERT_RMW_ID_MATCHES', rmw_impl) node_under_test = Node( package='autoware_reference_system', executable=test_exe, output='screen' ) trace_action = Trace( session_name=trace_type + '_' + test_exe_name + '_' + str(RUNTIME) + 's', events_ust=DEFAULT_EVENTS_ROS, events_kernel=[], ) launch_description.add_action(envvar_rcutils_action) launch_description.add_action(envvar_rclassert_rmw_action) launch_description.add_action(envvar_rmw_action) launch_description.add_action(trace_action) launch_description.add_action(node_under_test) launch_description.add_action( launch_testing.actions.ReadyToTest() ) return launch_description, locals() class TestGenerateTracesAutowareReferenceSystem(unittest.TestCase): def test_generate_traces(self): global RUNTIME start_time = time.time() end_time = start_time + RUNTIME while time.time() < end_time: print('generating traces...') time.sleep(0.25) # seconds self.assertTrue(True) Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/test/generate_callback_traces.py"},{"location":"Files/generate__callback__traces_8py/#autoware_reference_systemtestgenerate_callback_tracespy","text":"","title":"autoware_reference_system/test/generate_callback_traces.py"},{"location":"Files/generate__callback__traces_8py/#namespaces","text":"Name generate_callback_traces","title":"Namespaces"},{"location":"Files/generate__callback__traces_8py/#classes","text":"Name class generate_callback_traces::TestGenerateTracesAutowareReferenceSystem","title":"Classes"},{"location":"Files/generate__callback__traces_8py/#source-code","text":"# Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import time import unittest from launch import LaunchDescription from launch.actions import SetEnvironmentVariable from launch_ros.actions import Node import launch_testing import launch_testing.actions from tracetools_launch.action import Trace from tracetools_trace.tools.names import DEFAULT_EVENTS_ROS # Generate traces for specified executables and RMWs # this file has @variables@ that are meant to be automatically replaced # by values using the `configure_file` CMake function during the build RUNTIME = int('@RUNTIME@') def generate_test_description(): # replaced with cmake `configure_file` function rmw_impl = '@RMW_IMPLEMENTATION@' test_exe = '@TEST_EXECUTABLE@' test_exe_name = '@TEST_EXECUTABLE_NAME@' trace_type = '@TRACE_TYPE@' launch_description = LaunchDescription() # see https://github.com/ros2/launch/issues/417 # have to use `SetEnvironmentVariable` to set env vars in launch description envvar_rcutils_action = SetEnvironmentVariable( 'RCUTILS_CONSOLE_OUTPUT_FORMAT', '[{severity}] [{name}]: {message}') envvar_rmw_action = SetEnvironmentVariable( 'RMW_IMPLEMENTATION', rmw_impl) envvar_rclassert_rmw_action = SetEnvironmentVariable( 'RCL_ASSERT_RMW_ID_MATCHES', rmw_impl) node_under_test = Node( package='autoware_reference_system', executable=test_exe, output='screen' ) trace_action = Trace( session_name=trace_type + '_' + test_exe_name + '_' + str(RUNTIME) + 's', events_ust=DEFAULT_EVENTS_ROS, events_kernel=[], ) launch_description.add_action(envvar_rcutils_action) launch_description.add_action(envvar_rclassert_rmw_action) launch_description.add_action(envvar_rmw_action) launch_description.add_action(trace_action) launch_description.add_action(node_under_test) launch_description.add_action( launch_testing.actions.ReadyToTest() ) return launch_description, locals() class TestGenerateTracesAutowareReferenceSystem(unittest.TestCase): def test_generate_traces(self): global RUNTIME start_time = time.time() end_time = start_time + RUNTIME while time.time() < end_time: print('generating traces...') time.sleep(0.25) # seconds self.assertTrue(True) Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/generate__reports_8py/","text":"autoware_reference_system/test/generate_reports.py Namespaces Name generate_reports Source code # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import sys from bokeh.io import output_file from bokeh.layouts import layout from bokeh.plotting import save import callback_duration from constants import SIZE_SUBPLOT, SIZE_SUMMARY from constants import TRACE_CALLBACK, TRACE_MEMORY, TRACE_STD import dropped_messages import memory_usage # import std_latency from trace_utils import initDataModel from utils import checkDirPath, getDirPath, getFileName, getTraceType def memory_report(wd, filename): fname = wd + filename + '_memory_and_cpu_usage_report' output_file( filename=fname + '.html', title='Memory Usage Report') print('Output report to ' + fname + '.html') mem_individual = memory_usage.individual(wd + filename + '.txt', size=SIZE_SUMMARY) report = layout([*mem_individual]) save(report) # export_png(report, filename=fname + '.png') def std_report(wd, filename): print('std report called') # dirPath = getDirPath(path) # std_summary, test_name = std_latency.individual(dirPath + 'streams.log', size=SIZE_SUMMARY) # fname = dirPath + test_name + '_latency_and_dropped_messages_report' # output_file( # filename=fname + '.html', # title='Latency and Dropped Messages Report (' + test_name + ')') # print('Output report to ' + fname + '.html') # report = layout([[*std_summary]]) # save(report) def callback_report(wd, filename, ros2_data_model): fname = wd + filename + '_callback_duration_report' output_file( filename=fname + '.html', title='Callback Duration Report') print('Output report to ' + fname + '.html') duration_summary = callback_duration.summary( data_model=ros2_data_model, size=SIZE_SUMMARY) duration_individual = callback_duration.individual( data_model=ros2_data_model, size=SIZE_SUBPLOT) report = layout([[duration_summary], *duration_individual]) save(report) # export_png(report, filename=fname + '.png') def dropped_messages_report(wd, filename, ros2_data_model): fname = wd + filename + '_tracing_latency_and_dropped_messages_report' output_file( filename=fname + '.html', title='ROS 2 Tracing Latency and Dropped Messages Report') print('Output report to ' + fname + '.html') dropped_msgs = dropped_messages.individual( data_model=ros2_data_model, size=SIZE_SUMMARY) report = layout([[dropped_msgs]]) save(report) # export_png(report, filename=fname + '.png') def generate_reports(wd, fname, trace_type, ros2_data_model): if(trace_type == TRACE_CALLBACK): callback_report(wd, fname, ros2_data_model) dropped_messages_report(wd, fname, ros2_data_model) elif(trace_type == TRACE_MEMORY): memory_report(wd, fname) elif(trace_type == TRACE_STD): std_report(wd, fname) if __name__ == '__main__': path = 'path' if(len(sys.argv) >= 2): path = sys.argv[1] else: path = '/home/ubuntu/.ros/tracing/profile' # remove filename from path wd = getDirPath(path) # confirm directory exists checkDirPath(wd) # get filename fname = getFileName(path) # get trace type based on working directory path trace_type = getTraceType(wd) if(trace_type == TRACE_CALLBACK): ros2_data_model = initDataModel(path) elif(trace_type == TRACE_MEMORY): ros2_data_model = None elif(trace_type == TRACE_STD): ros2_data_model = None generate_reports(wd, fname, trace_type, ros2_data_model) Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/test/generate_reports.py"},{"location":"Files/generate__reports_8py/#autoware_reference_systemtestgenerate_reportspy","text":"","title":"autoware_reference_system/test/generate_reports.py"},{"location":"Files/generate__reports_8py/#namespaces","text":"Name generate_reports","title":"Namespaces"},{"location":"Files/generate__reports_8py/#source-code","text":"# Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import sys from bokeh.io import output_file from bokeh.layouts import layout from bokeh.plotting import save import callback_duration from constants import SIZE_SUBPLOT, SIZE_SUMMARY from constants import TRACE_CALLBACK, TRACE_MEMORY, TRACE_STD import dropped_messages import memory_usage # import std_latency from trace_utils import initDataModel from utils import checkDirPath, getDirPath, getFileName, getTraceType def memory_report(wd, filename): fname = wd + filename + '_memory_and_cpu_usage_report' output_file( filename=fname + '.html', title='Memory Usage Report') print('Output report to ' + fname + '.html') mem_individual = memory_usage.individual(wd + filename + '.txt', size=SIZE_SUMMARY) report = layout([*mem_individual]) save(report) # export_png(report, filename=fname + '.png') def std_report(wd, filename): print('std report called') # dirPath = getDirPath(path) # std_summary, test_name = std_latency.individual(dirPath + 'streams.log', size=SIZE_SUMMARY) # fname = dirPath + test_name + '_latency_and_dropped_messages_report' # output_file( # filename=fname + '.html', # title='Latency and Dropped Messages Report (' + test_name + ')') # print('Output report to ' + fname + '.html') # report = layout([[*std_summary]]) # save(report) def callback_report(wd, filename, ros2_data_model): fname = wd + filename + '_callback_duration_report' output_file( filename=fname + '.html', title='Callback Duration Report') print('Output report to ' + fname + '.html') duration_summary = callback_duration.summary( data_model=ros2_data_model, size=SIZE_SUMMARY) duration_individual = callback_duration.individual( data_model=ros2_data_model, size=SIZE_SUBPLOT) report = layout([[duration_summary], *duration_individual]) save(report) # export_png(report, filename=fname + '.png') def dropped_messages_report(wd, filename, ros2_data_model): fname = wd + filename + '_tracing_latency_and_dropped_messages_report' output_file( filename=fname + '.html', title='ROS 2 Tracing Latency and Dropped Messages Report') print('Output report to ' + fname + '.html') dropped_msgs = dropped_messages.individual( data_model=ros2_data_model, size=SIZE_SUMMARY) report = layout([[dropped_msgs]]) save(report) # export_png(report, filename=fname + '.png') def generate_reports(wd, fname, trace_type, ros2_data_model): if(trace_type == TRACE_CALLBACK): callback_report(wd, fname, ros2_data_model) dropped_messages_report(wd, fname, ros2_data_model) elif(trace_type == TRACE_MEMORY): memory_report(wd, fname) elif(trace_type == TRACE_STD): std_report(wd, fname) if __name__ == '__main__': path = 'path' if(len(sys.argv) >= 2): path = sys.argv[1] else: path = '/home/ubuntu/.ros/tracing/profile' # remove filename from path wd = getDirPath(path) # confirm directory exists checkDirPath(wd) # get filename fname = getFileName(path) # get trace type based on working directory path trace_type = getTraceType(wd) if(trace_type == TRACE_CALLBACK): ros2_data_model = initDataModel(path) elif(trace_type == TRACE_MEMORY): ros2_data_model = None elif(trace_type == TRACE_STD): ros2_data_model = None generate_reports(wd, fname, trace_type, ros2_data_model) Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/generate__std__traces_8py/","text":"autoware_reference_system/test/generate_std_traces.py Namespaces Name generate_std_traces Classes Name class generate_std_traces::TestGenerateTracesAutowareReferenceSystem Source code # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import time import unittest from launch import LaunchDescription from launch.actions import SetEnvironmentVariable from launch_ros.actions import Node import launch_testing import launch_testing.actions # Generate traces for specified executables and RMWs # this file has @variables@ that are meant to be automatically replaced # by values using the `configure_file` CMake function during the build RUNTIME = int('@RUNTIME@') def generate_test_description(): # replaced with cmake `configure_file` function rmw_impl = '@RMW_IMPLEMENTATION@' test_exe = '@TEST_EXECUTABLE@' test_exe_name = '@TEST_EXECUTABLE_NAME@' trace_type = '@TRACE_TYPE@' launch_description = LaunchDescription() # see https://github.com/ros2/launch/issues/417 # have to use `SetEnvironmentVariable` to set env vars in launch description envvar_rcutils_action = SetEnvironmentVariable( 'RCUTILS_CONSOLE_OUTPUT_FORMAT', '[{severity}] [{name}]: {message}') envvar_rmw_action = SetEnvironmentVariable( 'RMW_IMPLEMENTATION', rmw_impl) envvar_rclassert_rmw_action = SetEnvironmentVariable( 'RCL_ASSERT_RMW_ID_MATCHES', rmw_impl) node_under_test = Node( package='autoware_reference_system', executable=test_exe, output='screen' ) launch_description.add_action(envvar_rcutils_action) launch_description.add_action(envvar_rclassert_rmw_action) launch_description.add_action(envvar_rmw_action) launch_description.add_action(node_under_test) launch_description.add_action( launch_testing.actions.ReadyToTest() ) return launch_description, locals() class TestGenerateTracesAutowareReferenceSystem(unittest.TestCase): def test_generate_traces(self): global RUNTIME start_time = time.time() end_time = start_time + RUNTIME while time.time() < end_time: print('generating traces...') time.sleep(0.25) # seconds self.assertTrue(True) Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/test/generate_std_traces.py"},{"location":"Files/generate__std__traces_8py/#autoware_reference_systemtestgenerate_std_tracespy","text":"","title":"autoware_reference_system/test/generate_std_traces.py"},{"location":"Files/generate__std__traces_8py/#namespaces","text":"Name generate_std_traces","title":"Namespaces"},{"location":"Files/generate__std__traces_8py/#classes","text":"Name class generate_std_traces::TestGenerateTracesAutowareReferenceSystem","title":"Classes"},{"location":"Files/generate__std__traces_8py/#source-code","text":"# Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import time import unittest from launch import LaunchDescription from launch.actions import SetEnvironmentVariable from launch_ros.actions import Node import launch_testing import launch_testing.actions # Generate traces for specified executables and RMWs # this file has @variables@ that are meant to be automatically replaced # by values using the `configure_file` CMake function during the build RUNTIME = int('@RUNTIME@') def generate_test_description(): # replaced with cmake `configure_file` function rmw_impl = '@RMW_IMPLEMENTATION@' test_exe = '@TEST_EXECUTABLE@' test_exe_name = '@TEST_EXECUTABLE_NAME@' trace_type = '@TRACE_TYPE@' launch_description = LaunchDescription() # see https://github.com/ros2/launch/issues/417 # have to use `SetEnvironmentVariable` to set env vars in launch description envvar_rcutils_action = SetEnvironmentVariable( 'RCUTILS_CONSOLE_OUTPUT_FORMAT', '[{severity}] [{name}]: {message}') envvar_rmw_action = SetEnvironmentVariable( 'RMW_IMPLEMENTATION', rmw_impl) envvar_rclassert_rmw_action = SetEnvironmentVariable( 'RCL_ASSERT_RMW_ID_MATCHES', rmw_impl) node_under_test = Node( package='autoware_reference_system', executable=test_exe, output='screen' ) launch_description.add_action(envvar_rcutils_action) launch_description.add_action(envvar_rclassert_rmw_action) launch_description.add_action(envvar_rmw_action) launch_description.add_action(node_under_test) launch_description.add_action( launch_testing.actions.ReadyToTest() ) return launch_description, locals() class TestGenerateTracesAutowareReferenceSystem(unittest.TestCase): def test_generate_traces(self): global RUNTIME start_time = time.time() end_time = start_time + RUNTIME while time.time() < end_time: print('generating traces...') time.sleep(0.25) # seconds self.assertTrue(True) Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/generate__summary__reports_8py/","text":"autoware_reference_system/test/generate_summary_reports.py Namespaces Name generate_summary_reports Source code # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import sys from bokeh.io import output_file from bokeh.layouts import layout from bokeh.plotting import save from constants import SIZE_SUMMARY from constants import TRACE_CALLBACK, TRACE_MEMORY, TRACE_STD import dropped_messages from errors import UnsupportedTraceTypeError import memory_usage import std_latency from utils import checkDirPath, getDirPath, getFileName, getTraceType def memory_summary_report(path, duration): fname = path + 'memory_and_cpu_usage_summary_report_' + duration + 's' output_file( filename=fname + '.html', title='Memory Usage Report') mem_summary = memory_usage.summary(path, duration=duration, size=SIZE_SUMMARY) print('Output report to ' + fname + '.html') report = layout([*mem_summary]) save(report) # export_png(report, filename=fname + '.png') def std_summary_report(path, duration): dirPath = getDirPath(path) fname = dirPath + 'executor_kpi_summary_report_' + duration + 's' output_file( filename=fname + '.html', title='Executor Key Performance Indicator (KPI) Report') print('Output report to ' + fname + '.html') std_summary = std_latency.summary( dirPath + 'streams.log', duration=duration, size=SIZE_SUMMARY) report = layout([*std_summary]) save(report) def dropped_summary_report(path, duration): fname = path + 'latency_and_dropped_msgs_summary_report_' + duration + 's' output_file( filename=fname + '.html', title='Latency and Dropped Message Summary Report') dropped_summary = dropped_messages.summary( path=path, size=SIZE_SUMMARY, duration=duration) report = layout([dropped_summary]) save(report) # export_png(report, filename=fname + '.png') def generate_summary_reports(path, duration): trace_type = getTraceType(path) if(trace_type == TRACE_CALLBACK): print('dropped summary report') # dropped_summary_report(path, duration) elif(trace_type == TRACE_MEMORY): print('memory summary report') memory_summary_report(path, duration) elif(trace_type == TRACE_STD): print('std latency summary report') std_summary_report(path, duration) else: raise UnsupportedTraceTypeError if __name__ == '__main__': if(len(sys.argv) >= 2): path = sys.argv[1] duration = sys.argv[2] else: path = '/home/ubuntu/.ros/tracing/profile' # remove filename from path wd = getDirPath(path) # confirm directory exists checkDirPath(wd) # get trace type, aka filename if path was given without a trailing `/` tracetype = getFileName(path) generate_summary_reports(wd + tracetype + '/', duration) Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/test/generate_summary_reports.py"},{"location":"Files/generate__summary__reports_8py/#autoware_reference_systemtestgenerate_summary_reportspy","text":"","title":"autoware_reference_system/test/generate_summary_reports.py"},{"location":"Files/generate__summary__reports_8py/#namespaces","text":"Name generate_summary_reports","title":"Namespaces"},{"location":"Files/generate__summary__reports_8py/#source-code","text":"# Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import sys from bokeh.io import output_file from bokeh.layouts import layout from bokeh.plotting import save from constants import SIZE_SUMMARY from constants import TRACE_CALLBACK, TRACE_MEMORY, TRACE_STD import dropped_messages from errors import UnsupportedTraceTypeError import memory_usage import std_latency from utils import checkDirPath, getDirPath, getFileName, getTraceType def memory_summary_report(path, duration): fname = path + 'memory_and_cpu_usage_summary_report_' + duration + 's' output_file( filename=fname + '.html', title='Memory Usage Report') mem_summary = memory_usage.summary(path, duration=duration, size=SIZE_SUMMARY) print('Output report to ' + fname + '.html') report = layout([*mem_summary]) save(report) # export_png(report, filename=fname + '.png') def std_summary_report(path, duration): dirPath = getDirPath(path) fname = dirPath + 'executor_kpi_summary_report_' + duration + 's' output_file( filename=fname + '.html', title='Executor Key Performance Indicator (KPI) Report') print('Output report to ' + fname + '.html') std_summary = std_latency.summary( dirPath + 'streams.log', duration=duration, size=SIZE_SUMMARY) report = layout([*std_summary]) save(report) def dropped_summary_report(path, duration): fname = path + 'latency_and_dropped_msgs_summary_report_' + duration + 's' output_file( filename=fname + '.html', title='Latency and Dropped Message Summary Report') dropped_summary = dropped_messages.summary( path=path, size=SIZE_SUMMARY, duration=duration) report = layout([dropped_summary]) save(report) # export_png(report, filename=fname + '.png') def generate_summary_reports(path, duration): trace_type = getTraceType(path) if(trace_type == TRACE_CALLBACK): print('dropped summary report') # dropped_summary_report(path, duration) elif(trace_type == TRACE_MEMORY): print('memory summary report') memory_summary_report(path, duration) elif(trace_type == TRACE_STD): print('std latency summary report') std_summary_report(path, duration) else: raise UnsupportedTraceTypeError if __name__ == '__main__': if(len(sys.argv) >= 2): path = sys.argv[1] duration = sys.argv[2] else: path = '/home/ubuntu/.ros/tracing/profile' # remove filename from path wd = getDirPath(path) # confirm directory exists checkDirPath(wd) # get trace type, aka filename if path was given without a trailing `/` tracetype = getFileName(path) generate_summary_reports(wd + tracetype + '/', duration) Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/gtest__main_8cpp/","text":"reference_system/test/gtest_main.cpp Functions Name int main (int argc, char * argv[]) Functions Documentation function main int main( int argc, char * argv[] ) Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include \"gtest/gtest.h\" #include <rclcpp/rclcpp.hpp> int main(int argc, char * argv[]) { ::testing::InitGoogleTest(&argc, argv); return RUN_ALL_TESTS(); } Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_system/test/gtest_main.cpp"},{"location":"Files/gtest__main_8cpp/#reference_systemtestgtest_maincpp","text":"","title":"reference_system/test/gtest_main.cpp"},{"location":"Files/gtest__main_8cpp/#functions","text":"Name int main (int argc, char * argv[])","title":"Functions"},{"location":"Files/gtest__main_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/gtest__main_8cpp/#function-main","text":"int main( int argc, char * argv[] )","title":"function main"},{"location":"Files/gtest__main_8cpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include \"gtest/gtest.h\" #include <rclcpp/rclcpp.hpp> int main(int argc, char * argv[]) { ::testing::InitGoogleTest(&argc, argv); return RUN_ALL_TESTS(); } Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/intersection_8hpp/","text":"reference_system/include/reference_system/nodes/rclcpp/intersection.hpp Namespaces Name nodes nodes::rclcpp_system Classes Name class nodes::rclcpp_system::Intersection Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__RCLCPP__INTERSECTION_HPP_ #define REFERENCE_SYSTEM__NODES__RCLCPP__INTERSECTION_HPP_ #include <cstdlib> #include <chrono> #include <memory> #include <string> #include <utility> #include <vector> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/number_cruncher.hpp\" #include \"reference_system/sample_management.hpp\" #include \"reference_system/msg_types.hpp\" namespace nodes { namespace rclcpp_system { class Intersection : public rclcpp::Node { public: explicit Intersection(const IntersectionSettings & settings) : Node(settings.node_name) { for (auto & connection : settings.connections) { rclcpp::SubscriptionOptionsWithAllocator<std::allocator<void>> options; rclcpp::CallbackGroup::SharedPtr callback_group = this->create_callback_group( rclcpp::CallbackGroupType::MutuallyExclusive); options.callback_group = callback_group; connections_.emplace_back( Connection{ this->create_publisher<message_t>(connection.output_topic, 1), this->create_subscription<message_t>( connection.input_topic, 1, [this, id = connections_.size()](const message_t::SharedPtr msg) { input_callback(msg, id); }, options), callback_group, connection.number_crunch_limit }); } } rclcpp::CallbackGroup::SharedPtr get_callback_group_of_subscription( const std::string & input_topic) { for (auto & connection : connections_) { if (input_topic == connection.subscription->get_topic_name()) { return connection.callback_group; } } RCLCPP_FATAL(get_logger(), \"Subscription for topic '%s' not found!\", input_topic.c_str()); std::exit(1); } private: void input_callback(const message_t::SharedPtr input_message, const uint64_t id) { uint64_t timestamp = now_as_int(); auto number_cruncher_result = number_cruncher(connections_[id].number_crunch_limit); auto output_message = connections_[id].publisher->borrow_loaned_message(); output_message.get().size = 0; merge_history_into_sample(output_message.get(), input_message); uint32_t missed_samples = get_missed_samples_and_update_seq_nr( input_message, connections_[id].input_sequence_number); set_sample( this->get_name(), connections_[id].sequence_number++, missed_samples, timestamp, output_message.get()); // use result so that it is not optimizied away by some clever compiler output_message.get().data[0] = number_cruncher_result; connections_[id].publisher->publish(std::move(output_message)); } private: struct Connection { rclcpp::Publisher<message_t>::SharedPtr publisher; rclcpp::Subscription<message_t>::SharedPtr subscription; rclcpp::CallbackGroup::SharedPtr callback_group; uint64_t number_crunch_limit; uint32_t sequence_number = 0; uint32_t input_sequence_number = 0; }; std::vector<Connection> connections_; }; } // namespace rclcpp_system } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__RCLCPP__INTERSECTION_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_system/include/reference_system/nodes/rclcpp/intersection.hpp"},{"location":"Files/intersection_8hpp/#reference_systemincludereference_systemnodesrclcppintersectionhpp","text":"","title":"reference_system/include/reference_system/nodes/rclcpp/intersection.hpp"},{"location":"Files/intersection_8hpp/#namespaces","text":"Name nodes nodes::rclcpp_system","title":"Namespaces"},{"location":"Files/intersection_8hpp/#classes","text":"Name class nodes::rclcpp_system::Intersection","title":"Classes"},{"location":"Files/intersection_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__RCLCPP__INTERSECTION_HPP_ #define REFERENCE_SYSTEM__NODES__RCLCPP__INTERSECTION_HPP_ #include <cstdlib> #include <chrono> #include <memory> #include <string> #include <utility> #include <vector> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/number_cruncher.hpp\" #include \"reference_system/sample_management.hpp\" #include \"reference_system/msg_types.hpp\" namespace nodes { namespace rclcpp_system { class Intersection : public rclcpp::Node { public: explicit Intersection(const IntersectionSettings & settings) : Node(settings.node_name) { for (auto & connection : settings.connections) { rclcpp::SubscriptionOptionsWithAllocator<std::allocator<void>> options; rclcpp::CallbackGroup::SharedPtr callback_group = this->create_callback_group( rclcpp::CallbackGroupType::MutuallyExclusive); options.callback_group = callback_group; connections_.emplace_back( Connection{ this->create_publisher<message_t>(connection.output_topic, 1), this->create_subscription<message_t>( connection.input_topic, 1, [this, id = connections_.size()](const message_t::SharedPtr msg) { input_callback(msg, id); }, options), callback_group, connection.number_crunch_limit }); } } rclcpp::CallbackGroup::SharedPtr get_callback_group_of_subscription( const std::string & input_topic) { for (auto & connection : connections_) { if (input_topic == connection.subscription->get_topic_name()) { return connection.callback_group; } } RCLCPP_FATAL(get_logger(), \"Subscription for topic '%s' not found!\", input_topic.c_str()); std::exit(1); } private: void input_callback(const message_t::SharedPtr input_message, const uint64_t id) { uint64_t timestamp = now_as_int(); auto number_cruncher_result = number_cruncher(connections_[id].number_crunch_limit); auto output_message = connections_[id].publisher->borrow_loaned_message(); output_message.get().size = 0; merge_history_into_sample(output_message.get(), input_message); uint32_t missed_samples = get_missed_samples_and_update_seq_nr( input_message, connections_[id].input_sequence_number); set_sample( this->get_name(), connections_[id].sequence_number++, missed_samples, timestamp, output_message.get()); // use result so that it is not optimizied away by some clever compiler output_message.get().data[0] = number_cruncher_result; connections_[id].publisher->publish(std::move(output_message)); } private: struct Connection { rclcpp::Publisher<message_t>::SharedPtr publisher; rclcpp::Subscription<message_t>::SharedPtr subscription; rclcpp::CallbackGroup::SharedPtr callback_group; uint64_t number_crunch_limit; uint32_t sequence_number = 0; uint32_t input_sequence_number = 0; }; std::vector<Connection> connections_; }; } // namespace rclcpp_system } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__RCLCPP__INTERSECTION_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/memory__usage_8py/","text":"autoware_reference_system/test/memory_usage.py Namespaces Name memory_usage Source code # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import glob import os from bokeh.models import ColumnDataSource from bokeh.models.axes import LinearAxis from bokeh.models.ranges import FactorRange, Range1d from bokeh.models.tools import HoverTool from bokeh.models.widgets.markups import Div from bokeh.models.widgets.tables import DataTable, TableColumn from bokeh.palettes import cividis from bokeh.plotting import figure from bokeh.transform import factor_cmap from constants import SIZE_AXIS_LABEL, SIZE_CATEGORY_LABEL, SIZE_MAJOR_LABEL, SIZE_TITLE from constants import SIZE_TABLE_ROW, SIZE_TABLE_WIDTH import pandas as pd def summary(path, duration, size): data = [] x = [] raw_df = [] summary_data = { 'exe': [], 'rmw': [], 'type': [], 'low': [], 'mean': [], 'high': [], 'std_dev': [], 'top': [], 'bottom': [] } for idx, fpath in enumerate(glob.glob(path + '*' + duration + '*.txt')): fname = os.path.basename(fpath) if '.txt' in fname: fname = fname[:-4] # extract exe and rmw name tmp_name = fname.find('_rmw') exe = fname[0:tmp_name] rmw = fname[tmp_name + 1:-(len(duration) + 2)] # open datafile and parse it into a usable structure data.append(open(fpath).read().splitlines()[1:]) data[idx] = [[float(element) for element in line.split()] for line in data[idx]] # add raw data to dataframe raw_df.append( pd.DataFrame( data=data[idx], columns=[ 'time', 'cpu', 'real', 'virtual'])) # calculate statics from raw data df_summary = raw_df[idx].describe().T.reset_index() # add data to dictionary for index, row in df_summary.iterrows(): summary_data['exe'].append(exe) summary_data['rmw'].append(rmw) summary_data['type'].append(row['index']) summary_data['low'].append(row['min']) summary_data['mean'].append(row['mean']) summary_data['high'].append(row['max']) summary_data['top'].append(row['75%']) summary_data['bottom'].append(row['25%']) summary_data['std_dev'].append(row['std']) df = pd.DataFrame.from_records( summary_data, columns=[ 'exe', 'rmw', 'type', 'low', 'mean', 'high', 'top', 'bottom', 'std_dev']) # sort by exe and rmw df = df.sort_values(['exe', 'rmw'], ascending=True) exes = [] rmws = [] for exe in df.exe: for rmw in df.rmw: # add exe and rmw to list if exe not in exes: exes.append(exe) if rmw not in rmws: rmws.append(rmw) for exe in exes: for rmw in rmws: x.append((exe, rmw)) cpu = df.type == 'cpu' real = df.type == 'real' virtual = df.type == 'virtual' cpu_source = ColumnDataSource(df[cpu]) real_source = ColumnDataSource(df[real]) virtual_source = ColumnDataSource(df[virtual]) # add exe and rmw list of tuples for x axis cpu_source.data['x'] = x real_source.data['x'] = x virtual_source.data['x'] = x # initialize cpu figure cpu_fig = figure( title='CPU Usage Summary ' + str(duration) + 's', x_axis_label=f'Executors (with RMW)', y_axis_label='CPU (%)', x_range=FactorRange(*x), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) cpu_fig.segment( x, df.high[cpu].values, x, df.low[cpu].values, color='black', line_width=2) cpu_fig.vbar( width=0.2, x='x', top='mean', source=cpu_source, line_color='black', fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) cpu_fig.scatter( size=25, x='x', y='high', source=cpu_source, line_color='black', line_width=2, marker='dash', fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) cpu_fig.y_range.start = 0 cpu_fig.x_range.range_padding = 0.1 cpu_fig.title.text_font_size = SIZE_TITLE cpu_fig.xaxis.axis_label_text_font_size = SIZE_AXIS_LABEL cpu_fig.yaxis.axis_label_text_font_size = SIZE_AXIS_LABEL cpu_fig.yaxis.major_label_text_font_size = SIZE_MAJOR_LABEL cpu_fig.below[0].group_text_font_size = SIZE_CATEGORY_LABEL cpu_fig.below[0].major_label_text_font_size = SIZE_MAJOR_LABEL # initialize real memory figure real_fig = figure( title='Real Memory Usage Summary ' + str(duration) + 's', x_axis_label=f'Executors (with RMW)', y_axis_label='Real Memory Usage (MB)', x_range=FactorRange(*x), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) real_fig.segment( x, df.high[real].values, x, df.low[real].values, color='black', line_width=2) real_fig.vbar( width=0.2, x='x', top='mean', source=real_source, line_color='black', fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) real_fig.scatter( size=25, x='x', y='high', source=real_source, line_color='black', line_width=2, marker='dash', fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) real_fig.y_range.start = 0 real_fig.x_range.range_padding = 0.1 real_fig.title.text_font_size = SIZE_TITLE real_fig.xaxis.axis_label_text_font_size = SIZE_AXIS_LABEL real_fig.yaxis.axis_label_text_font_size = SIZE_AXIS_LABEL real_fig.yaxis.major_label_text_font_size = SIZE_MAJOR_LABEL real_fig.below[0].group_text_font_size = SIZE_CATEGORY_LABEL real_fig.below[0].major_label_text_font_size = SIZE_MAJOR_LABEL # initialize virtual memory figure virtual_fig = figure( title='Virtual Memory Usage Summary ' + str(duration) + 's', x_axis_label=f'Executors (with RMW)', y_axis_label='Virtual Memory Usage (MB)', x_range=FactorRange(*x), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) virtual_fig.segment( x, df.high[virtual].values, x, df.low[virtual].values, color='black', line_width=2) virtual_fig.vbar( width=0.2, x='x', top='mean', source=virtual_source, line_color='black', fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) virtual_fig.scatter( size=25, x='x', y='high', source=virtual_source, line_color='black', line_width=2, marker='dash', fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) virtual_fig.y_range.start = 0 virtual_fig.x_range.range_padding = 0.1 virtual_fig.title.text_font_size = SIZE_TITLE virtual_fig.xaxis.axis_label_text_font_size = SIZE_AXIS_LABEL virtual_fig.yaxis.axis_label_text_font_size = SIZE_AXIS_LABEL virtual_fig.yaxis.major_label_text_font_size = SIZE_MAJOR_LABEL virtual_fig.below[0].group_text_font_size = SIZE_CATEGORY_LABEL virtual_fig.below[0].major_label_text_font_size = SIZE_MAJOR_LABEL # add cpu hover tool cpu_hover = HoverTool() cpu_hover.tooltips = [ ('Average CPU Usage (%)', '@{mean}{0.00}'), ('Minimum CPU Usage (%)', '@{low}{0.00}'), ('Maximum CPU Usage (%)', '@{high}{0.00}') ] cpu_fig.add_tools(cpu_hover) # add real hover tool real_hover = HoverTool() real_hover.tooltips = [ ('Average Real Memory Used (MB)', '@{mean}{0.00}'), ('Minimum Real Memory Used (MB)', '@{low}{0.00}'), ('Maximum Real Memory Used (MB)', '@{high}{0.00}') ] real_fig.add_tools(real_hover) # add virtual hover tool virtual_hover = HoverTool() virtual_hover.tooltips = [ ('Average Virtual Memory Used (MB)', '@{mean}{0.00}'), ('Minimum Virtual Memory Used (MB)', '@{low}{0.00}'), ('Maximum Virtual Memory Used (MB)', '@{high}{0.00}') ] virtual_fig.add_tools(virtual_hover) # add cpu usage table columns = [TableColumn(field=col, title=col) for col in df] cpu_table_title = Div( text='<b>CPU Usage Statistics ' + str(duration) + 's</b>', width=SIZE_TABLE_WIDTH, height=SIZE_TABLE_ROW ) cpu_table = [ cpu_table_title, DataTable( columns=columns, source=ColumnDataSource(df[cpu].round(decimals=2)), autosize_mode='fit_viewport', margin=(0, 10, 10, 10), height=(len(df[cpu].exe.values.tolist()) * SIZE_TABLE_ROW), width=SIZE_TABLE_WIDTH)] # add real table real_table_title = Div( text='<b>Real Memory Usage Statistics ' + str(duration) + 's</b>', width=SIZE_TABLE_WIDTH, height=SIZE_TABLE_ROW ) real_table = [ real_table_title, DataTable( columns=columns, source=ColumnDataSource(df[real]), margin=(0, 10, 10, 10), height=(len(df[real].exe.values.tolist()) * SIZE_TABLE_ROW), width=SIZE_TABLE_WIDTH)] # add virtual table virtual_table_title = Div( text='<b>Virtual Memory Usage Statistics ' + str(duration) + 's</b>', width=SIZE_TABLE_WIDTH, height=SIZE_TABLE_ROW ) virtual_table = [ virtual_table_title, DataTable( columns=columns, source=ColumnDataSource(df[virtual]), margin=(0, 10, 10, 10), height=(len(df[virtual].exe.values.tolist()) * SIZE_TABLE_ROW), width=SIZE_TABLE_WIDTH)] # add figures and tables to output memory_figs = [ [cpu_table], [cpu_fig], [real_table], [real_fig], [virtual_table], [virtual_fig] ] return memory_figs def individual(path, size): basename = os.path.basename(path)[:-4] # open file data = open(path).read().splitlines()[1:] data = [[float(element) for element in line.split()] for line in data] df = pd.DataFrame(data=data, columns=['Elapsed Time', 'CPU (%)', 'Real (MB)', 'Virtual (MB)']) # add summary stats df_summary = df.describe().T.reset_index() # initialize list of figures memory = [] source = ColumnDataSource(df) # colors colors = [ '#158171', '#286f80', '#1bab78' ] # initialize raw data figure raw_data_fig = figure( title='Memory and CPU Usage Data [' + basename + ']', x_axis_label=f'Time (sec)', y_axis_label='CPU (%)', plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) # add CPU usage to figure raw_data_fig.line( x='Elapsed Time', y='CPU (%)', line_width=1, source=source, line_color=colors[0], alpha=0.8, legend_label='CPU (%)', muted_color=colors[0], muted_alpha=0.2 ) # legend attributes raw_data_fig.legend.location = 'top_right' raw_data_fig.legend.click_policy = 'hide' # add extra y ranges raw_data_fig.extra_y_ranges = { 'Real (MB)': Range1d( start=0, end=df_summary.loc[2, 'max'] + 25 ) } raw_data_fig.add_layout( LinearAxis( y_range_name='Real (MB)', axis_label='Real (MB)'), 'right' ) # add Real memory usage to figure raw_data_fig.line( x='Elapsed Time', y='Real (MB)', y_range_name='Real (MB)', line_width=1, source=source, line_color=colors[1], alpha=0.8, legend_label='Real (MB)', muted_color=colors[1], muted_alpha=0.2 ) raw_data_fig.title.text_font_size = SIZE_TITLE raw_data_fig.xaxis.axis_label_text_font_size = SIZE_AXIS_LABEL raw_data_fig.yaxis.axis_label_text_font_size = SIZE_AXIS_LABEL raw_data_fig.xaxis.major_label_text_font_size = SIZE_MAJOR_LABEL raw_data_fig.yaxis.major_label_text_font_size = SIZE_MAJOR_LABEL # add hover tool hover = HoverTool() hover.tooltips = [ ('CPU (%)', '@{CPU (%)}{0.00}'), ('Real (MB)', '@{Real (MB)}{0.00}'), ('Virtual (MB)', '@{Virtual (MB)}{0.00}') ] raw_data_fig.add_tools(hover) # create summary table columns = [TableColumn(field=col, title=col) for col in df_summary.columns] table_title = Div( text='<b>Memory and CPU Usage Data: ' + basename + '</b>', width=1000, height=20, style={ 'font-size': SIZE_MAJOR_LABEL } ) summary_fig = [ table_title, DataTable( columns=columns, source=ColumnDataSource(df_summary), margin=(10, 10, 10, 10), height=140)] # add figure and table to output memory = [[summary_fig], [raw_data_fig]] return memory Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/test/memory_usage.py"},{"location":"Files/memory__usage_8py/#autoware_reference_systemtestmemory_usagepy","text":"","title":"autoware_reference_system/test/memory_usage.py"},{"location":"Files/memory__usage_8py/#namespaces","text":"Name memory_usage","title":"Namespaces"},{"location":"Files/memory__usage_8py/#source-code","text":"# Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import glob import os from bokeh.models import ColumnDataSource from bokeh.models.axes import LinearAxis from bokeh.models.ranges import FactorRange, Range1d from bokeh.models.tools import HoverTool from bokeh.models.widgets.markups import Div from bokeh.models.widgets.tables import DataTable, TableColumn from bokeh.palettes import cividis from bokeh.plotting import figure from bokeh.transform import factor_cmap from constants import SIZE_AXIS_LABEL, SIZE_CATEGORY_LABEL, SIZE_MAJOR_LABEL, SIZE_TITLE from constants import SIZE_TABLE_ROW, SIZE_TABLE_WIDTH import pandas as pd def summary(path, duration, size): data = [] x = [] raw_df = [] summary_data = { 'exe': [], 'rmw': [], 'type': [], 'low': [], 'mean': [], 'high': [], 'std_dev': [], 'top': [], 'bottom': [] } for idx, fpath in enumerate(glob.glob(path + '*' + duration + '*.txt')): fname = os.path.basename(fpath) if '.txt' in fname: fname = fname[:-4] # extract exe and rmw name tmp_name = fname.find('_rmw') exe = fname[0:tmp_name] rmw = fname[tmp_name + 1:-(len(duration) + 2)] # open datafile and parse it into a usable structure data.append(open(fpath).read().splitlines()[1:]) data[idx] = [[float(element) for element in line.split()] for line in data[idx]] # add raw data to dataframe raw_df.append( pd.DataFrame( data=data[idx], columns=[ 'time', 'cpu', 'real', 'virtual'])) # calculate statics from raw data df_summary = raw_df[idx].describe().T.reset_index() # add data to dictionary for index, row in df_summary.iterrows(): summary_data['exe'].append(exe) summary_data['rmw'].append(rmw) summary_data['type'].append(row['index']) summary_data['low'].append(row['min']) summary_data['mean'].append(row['mean']) summary_data['high'].append(row['max']) summary_data['top'].append(row['75%']) summary_data['bottom'].append(row['25%']) summary_data['std_dev'].append(row['std']) df = pd.DataFrame.from_records( summary_data, columns=[ 'exe', 'rmw', 'type', 'low', 'mean', 'high', 'top', 'bottom', 'std_dev']) # sort by exe and rmw df = df.sort_values(['exe', 'rmw'], ascending=True) exes = [] rmws = [] for exe in df.exe: for rmw in df.rmw: # add exe and rmw to list if exe not in exes: exes.append(exe) if rmw not in rmws: rmws.append(rmw) for exe in exes: for rmw in rmws: x.append((exe, rmw)) cpu = df.type == 'cpu' real = df.type == 'real' virtual = df.type == 'virtual' cpu_source = ColumnDataSource(df[cpu]) real_source = ColumnDataSource(df[real]) virtual_source = ColumnDataSource(df[virtual]) # add exe and rmw list of tuples for x axis cpu_source.data['x'] = x real_source.data['x'] = x virtual_source.data['x'] = x # initialize cpu figure cpu_fig = figure( title='CPU Usage Summary ' + str(duration) + 's', x_axis_label=f'Executors (with RMW)', y_axis_label='CPU (%)', x_range=FactorRange(*x), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) cpu_fig.segment( x, df.high[cpu].values, x, df.low[cpu].values, color='black', line_width=2) cpu_fig.vbar( width=0.2, x='x', top='mean', source=cpu_source, line_color='black', fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) cpu_fig.scatter( size=25, x='x', y='high', source=cpu_source, line_color='black', line_width=2, marker='dash', fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) cpu_fig.y_range.start = 0 cpu_fig.x_range.range_padding = 0.1 cpu_fig.title.text_font_size = SIZE_TITLE cpu_fig.xaxis.axis_label_text_font_size = SIZE_AXIS_LABEL cpu_fig.yaxis.axis_label_text_font_size = SIZE_AXIS_LABEL cpu_fig.yaxis.major_label_text_font_size = SIZE_MAJOR_LABEL cpu_fig.below[0].group_text_font_size = SIZE_CATEGORY_LABEL cpu_fig.below[0].major_label_text_font_size = SIZE_MAJOR_LABEL # initialize real memory figure real_fig = figure( title='Real Memory Usage Summary ' + str(duration) + 's', x_axis_label=f'Executors (with RMW)', y_axis_label='Real Memory Usage (MB)', x_range=FactorRange(*x), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) real_fig.segment( x, df.high[real].values, x, df.low[real].values, color='black', line_width=2) real_fig.vbar( width=0.2, x='x', top='mean', source=real_source, line_color='black', fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) real_fig.scatter( size=25, x='x', y='high', source=real_source, line_color='black', line_width=2, marker='dash', fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) real_fig.y_range.start = 0 real_fig.x_range.range_padding = 0.1 real_fig.title.text_font_size = SIZE_TITLE real_fig.xaxis.axis_label_text_font_size = SIZE_AXIS_LABEL real_fig.yaxis.axis_label_text_font_size = SIZE_AXIS_LABEL real_fig.yaxis.major_label_text_font_size = SIZE_MAJOR_LABEL real_fig.below[0].group_text_font_size = SIZE_CATEGORY_LABEL real_fig.below[0].major_label_text_font_size = SIZE_MAJOR_LABEL # initialize virtual memory figure virtual_fig = figure( title='Virtual Memory Usage Summary ' + str(duration) + 's', x_axis_label=f'Executors (with RMW)', y_axis_label='Virtual Memory Usage (MB)', x_range=FactorRange(*x), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) virtual_fig.segment( x, df.high[virtual].values, x, df.low[virtual].values, color='black', line_width=2) virtual_fig.vbar( width=0.2, x='x', top='mean', source=virtual_source, line_color='black', fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) virtual_fig.scatter( size=25, x='x', y='high', source=virtual_source, line_color='black', line_width=2, marker='dash', fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) virtual_fig.y_range.start = 0 virtual_fig.x_range.range_padding = 0.1 virtual_fig.title.text_font_size = SIZE_TITLE virtual_fig.xaxis.axis_label_text_font_size = SIZE_AXIS_LABEL virtual_fig.yaxis.axis_label_text_font_size = SIZE_AXIS_LABEL virtual_fig.yaxis.major_label_text_font_size = SIZE_MAJOR_LABEL virtual_fig.below[0].group_text_font_size = SIZE_CATEGORY_LABEL virtual_fig.below[0].major_label_text_font_size = SIZE_MAJOR_LABEL # add cpu hover tool cpu_hover = HoverTool() cpu_hover.tooltips = [ ('Average CPU Usage (%)', '@{mean}{0.00}'), ('Minimum CPU Usage (%)', '@{low}{0.00}'), ('Maximum CPU Usage (%)', '@{high}{0.00}') ] cpu_fig.add_tools(cpu_hover) # add real hover tool real_hover = HoverTool() real_hover.tooltips = [ ('Average Real Memory Used (MB)', '@{mean}{0.00}'), ('Minimum Real Memory Used (MB)', '@{low}{0.00}'), ('Maximum Real Memory Used (MB)', '@{high}{0.00}') ] real_fig.add_tools(real_hover) # add virtual hover tool virtual_hover = HoverTool() virtual_hover.tooltips = [ ('Average Virtual Memory Used (MB)', '@{mean}{0.00}'), ('Minimum Virtual Memory Used (MB)', '@{low}{0.00}'), ('Maximum Virtual Memory Used (MB)', '@{high}{0.00}') ] virtual_fig.add_tools(virtual_hover) # add cpu usage table columns = [TableColumn(field=col, title=col) for col in df] cpu_table_title = Div( text='<b>CPU Usage Statistics ' + str(duration) + 's</b>', width=SIZE_TABLE_WIDTH, height=SIZE_TABLE_ROW ) cpu_table = [ cpu_table_title, DataTable( columns=columns, source=ColumnDataSource(df[cpu].round(decimals=2)), autosize_mode='fit_viewport', margin=(0, 10, 10, 10), height=(len(df[cpu].exe.values.tolist()) * SIZE_TABLE_ROW), width=SIZE_TABLE_WIDTH)] # add real table real_table_title = Div( text='<b>Real Memory Usage Statistics ' + str(duration) + 's</b>', width=SIZE_TABLE_WIDTH, height=SIZE_TABLE_ROW ) real_table = [ real_table_title, DataTable( columns=columns, source=ColumnDataSource(df[real]), margin=(0, 10, 10, 10), height=(len(df[real].exe.values.tolist()) * SIZE_TABLE_ROW), width=SIZE_TABLE_WIDTH)] # add virtual table virtual_table_title = Div( text='<b>Virtual Memory Usage Statistics ' + str(duration) + 's</b>', width=SIZE_TABLE_WIDTH, height=SIZE_TABLE_ROW ) virtual_table = [ virtual_table_title, DataTable( columns=columns, source=ColumnDataSource(df[virtual]), margin=(0, 10, 10, 10), height=(len(df[virtual].exe.values.tolist()) * SIZE_TABLE_ROW), width=SIZE_TABLE_WIDTH)] # add figures and tables to output memory_figs = [ [cpu_table], [cpu_fig], [real_table], [real_fig], [virtual_table], [virtual_fig] ] return memory_figs def individual(path, size): basename = os.path.basename(path)[:-4] # open file data = open(path).read().splitlines()[1:] data = [[float(element) for element in line.split()] for line in data] df = pd.DataFrame(data=data, columns=['Elapsed Time', 'CPU (%)', 'Real (MB)', 'Virtual (MB)']) # add summary stats df_summary = df.describe().T.reset_index() # initialize list of figures memory = [] source = ColumnDataSource(df) # colors colors = [ '#158171', '#286f80', '#1bab78' ] # initialize raw data figure raw_data_fig = figure( title='Memory and CPU Usage Data [' + basename + ']', x_axis_label=f'Time (sec)', y_axis_label='CPU (%)', plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) # add CPU usage to figure raw_data_fig.line( x='Elapsed Time', y='CPU (%)', line_width=1, source=source, line_color=colors[0], alpha=0.8, legend_label='CPU (%)', muted_color=colors[0], muted_alpha=0.2 ) # legend attributes raw_data_fig.legend.location = 'top_right' raw_data_fig.legend.click_policy = 'hide' # add extra y ranges raw_data_fig.extra_y_ranges = { 'Real (MB)': Range1d( start=0, end=df_summary.loc[2, 'max'] + 25 ) } raw_data_fig.add_layout( LinearAxis( y_range_name='Real (MB)', axis_label='Real (MB)'), 'right' ) # add Real memory usage to figure raw_data_fig.line( x='Elapsed Time', y='Real (MB)', y_range_name='Real (MB)', line_width=1, source=source, line_color=colors[1], alpha=0.8, legend_label='Real (MB)', muted_color=colors[1], muted_alpha=0.2 ) raw_data_fig.title.text_font_size = SIZE_TITLE raw_data_fig.xaxis.axis_label_text_font_size = SIZE_AXIS_LABEL raw_data_fig.yaxis.axis_label_text_font_size = SIZE_AXIS_LABEL raw_data_fig.xaxis.major_label_text_font_size = SIZE_MAJOR_LABEL raw_data_fig.yaxis.major_label_text_font_size = SIZE_MAJOR_LABEL # add hover tool hover = HoverTool() hover.tooltips = [ ('CPU (%)', '@{CPU (%)}{0.00}'), ('Real (MB)', '@{Real (MB)}{0.00}'), ('Virtual (MB)', '@{Virtual (MB)}{0.00}') ] raw_data_fig.add_tools(hover) # create summary table columns = [TableColumn(field=col, title=col) for col in df_summary.columns] table_title = Div( text='<b>Memory and CPU Usage Data: ' + basename + '</b>', width=1000, height=20, style={ 'font-size': SIZE_MAJOR_LABEL } ) summary_fig = [ table_title, DataTable( columns=columns, source=ColumnDataSource(df_summary), margin=(10, 10, 10, 10), height=140)] # add figure and table to output memory = [[summary_fig], [raw_data_fig]] return memory Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/msg__types_8hpp/","text":"reference_system/include/reference_system/msg_types.hpp Types Name using reference_interfaces::msg::Message4kb message_t Types Documentation using message_t using message_t = reference_interfaces::msg::Message4kb; Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__MSG_TYPES_HPP_ #define REFERENCE_SYSTEM__MSG_TYPES_HPP_ #include \"reference_interfaces/msg/message4kb.hpp\" using message_t = reference_interfaces::msg::Message4kb; #endif // REFERENCE_SYSTEM__MSG_TYPES_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_system/include/reference_system/msg_types.hpp"},{"location":"Files/msg__types_8hpp/#reference_systemincludereference_systemmsg_typeshpp","text":"","title":"reference_system/include/reference_system/msg_types.hpp"},{"location":"Files/msg__types_8hpp/#types","text":"Name using reference_interfaces::msg::Message4kb message_t","title":"Types"},{"location":"Files/msg__types_8hpp/#types-documentation","text":"","title":"Types Documentation"},{"location":"Files/msg__types_8hpp/#using-message_t","text":"using message_t = reference_interfaces::msg::Message4kb;","title":"using message_t"},{"location":"Files/msg__types_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__MSG_TYPES_HPP_ #define REFERENCE_SYSTEM__MSG_TYPES_HPP_ #include \"reference_interfaces/msg/message4kb.hpp\" using message_t = reference_interfaces::msg::Message4kb; #endif // REFERENCE_SYSTEM__MSG_TYPES_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/number__cruncher_8hpp/","text":"reference_system/include/reference_system/number_cruncher.hpp Functions Name uint64_t number_cruncher (const uint64_t maximum_number) long double get_crunch_time_in_ms (const uint64_t maximum_number) Functions Documentation function number_cruncher uint64_t number_cruncher( const uint64_t maximum_number ) function get_crunch_time_in_ms long double get_crunch_time_in_ms( const uint64_t maximum_number ) Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NUMBER_CRUNCHER_HPP_ #define REFERENCE_SYSTEM__NUMBER_CRUNCHER_HPP_ #include <chrono> #include <cmath> #include <vector> uint64_t number_cruncher(const uint64_t maximum_number) { uint64_t number_of_primes = 0; uint64_t initial_value = 2; // edge case where max number is too low if (maximum_number <= initial_value) { return 2; } for (uint64_t i = initial_value; i <= maximum_number; ++i) { bool is_prime = true; for (uint64_t n = initial_value; n < i; ++n) { if (i % n == 0) { is_prime = false; break; } } if (is_prime) { ++number_of_primes; } } return number_of_primes; } long double get_crunch_time_in_ms(const uint64_t maximum_number) { auto start = std::chrono::system_clock::now(); number_cruncher(maximum_number); auto stop = std::chrono::system_clock::now(); return static_cast<long double>( std::chrono::nanoseconds(stop - start).count() / 1000000.0); } #endif // REFERENCE_SYSTEM__NUMBER_CRUNCHER_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_system/include/reference_system/number_cruncher.hpp"},{"location":"Files/number__cruncher_8hpp/#reference_systemincludereference_systemnumber_cruncherhpp","text":"","title":"reference_system/include/reference_system/number_cruncher.hpp"},{"location":"Files/number__cruncher_8hpp/#functions","text":"Name uint64_t number_cruncher (const uint64_t maximum_number) long double get_crunch_time_in_ms (const uint64_t maximum_number)","title":"Functions"},{"location":"Files/number__cruncher_8hpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/number__cruncher_8hpp/#function-number_cruncher","text":"uint64_t number_cruncher( const uint64_t maximum_number )","title":"function number_cruncher"},{"location":"Files/number__cruncher_8hpp/#function-get_crunch_time_in_ms","text":"long double get_crunch_time_in_ms( const uint64_t maximum_number )","title":"function get_crunch_time_in_ms"},{"location":"Files/number__cruncher_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NUMBER_CRUNCHER_HPP_ #define REFERENCE_SYSTEM__NUMBER_CRUNCHER_HPP_ #include <chrono> #include <cmath> #include <vector> uint64_t number_cruncher(const uint64_t maximum_number) { uint64_t number_of_primes = 0; uint64_t initial_value = 2; // edge case where max number is too low if (maximum_number <= initial_value) { return 2; } for (uint64_t i = initial_value; i <= maximum_number; ++i) { bool is_prime = true; for (uint64_t n = initial_value; n < i; ++n) { if (i % n == 0) { is_prime = false; break; } } if (is_prime) { ++number_of_primes; } } return number_of_primes; } long double get_crunch_time_in_ms(const uint64_t maximum_number) { auto start = std::chrono::system_clock::now(); number_cruncher(maximum_number); auto stop = std::chrono::system_clock::now(); return static_cast<long double>( std::chrono::nanoseconds(stop - start).count() / 1000000.0); } #endif // REFERENCE_SYSTEM__NUMBER_CRUNCHER_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/number__cruncher__benchmark_8cpp/","text":"autoware_reference_system/src/ros2/number_cruncher_benchmark.cpp Functions Name int main () Functions Documentation function main int main() Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // #include \"reference_system/number_cruncher.hpp\" #include <iostream> #include <iomanip> int main() { long double crunch_time = 0.0; std::cout << \"maximum_number run time\" << std::endl; for (uint64_t i = 64; crunch_time < 1000.0; i *= 2) { crunch_time = get_crunch_time_in_ms(i); std::cout << std::setfill(' ') << std::setw(12) << i << \" \" << crunch_time << \"ms\" << std::endl; } } Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/src/ros2/number_cruncher_benchmark.cpp"},{"location":"Files/number__cruncher__benchmark_8cpp/#autoware_reference_systemsrcros2number_cruncher_benchmarkcpp","text":"","title":"autoware_reference_system/src/ros2/number_cruncher_benchmark.cpp"},{"location":"Files/number__cruncher__benchmark_8cpp/#functions","text":"Name int main ()","title":"Functions"},{"location":"Files/number__cruncher__benchmark_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/number__cruncher__benchmark_8cpp/#function-main","text":"int main()","title":"function main"},{"location":"Files/number__cruncher__benchmark_8cpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // #include \"reference_system/number_cruncher.hpp\" #include <iostream> #include <iomanip> int main() { long double crunch_time = 0.0; std::cout << \"maximum_number run time\" << std::endl; for (uint64_t i = 64; crunch_time < 1000.0; i *= 2) { crunch_time = get_crunch_time_in_ms(i); std::cout << std::setfill(' ') << std::setw(12) << i << \" \" << crunch_time << \"ms\" << std::endl; } } Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/rclcpp__system_8hpp/","text":"reference_system/include/reference_system/system/type/rclcpp_system.hpp Classes Name struct RclcppSystem Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__SYSTEM__TYPE__RCLCPP_SYSTEM_HPP_ #define REFERENCE_SYSTEM__SYSTEM__TYPE__RCLCPP_SYSTEM_HPP_ #include \"reference_system/nodes/rclcpp/command.hpp\" #include \"reference_system/nodes/rclcpp/fusion.hpp\" #include \"reference_system/nodes/rclcpp/transform.hpp\" #include \"reference_system/nodes/rclcpp/cyclic.hpp\" #include \"reference_system/nodes/rclcpp/sensor.hpp\" #include \"reference_system/nodes/rclcpp/intersection.hpp\" struct RclcppSystem { using NodeBaseType = rclcpp::Node; using Command = nodes::rclcpp_system::Command; using Cyclic = nodes::rclcpp_system::Cyclic; using Fusion = nodes::rclcpp_system::Fusion; using Intersection = nodes::rclcpp_system::Intersection; using Sensor = nodes::rclcpp_system::Sensor; using Transform = nodes::rclcpp_system::Transform; }; #endif // REFERENCE_SYSTEM__SYSTEM__TYPE__RCLCPP_SYSTEM_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_system/include/reference_system/system/type/rclcpp_system.hpp"},{"location":"Files/rclcpp__system_8hpp/#reference_systemincludereference_systemsystemtyperclcpp_systemhpp","text":"","title":"reference_system/include/reference_system/system/type/rclcpp_system.hpp"},{"location":"Files/rclcpp__system_8hpp/#classes","text":"Name struct RclcppSystem","title":"Classes"},{"location":"Files/rclcpp__system_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__SYSTEM__TYPE__RCLCPP_SYSTEM_HPP_ #define REFERENCE_SYSTEM__SYSTEM__TYPE__RCLCPP_SYSTEM_HPP_ #include \"reference_system/nodes/rclcpp/command.hpp\" #include \"reference_system/nodes/rclcpp/fusion.hpp\" #include \"reference_system/nodes/rclcpp/transform.hpp\" #include \"reference_system/nodes/rclcpp/cyclic.hpp\" #include \"reference_system/nodes/rclcpp/sensor.hpp\" #include \"reference_system/nodes/rclcpp/intersection.hpp\" struct RclcppSystem { using NodeBaseType = rclcpp::Node; using Command = nodes::rclcpp_system::Command; using Cyclic = nodes::rclcpp_system::Cyclic; using Fusion = nodes::rclcpp_system::Fusion; using Intersection = nodes::rclcpp_system::Intersection; using Sensor = nodes::rclcpp_system::Sensor; using Transform = nodes::rclcpp_system::Transform; }; #endif // REFERENCE_SYSTEM__SYSTEM__TYPE__RCLCPP_SYSTEM_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/reference__interfaces_2CMakeLists_8txt/","text":"CMakeLists.txt Functions Name cmake_minimum_required (VERSION 3. 5) Functions Documentation function cmake_minimum_required cmake_minimum_required( VERSION 3. 5 ) Source code cmake_minimum_required(VERSION 3.5) project(reference_interfaces) # Default to C++17 if(NOT CMAKE_CXX_STANDARD) set(CMAKE_CXX_STANDARD 17) endif() if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\") add_compile_options(-Wall -Wextra -Wpedantic) endif() find_package(ament_cmake_auto REQUIRED) ament_auto_find_build_dependencies() # add additional messages here set(msg_files \"msg/TransmissionStats.idl\" \"msg/Message4kb.idl\" ) # add additional message dependencies here #set(msg_dependencies # \"std_msgs\" #) rosidl_generate_interfaces(${PROJECT_NAME} ${msg_files} DEPENDENCIES ${msg_dependencies} ADD_LINTER_TESTS ) ament_auto_package() # fix rosidl_generator_py bug #143 # https://github.com/ros2/rosidl_python/issues/143 set(GENERATED_FILE \"${CMAKE_CURRENT_BINARY_DIR}/rosidl_generator_py/${PROJECT_NAME}/msg/_transmission_stats.py\") message(STATUS \"checking generated file: ${GENERATED_FILE}\") add_custom_command( TARGET ${PROJECT_NAME}__python POST_BUILD COMMAND sed -i \"s/all(val >= 0 and val) < 256/all(ord(val) >= 0 and ord(val) < 256/\" ${GENERATED_FILE} COMMENT \"Check generated IDL files for extra parenthesis...\" VERBATIM) Updated on 2021-12-24 at 17:45:36 +0000","title":"CMakeLists.txt"},{"location":"Files/reference__interfaces_2CMakeLists_8txt/#cmakeliststxt","text":"","title":"CMakeLists.txt"},{"location":"Files/reference__interfaces_2CMakeLists_8txt/#functions","text":"Name cmake_minimum_required (VERSION 3. 5)","title":"Functions"},{"location":"Files/reference__interfaces_2CMakeLists_8txt/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/reference__interfaces_2CMakeLists_8txt/#function-cmake_minimum_required","text":"cmake_minimum_required( VERSION 3. 5 )","title":"function cmake_minimum_required"},{"location":"Files/reference__interfaces_2CMakeLists_8txt/#source-code","text":"cmake_minimum_required(VERSION 3.5) project(reference_interfaces) # Default to C++17 if(NOT CMAKE_CXX_STANDARD) set(CMAKE_CXX_STANDARD 17) endif() if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\") add_compile_options(-Wall -Wextra -Wpedantic) endif() find_package(ament_cmake_auto REQUIRED) ament_auto_find_build_dependencies() # add additional messages here set(msg_files \"msg/TransmissionStats.idl\" \"msg/Message4kb.idl\" ) # add additional message dependencies here #set(msg_dependencies # \"std_msgs\" #) rosidl_generate_interfaces(${PROJECT_NAME} ${msg_files} DEPENDENCIES ${msg_dependencies} ADD_LINTER_TESTS ) ament_auto_package() # fix rosidl_generator_py bug #143 # https://github.com/ros2/rosidl_python/issues/143 set(GENERATED_FILE \"${CMAKE_CURRENT_BINARY_DIR}/rosidl_generator_py/${PROJECT_NAME}/msg/_transmission_stats.py\") message(STATUS \"checking generated file: ${GENERATED_FILE}\") add_custom_command( TARGET ${PROJECT_NAME}__python POST_BUILD COMMAND sed -i \"s/all(val >= 0 and val) < 256/all(ord(val) >= 0 and ord(val) < 256/\" ${GENERATED_FILE} COMMENT \"Check generated IDL files for extra parenthesis...\" VERBATIM) Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/reference__system_2CMakeLists_8txt/","text":"CMakeLists.txt Functions Name cmake_minimum_required (VERSION 3. 5) INTERFACE target_include_directories ( ${PROJECT_NAME} INTERFACE $< BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include > $< INSTALL_INTERFACE:include >) find_package (ament_lint_auto REQUIRED) ament_target_dependencies (test_sample_management reference_interfaces) ament_add_gtest (test_reference_system_rclcpp test/test_fixtures.hpp test/test_reference_system_rclcpp. cpp) ament_target_dependencies (test_reference_system_rclcpp reference_interfaces rclcpp) Functions Documentation function cmake_minimum_required cmake_minimum_required( VERSION 3. 5 ) function target_include_directories INTERFACE target_include_directories( ${PROJECT_NAME} INTERFACE $< BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include > $< INSTALL_INTERFACE:include > ) function find_package find_package( ament_lint_auto REQUIRED ) function ament_target_dependencies ament_target_dependencies( test_sample_management reference_interfaces ) function ament_add_gtest ament_add_gtest( test_reference_system_rclcpp test/test_fixtures.hpp test/test_reference_system_rclcpp. cpp ) function ament_target_dependencies ament_target_dependencies( test_reference_system_rclcpp reference_interfaces rclcpp ) Source code cmake_minimum_required(VERSION 3.5) project(reference_system VERSION 0.0.1 ) if(NOT CMAKE_CXX_STANDARD) set(CMAKE_CXX_STANDARD 17) endif() if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\") add_compile_options(-Wall -Wextra -Wpedantic) endif() find_package(ament_cmake_auto REQUIRED) ament_auto_find_build_dependencies() # Add header-only library add_library(${PROJECT_NAME} INTERFACE) target_include_directories(${PROJECT_NAME} INTERFACE $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include> $<INSTALL_INTERFACE:include> ) if(${BUILD_TESTING}) find_package(ament_lint_auto REQUIRED) ament_lint_auto_find_test_dependencies() find_package(ament_cmake_gtest) # unit tests ament_add_gtest(test_sample_management test/test_sample_management.cpp) target_link_libraries(test_sample_management ${PROJECT_NAME}) ament_target_dependencies(test_sample_management reference_interfaces) ament_add_gtest(test_number_cruncher test/test_number_cruncher.cpp) target_link_libraries(test_number_cruncher ${PROJECT_NAME}) # integration tests ament_add_gtest(test_reference_system_rclcpp test/test_fixtures.hpp test/test_reference_system_rclcpp.cpp) target_link_libraries(test_reference_system_rclcpp ${PROJECT_NAME}) ament_target_dependencies(test_reference_system_rclcpp reference_interfaces rclcpp) endif() # Install install(TARGETS ${PROJECT_NAME} EXPORT \"export_${PROJECT_NAME}\" ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR} LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR} RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR} INCLUDES DESTINATION include ) ament_export_targets(\"export_${PROJECT_NAME}\") ament_auto_package() Updated on 2021-12-24 at 17:45:36 +0000","title":"CMakeLists.txt"},{"location":"Files/reference__system_2CMakeLists_8txt/#cmakeliststxt","text":"","title":"CMakeLists.txt"},{"location":"Files/reference__system_2CMakeLists_8txt/#functions","text":"Name cmake_minimum_required (VERSION 3. 5) INTERFACE target_include_directories ( ${PROJECT_NAME} INTERFACE $< BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include > $< INSTALL_INTERFACE:include >) find_package (ament_lint_auto REQUIRED) ament_target_dependencies (test_sample_management reference_interfaces) ament_add_gtest (test_reference_system_rclcpp test/test_fixtures.hpp test/test_reference_system_rclcpp. cpp) ament_target_dependencies (test_reference_system_rclcpp reference_interfaces rclcpp)","title":"Functions"},{"location":"Files/reference__system_2CMakeLists_8txt/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/reference__system_2CMakeLists_8txt/#function-cmake_minimum_required","text":"cmake_minimum_required( VERSION 3. 5 )","title":"function cmake_minimum_required"},{"location":"Files/reference__system_2CMakeLists_8txt/#function-target_include_directories","text":"INTERFACE target_include_directories( ${PROJECT_NAME} INTERFACE $< BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include > $< INSTALL_INTERFACE:include > )","title":"function target_include_directories"},{"location":"Files/reference__system_2CMakeLists_8txt/#function-find_package","text":"find_package( ament_lint_auto REQUIRED )","title":"function find_package"},{"location":"Files/reference__system_2CMakeLists_8txt/#function-ament_target_dependencies","text":"ament_target_dependencies( test_sample_management reference_interfaces )","title":"function ament_target_dependencies"},{"location":"Files/reference__system_2CMakeLists_8txt/#function-ament_add_gtest","text":"ament_add_gtest( test_reference_system_rclcpp test/test_fixtures.hpp test/test_reference_system_rclcpp. cpp )","title":"function ament_add_gtest"},{"location":"Files/reference__system_2CMakeLists_8txt/#function-ament_target_dependencies_1","text":"ament_target_dependencies( test_reference_system_rclcpp reference_interfaces rclcpp )","title":"function ament_target_dependencies"},{"location":"Files/reference__system_2CMakeLists_8txt/#source-code","text":"cmake_minimum_required(VERSION 3.5) project(reference_system VERSION 0.0.1 ) if(NOT CMAKE_CXX_STANDARD) set(CMAKE_CXX_STANDARD 17) endif() if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\") add_compile_options(-Wall -Wextra -Wpedantic) endif() find_package(ament_cmake_auto REQUIRED) ament_auto_find_build_dependencies() # Add header-only library add_library(${PROJECT_NAME} INTERFACE) target_include_directories(${PROJECT_NAME} INTERFACE $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include> $<INSTALL_INTERFACE:include> ) if(${BUILD_TESTING}) find_package(ament_lint_auto REQUIRED) ament_lint_auto_find_test_dependencies() find_package(ament_cmake_gtest) # unit tests ament_add_gtest(test_sample_management test/test_sample_management.cpp) target_link_libraries(test_sample_management ${PROJECT_NAME}) ament_target_dependencies(test_sample_management reference_interfaces) ament_add_gtest(test_number_cruncher test/test_number_cruncher.cpp) target_link_libraries(test_number_cruncher ${PROJECT_NAME}) # integration tests ament_add_gtest(test_reference_system_rclcpp test/test_fixtures.hpp test/test_reference_system_rclcpp.cpp) target_link_libraries(test_reference_system_rclcpp ${PROJECT_NAME}) ament_target_dependencies(test_reference_system_rclcpp reference_interfaces rclcpp) endif() # Install install(TARGETS ${PROJECT_NAME} EXPORT \"export_${PROJECT_NAME}\" ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR} LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR} RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR} INCLUDES DESTINATION include ) ament_export_targets(\"export_${PROJECT_NAME}\") ament_auto_package() Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/reference__system_2README_8md/","text":"README.md Source code # reference_system This package holds the core node definitions that can be used to build various reference systems that can end up being quite complex. These _reference systems_ can then be used to benchmark, test and evaluate various changes to the core middleware being used (e.g. executors, QoS settings, DDSs', etc.). See [autoware_reference_system](../autoware_reference_system/) as an example as to how one could use these nodes to build a simulated real-world system for benchmarking and testing purposes. Updated on 2021-12-24 at 17:45:36 +0000","title":"README.md"},{"location":"Files/reference__system_2README_8md/#readmemd","text":"","title":"README.md"},{"location":"Files/reference__system_2README_8md/#source-code","text":"# reference_system This package holds the core node definitions that can be used to build various reference systems that can end up being quite complex. These _reference systems_ can then be used to benchmark, test and evaluate various changes to the core middleware being used (e.g. executors, QoS settings, DDSs', etc.). See [autoware_reference_system](../autoware_reference_system/) as an example as to how one could use these nodes to build a simulated real-world system for benchmarking and testing purposes. Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/sample__management_8hpp/","text":"reference_system/include/reference_system/sample_management.hpp Classes Name struct statistic_value_t struct sample_statistic_t Functions Name bool set_benchmark_mode (const bool has_benchmark_mode, const bool set_value =true) bool is_in_benchmark_mode () uint64_t now_as_int () template <typename SampleTypePointer > void set_sample (const std::string & node_name, const uint32_t sequence_number, const uint32_t dropped_samples, const uint64_t timestamp, SampleTypePointer & sample) template <typename SampleTypePointer > uint64_t get_sample_timestamp (const SampleTypePointer & sample) template <typename SampleTypePointer > uint32_t get_sample_sequence_number (const SampleTypePointer & sample) template <typename SampleTypePointer > uint32_t get_missed_samples_and_update_seq_nr (const SampleTypePointer & sample, uint32_t & sequence_number) template <typename SampleTypePointer ,typename SourceType > void merge_history_into_sample (SampleTypePointer & sample, const SourceType & source) std::ostream & operator<< (std::ostream & output, const statistic_value_t & v) template <typename SampleTypePointer > void print_sample_path (const std::string & node_name, const uint32_t lost_samples, const SampleTypePointer & sample) Functions Documentation function set_benchmark_mode bool set_benchmark_mode( const bool has_benchmark_mode, const bool set_value =true ) function is_in_benchmark_mode bool is_in_benchmark_mode() function now_as_int uint64_t now_as_int() function set_sample template <typename SampleTypePointer > void set_sample( const std::string & node_name, const uint32_t sequence_number, const uint32_t dropped_samples, const uint64_t timestamp, SampleTypePointer & sample ) function get_sample_timestamp template <typename SampleTypePointer > uint64_t get_sample_timestamp( const SampleTypePointer & sample ) function get_sample_sequence_number template <typename SampleTypePointer > uint32_t get_sample_sequence_number( const SampleTypePointer & sample ) function get_missed_samples_and_update_seq_nr template <typename SampleTypePointer > uint32_t get_missed_samples_and_update_seq_nr( const SampleTypePointer & sample, uint32_t & sequence_number ) function merge_history_into_sample template <typename SampleTypePointer , typename SourceType > void merge_history_into_sample( SampleTypePointer & sample, const SourceType & source ) function operator<< std::ostream & operator<<( std::ostream & output, const statistic_value_t & v ) function print_sample_path template <typename SampleTypePointer > void print_sample_path( const std::string & node_name, const uint32_t lost_samples, const SampleTypePointer & sample ) Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__SAMPLE_MANAGEMENT_HPP_ #define REFERENCE_SYSTEM__SAMPLE_MANAGEMENT_HPP_ #include <algorithm> #include <chrono> #include <cmath> #include <map> #include <string> #include <iostream> #include <vector> #include <limits> #include <mutex> #include \"reference_system/msg_types.hpp\" bool set_benchmark_mode(const bool has_benchmark_mode, const bool set_value = true) { static bool value{false}; if (set_value) {value = has_benchmark_mode;} return value; } bool is_in_benchmark_mode() { return set_benchmark_mode(false, false); } uint64_t now_as_int() { return static_cast<uint64_t>( std::chrono::duration_cast<std::chrono::nanoseconds>( std::chrono::system_clock::now().time_since_epoch()) .count()); } template<typename SampleTypePointer> void set_sample( const std::string & node_name, const uint32_t sequence_number, const uint32_t dropped_samples, const uint64_t timestamp, SampleTypePointer & sample) { if (is_in_benchmark_mode() ) {return;} if (sample.size >= message_t::STATS_CAPACITY) { return; } uint64_t idx = sample.size; ++sample.size; memcpy( sample.stats[idx].node_name.data(), node_name.data(), std::min( node_name.size(), reference_interfaces::msg::TransmissionStats::NODE_NAME_LENGTH)); sample.stats[idx].timestamp = timestamp; sample.stats[idx].sequence_number = sequence_number; sample.stats[idx].dropped_samples = dropped_samples; } template<typename SampleTypePointer> uint64_t get_sample_timestamp(const SampleTypePointer & sample) { if (is_in_benchmark_mode() || sample->size == 0) { return 0; } else { return sample->stats[sample->size - 1].timestamp; } } template<typename SampleTypePointer> uint32_t get_sample_sequence_number(const SampleTypePointer & sample) { if (is_in_benchmark_mode() || sample->size == 0) { return 0; } else { return sample->stats[sample->size - 1].sequence_number; } } template<typename SampleTypePointer> uint32_t get_missed_samples_and_update_seq_nr( const SampleTypePointer & sample, uint32_t & sequence_number) { uint32_t updated_seq_nr = get_sample_sequence_number(sample); uint32_t missed_samples = (updated_seq_nr > sequence_number) ? updated_seq_nr - sequence_number - 1 : 0; sequence_number = updated_seq_nr; return missed_samples; } template<typename SampleTypePointer, typename SourceType> void merge_history_into_sample(SampleTypePointer & sample, const SourceType & source) { if (is_in_benchmark_mode()) {return;} std::vector<uint64_t> entries_to_add; for (uint64_t i = 0; i < source->size; ++i) { bool entry_found = false; std::string source_name((const char *)source->stats[i].node_name.data()); for (uint64_t k = 0; k < sample.size; ++k) { std::string sample_name((const char *)sample.stats[k].node_name.data()); if (source_name == sample_name) { entry_found = true; break; } } if (!entry_found) {entries_to_add.emplace_back(i);} } for (auto i : entries_to_add) { memcpy( sample.stats.data() + sample.size, source->stats.data() + i, sizeof(reference_interfaces::msg::TransmissionStats)); ++sample.size; } } struct statistic_value_t { double average = 0.0; double deviation = 0.0; uint64_t min = std::numeric_limits<uint64_t>::max(); uint64_t max = 0; uint64_t current = 0; uint64_t total_number = 0; std::string suffix; double adjustment = 0.0; double m2 = 0.0; void set(const uint64_t value) { // Use Welford's online algorithm to calculate deviation ++total_number; current = value; auto previous_delta = value - average; average += previous_delta / total_number; auto new_delta = value - average; m2 += (previous_delta * new_delta); deviation = sqrt(m2 / (total_number - 1)); min = std::min(min, value); max = std::max(max, value); } }; struct sample_statistic_t { uint64_t timepoint_of_first_received_sample = 0; uint32_t previous_behavior_planner_sequence = 0; uint64_t previous_behavior_planner_time_stamp = 0; statistic_value_t latency; statistic_value_t hot_path_latency; statistic_value_t behavior_planner_period; }; std::ostream & operator<<(std::ostream & output, const statistic_value_t & v) { if (v.adjustment == 0.0) { output << v.current << v.suffix << \" [min=\" << v.min << v.suffix << \", max=\" << v.max << v.suffix << \", average=\" << v.average << v.suffix << \", deviation=\" << v.deviation << \"]\"; } else { output << static_cast<double>(v.current) / v.adjustment << v.suffix << \" [min=\" << static_cast<double>(v.min) / v.adjustment << v.suffix << \", max=\" << static_cast<double>(v.max) / v.adjustment << v.suffix << \", average=\" << v.average / v.adjustment << v.suffix << \", deviation=\" << v.deviation / v.adjustment << v.suffix << \"]\"; } return output; } template<typename SampleTypePointer> void print_sample_path( const std::string & node_name, const uint32_t lost_samples, const SampleTypePointer & sample) { static int benchmark_counter = 0; ++benchmark_counter; // benchmark_counter = dismissing first 100 samples to get rid of startup jitter if (is_in_benchmark_mode() || sample->size <= 0 || benchmark_counter < 10) {return;} static std::map<std::string, sample_statistic_t> advanced_statistics; static std::map<std::string, std::map<std::string, statistic_value_t>> dropped_samples; auto iter = advanced_statistics.find(node_name); if (iter == advanced_statistics.end() ) { advanced_statistics[node_name].timepoint_of_first_received_sample = std::chrono::duration_cast<std::chrono::nanoseconds>( std::chrono::system_clock::now().time_since_epoch()).count(); advanced_statistics[node_name].latency.suffix = \"ms\"; advanced_statistics[node_name].latency.adjustment = 1000000.0; advanced_statistics[node_name].hot_path_latency.suffix = \"ms\"; advanced_statistics[node_name].hot_path_latency.adjustment = 1000000.0; advanced_statistics[node_name].behavior_planner_period.suffix = \"ms\"; advanced_statistics[node_name].behavior_planner_period.adjustment = 1000000.0; } const uint64_t timestamp_in_ns = static_cast<uint64_t>( std::chrono::duration_cast<std::chrono::nanoseconds>( std::chrono::system_clock::now().time_since_epoch()) .count()); static std::mutex cout_mutex; std::lock_guard<std::mutex> lock(cout_mutex); std::cout << \"----------------------------------------------------------\" << std::endl; std::cout << \"sample path: \" << std::endl; std::cout << \" order timepoint sequence nr. node name dropped samples\" << std::endl; std::map<uint64_t, uint64_t> timestamp2Order; uint64_t min_time_stamp = std::numeric_limits<uint64_t>::max(); for (uint64_t i = 0; i < sample->size; ++i) { timestamp2Order[sample->stats[i].timestamp] = 0; min_time_stamp = std::min(min_time_stamp, sample->stats[i].timestamp); } uint64_t i = 0; for (auto & e : timestamp2Order) { e.second = i++; } for (uint64_t i = 0; i < sample->size; ++i) { std::string name((const char *)sample->stats[i].node_name.data()); std::cout << \" [\"; std::cout.width(2); std::cout << timestamp2Order[sample->stats[i].timestamp]; std::cout << \"] \" << sample->stats[i].timestamp << \" \"; std::cout.width(10); std::cout << sample->stats[i].sequence_number; std::cout << \" \"; std::cout.width(24); std::cout << name; std::cout << \" \"; dropped_samples[node_name][name].set(sample->stats[i].dropped_samples); std::cout << dropped_samples[node_name][name]; std::cout << std::endl; } std::cout << \" [\"; std::cout.width(2); std::cout << timestamp2Order.size(); std::cout << \"] \" << timestamp_in_ns << \" \"; std::cout.width(10); std::cout << \"endpoint\"; std::cout << \" \"; std::cout.width(24); std::cout << node_name; std::cout << \" \"; dropped_samples[node_name][node_name].set(lost_samples); std::cout << dropped_samples[node_name][node_name]; std::cout << std::endl; // hot path latency uint64_t hot_path_latency_in_ns = 0; bool does_contain_hot_path = false; uint64_t lidar_timestamp = 0; for (uint64_t i = 0; i < sample->size; ++i) { uint64_t idx = sample->size - i - 1; std::string current_node_name( reinterpret_cast<const char *>(sample->stats[idx].node_name.data())); if (current_node_name == \"ObjectCollisionEstimator\") { hot_path_latency_in_ns = sample->stats[idx].timestamp; does_contain_hot_path = true; } else if (current_node_name == \"FrontLidarDriver\") { lidar_timestamp = std::max(lidar_timestamp, sample->stats[idx].timestamp); } else if (current_node_name == \"RearLidarDriver\") { lidar_timestamp = std::max(lidar_timestamp, sample->stats[idx].timestamp); } } hot_path_latency_in_ns -= lidar_timestamp; // hot path drops uint64_t hot_path_drops = 0; if (does_contain_hot_path) { for (uint64_t i = 0; i < sample->size; ++i) { uint64_t idx = sample->size - i - 1; std::string current_node_name( reinterpret_cast<const char *>(sample->stats[idx].node_name.data())); if (current_node_name == \"ObjectCollisionEstimator\" || current_node_name == \"FrontLidarDriver\" || current_node_name == \"PointsTransformerFront\" || current_node_name == \"PointCloudFusion\" || current_node_name == \"RayGroundFilter\" || current_node_name == \"EuclideanClusterDetector\") { hot_path_drops += sample->stats[idx].dropped_samples; } } } // behavior planner cycle time bool does_contain_behavior_planner = false; for (uint64_t i = 0; i < sample->size; ++i) { std::string current_node_name( reinterpret_cast<const char *>(sample->stats[i].node_name.data())); if (current_node_name == \"BehaviorPlanner\") { does_contain_behavior_planner = true; auto seq_nr = sample->stats[i].sequence_number; auto timestamp = sample->stats[i].timestamp; auto prev_seq_nr = advanced_statistics[node_name].previous_behavior_planner_sequence; auto prev_timestamp = advanced_statistics[node_name].previous_behavior_planner_time_stamp; if (prev_timestamp != 0) { advanced_statistics[node_name].behavior_planner_period.set( static_cast<double>(timestamp - prev_timestamp) / static_cast<double>(seq_nr - prev_seq_nr)); } advanced_statistics[node_name].previous_behavior_planner_sequence = seq_nr; advanced_statistics[node_name].previous_behavior_planner_time_stamp = timestamp; } } advanced_statistics[node_name].latency.set(timestamp_in_ns - min_time_stamp); std::cout << std::endl; std::cout << \"Statistics:\" << std::endl; std::cout << \" latency: \" << advanced_statistics[node_name].latency << std::endl; if (does_contain_hot_path) { dropped_samples[node_name][\"hotpath\"].set(hot_path_drops); advanced_statistics[node_name].hot_path_latency.set(hot_path_latency_in_ns); std::cout << \" hot path: \" << \\ \"FrontLidarDriver/RearLidarDriver (latest) -> ObjectCollisionEstimator\" << std::endl; std::cout << \" hot path latency: \" << advanced_statistics[node_name].hot_path_latency << std::endl; std::cout << \" hot path drops: \" << dropped_samples[node_name][\"hotpath\"] << std::endl; } if (does_contain_behavior_planner) { std::cout << \" behavior planner period: \" << advanced_statistics[node_name].behavior_planner_period << std::endl; } std::cout << \"----------------------------------------------------------\" << std::endl; std::cout << std::endl; } #endif // REFERENCE_SYSTEM__SAMPLE_MANAGEMENT_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_system/include/reference_system/sample_management.hpp"},{"location":"Files/sample__management_8hpp/#reference_systemincludereference_systemsample_managementhpp","text":"","title":"reference_system/include/reference_system/sample_management.hpp"},{"location":"Files/sample__management_8hpp/#classes","text":"Name struct statistic_value_t struct sample_statistic_t","title":"Classes"},{"location":"Files/sample__management_8hpp/#functions","text":"Name bool set_benchmark_mode (const bool has_benchmark_mode, const bool set_value =true) bool is_in_benchmark_mode () uint64_t now_as_int () template <typename SampleTypePointer > void set_sample (const std::string & node_name, const uint32_t sequence_number, const uint32_t dropped_samples, const uint64_t timestamp, SampleTypePointer & sample) template <typename SampleTypePointer > uint64_t get_sample_timestamp (const SampleTypePointer & sample) template <typename SampleTypePointer > uint32_t get_sample_sequence_number (const SampleTypePointer & sample) template <typename SampleTypePointer > uint32_t get_missed_samples_and_update_seq_nr (const SampleTypePointer & sample, uint32_t & sequence_number) template <typename SampleTypePointer ,typename SourceType > void merge_history_into_sample (SampleTypePointer & sample, const SourceType & source) std::ostream & operator<< (std::ostream & output, const statistic_value_t & v) template <typename SampleTypePointer > void print_sample_path (const std::string & node_name, const uint32_t lost_samples, const SampleTypePointer & sample)","title":"Functions"},{"location":"Files/sample__management_8hpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/sample__management_8hpp/#function-set_benchmark_mode","text":"bool set_benchmark_mode( const bool has_benchmark_mode, const bool set_value =true )","title":"function set_benchmark_mode"},{"location":"Files/sample__management_8hpp/#function-is_in_benchmark_mode","text":"bool is_in_benchmark_mode()","title":"function is_in_benchmark_mode"},{"location":"Files/sample__management_8hpp/#function-now_as_int","text":"uint64_t now_as_int()","title":"function now_as_int"},{"location":"Files/sample__management_8hpp/#function-set_sample","text":"template <typename SampleTypePointer > void set_sample( const std::string & node_name, const uint32_t sequence_number, const uint32_t dropped_samples, const uint64_t timestamp, SampleTypePointer & sample )","title":"function set_sample"},{"location":"Files/sample__management_8hpp/#function-get_sample_timestamp","text":"template <typename SampleTypePointer > uint64_t get_sample_timestamp( const SampleTypePointer & sample )","title":"function get_sample_timestamp"},{"location":"Files/sample__management_8hpp/#function-get_sample_sequence_number","text":"template <typename SampleTypePointer > uint32_t get_sample_sequence_number( const SampleTypePointer & sample )","title":"function get_sample_sequence_number"},{"location":"Files/sample__management_8hpp/#function-get_missed_samples_and_update_seq_nr","text":"template <typename SampleTypePointer > uint32_t get_missed_samples_and_update_seq_nr( const SampleTypePointer & sample, uint32_t & sequence_number )","title":"function get_missed_samples_and_update_seq_nr"},{"location":"Files/sample__management_8hpp/#function-merge_history_into_sample","text":"template <typename SampleTypePointer , typename SourceType > void merge_history_into_sample( SampleTypePointer & sample, const SourceType & source )","title":"function merge_history_into_sample"},{"location":"Files/sample__management_8hpp/#function-operator","text":"std::ostream & operator<<( std::ostream & output, const statistic_value_t & v )","title":"function operator&lt;&lt;"},{"location":"Files/sample__management_8hpp/#function-print_sample_path","text":"template <typename SampleTypePointer > void print_sample_path( const std::string & node_name, const uint32_t lost_samples, const SampleTypePointer & sample )","title":"function print_sample_path"},{"location":"Files/sample__management_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__SAMPLE_MANAGEMENT_HPP_ #define REFERENCE_SYSTEM__SAMPLE_MANAGEMENT_HPP_ #include <algorithm> #include <chrono> #include <cmath> #include <map> #include <string> #include <iostream> #include <vector> #include <limits> #include <mutex> #include \"reference_system/msg_types.hpp\" bool set_benchmark_mode(const bool has_benchmark_mode, const bool set_value = true) { static bool value{false}; if (set_value) {value = has_benchmark_mode;} return value; } bool is_in_benchmark_mode() { return set_benchmark_mode(false, false); } uint64_t now_as_int() { return static_cast<uint64_t>( std::chrono::duration_cast<std::chrono::nanoseconds>( std::chrono::system_clock::now().time_since_epoch()) .count()); } template<typename SampleTypePointer> void set_sample( const std::string & node_name, const uint32_t sequence_number, const uint32_t dropped_samples, const uint64_t timestamp, SampleTypePointer & sample) { if (is_in_benchmark_mode() ) {return;} if (sample.size >= message_t::STATS_CAPACITY) { return; } uint64_t idx = sample.size; ++sample.size; memcpy( sample.stats[idx].node_name.data(), node_name.data(), std::min( node_name.size(), reference_interfaces::msg::TransmissionStats::NODE_NAME_LENGTH)); sample.stats[idx].timestamp = timestamp; sample.stats[idx].sequence_number = sequence_number; sample.stats[idx].dropped_samples = dropped_samples; } template<typename SampleTypePointer> uint64_t get_sample_timestamp(const SampleTypePointer & sample) { if (is_in_benchmark_mode() || sample->size == 0) { return 0; } else { return sample->stats[sample->size - 1].timestamp; } } template<typename SampleTypePointer> uint32_t get_sample_sequence_number(const SampleTypePointer & sample) { if (is_in_benchmark_mode() || sample->size == 0) { return 0; } else { return sample->stats[sample->size - 1].sequence_number; } } template<typename SampleTypePointer> uint32_t get_missed_samples_and_update_seq_nr( const SampleTypePointer & sample, uint32_t & sequence_number) { uint32_t updated_seq_nr = get_sample_sequence_number(sample); uint32_t missed_samples = (updated_seq_nr > sequence_number) ? updated_seq_nr - sequence_number - 1 : 0; sequence_number = updated_seq_nr; return missed_samples; } template<typename SampleTypePointer, typename SourceType> void merge_history_into_sample(SampleTypePointer & sample, const SourceType & source) { if (is_in_benchmark_mode()) {return;} std::vector<uint64_t> entries_to_add; for (uint64_t i = 0; i < source->size; ++i) { bool entry_found = false; std::string source_name((const char *)source->stats[i].node_name.data()); for (uint64_t k = 0; k < sample.size; ++k) { std::string sample_name((const char *)sample.stats[k].node_name.data()); if (source_name == sample_name) { entry_found = true; break; } } if (!entry_found) {entries_to_add.emplace_back(i);} } for (auto i : entries_to_add) { memcpy( sample.stats.data() + sample.size, source->stats.data() + i, sizeof(reference_interfaces::msg::TransmissionStats)); ++sample.size; } } struct statistic_value_t { double average = 0.0; double deviation = 0.0; uint64_t min = std::numeric_limits<uint64_t>::max(); uint64_t max = 0; uint64_t current = 0; uint64_t total_number = 0; std::string suffix; double adjustment = 0.0; double m2 = 0.0; void set(const uint64_t value) { // Use Welford's online algorithm to calculate deviation ++total_number; current = value; auto previous_delta = value - average; average += previous_delta / total_number; auto new_delta = value - average; m2 += (previous_delta * new_delta); deviation = sqrt(m2 / (total_number - 1)); min = std::min(min, value); max = std::max(max, value); } }; struct sample_statistic_t { uint64_t timepoint_of_first_received_sample = 0; uint32_t previous_behavior_planner_sequence = 0; uint64_t previous_behavior_planner_time_stamp = 0; statistic_value_t latency; statistic_value_t hot_path_latency; statistic_value_t behavior_planner_period; }; std::ostream & operator<<(std::ostream & output, const statistic_value_t & v) { if (v.adjustment == 0.0) { output << v.current << v.suffix << \" [min=\" << v.min << v.suffix << \", max=\" << v.max << v.suffix << \", average=\" << v.average << v.suffix << \", deviation=\" << v.deviation << \"]\"; } else { output << static_cast<double>(v.current) / v.adjustment << v.suffix << \" [min=\" << static_cast<double>(v.min) / v.adjustment << v.suffix << \", max=\" << static_cast<double>(v.max) / v.adjustment << v.suffix << \", average=\" << v.average / v.adjustment << v.suffix << \", deviation=\" << v.deviation / v.adjustment << v.suffix << \"]\"; } return output; } template<typename SampleTypePointer> void print_sample_path( const std::string & node_name, const uint32_t lost_samples, const SampleTypePointer & sample) { static int benchmark_counter = 0; ++benchmark_counter; // benchmark_counter = dismissing first 100 samples to get rid of startup jitter if (is_in_benchmark_mode() || sample->size <= 0 || benchmark_counter < 10) {return;} static std::map<std::string, sample_statistic_t> advanced_statistics; static std::map<std::string, std::map<std::string, statistic_value_t>> dropped_samples; auto iter = advanced_statistics.find(node_name); if (iter == advanced_statistics.end() ) { advanced_statistics[node_name].timepoint_of_first_received_sample = std::chrono::duration_cast<std::chrono::nanoseconds>( std::chrono::system_clock::now().time_since_epoch()).count(); advanced_statistics[node_name].latency.suffix = \"ms\"; advanced_statistics[node_name].latency.adjustment = 1000000.0; advanced_statistics[node_name].hot_path_latency.suffix = \"ms\"; advanced_statistics[node_name].hot_path_latency.adjustment = 1000000.0; advanced_statistics[node_name].behavior_planner_period.suffix = \"ms\"; advanced_statistics[node_name].behavior_planner_period.adjustment = 1000000.0; } const uint64_t timestamp_in_ns = static_cast<uint64_t>( std::chrono::duration_cast<std::chrono::nanoseconds>( std::chrono::system_clock::now().time_since_epoch()) .count()); static std::mutex cout_mutex; std::lock_guard<std::mutex> lock(cout_mutex); std::cout << \"----------------------------------------------------------\" << std::endl; std::cout << \"sample path: \" << std::endl; std::cout << \" order timepoint sequence nr. node name dropped samples\" << std::endl; std::map<uint64_t, uint64_t> timestamp2Order; uint64_t min_time_stamp = std::numeric_limits<uint64_t>::max(); for (uint64_t i = 0; i < sample->size; ++i) { timestamp2Order[sample->stats[i].timestamp] = 0; min_time_stamp = std::min(min_time_stamp, sample->stats[i].timestamp); } uint64_t i = 0; for (auto & e : timestamp2Order) { e.second = i++; } for (uint64_t i = 0; i < sample->size; ++i) { std::string name((const char *)sample->stats[i].node_name.data()); std::cout << \" [\"; std::cout.width(2); std::cout << timestamp2Order[sample->stats[i].timestamp]; std::cout << \"] \" << sample->stats[i].timestamp << \" \"; std::cout.width(10); std::cout << sample->stats[i].sequence_number; std::cout << \" \"; std::cout.width(24); std::cout << name; std::cout << \" \"; dropped_samples[node_name][name].set(sample->stats[i].dropped_samples); std::cout << dropped_samples[node_name][name]; std::cout << std::endl; } std::cout << \" [\"; std::cout.width(2); std::cout << timestamp2Order.size(); std::cout << \"] \" << timestamp_in_ns << \" \"; std::cout.width(10); std::cout << \"endpoint\"; std::cout << \" \"; std::cout.width(24); std::cout << node_name; std::cout << \" \"; dropped_samples[node_name][node_name].set(lost_samples); std::cout << dropped_samples[node_name][node_name]; std::cout << std::endl; // hot path latency uint64_t hot_path_latency_in_ns = 0; bool does_contain_hot_path = false; uint64_t lidar_timestamp = 0; for (uint64_t i = 0; i < sample->size; ++i) { uint64_t idx = sample->size - i - 1; std::string current_node_name( reinterpret_cast<const char *>(sample->stats[idx].node_name.data())); if (current_node_name == \"ObjectCollisionEstimator\") { hot_path_latency_in_ns = sample->stats[idx].timestamp; does_contain_hot_path = true; } else if (current_node_name == \"FrontLidarDriver\") { lidar_timestamp = std::max(lidar_timestamp, sample->stats[idx].timestamp); } else if (current_node_name == \"RearLidarDriver\") { lidar_timestamp = std::max(lidar_timestamp, sample->stats[idx].timestamp); } } hot_path_latency_in_ns -= lidar_timestamp; // hot path drops uint64_t hot_path_drops = 0; if (does_contain_hot_path) { for (uint64_t i = 0; i < sample->size; ++i) { uint64_t idx = sample->size - i - 1; std::string current_node_name( reinterpret_cast<const char *>(sample->stats[idx].node_name.data())); if (current_node_name == \"ObjectCollisionEstimator\" || current_node_name == \"FrontLidarDriver\" || current_node_name == \"PointsTransformerFront\" || current_node_name == \"PointCloudFusion\" || current_node_name == \"RayGroundFilter\" || current_node_name == \"EuclideanClusterDetector\") { hot_path_drops += sample->stats[idx].dropped_samples; } } } // behavior planner cycle time bool does_contain_behavior_planner = false; for (uint64_t i = 0; i < sample->size; ++i) { std::string current_node_name( reinterpret_cast<const char *>(sample->stats[i].node_name.data())); if (current_node_name == \"BehaviorPlanner\") { does_contain_behavior_planner = true; auto seq_nr = sample->stats[i].sequence_number; auto timestamp = sample->stats[i].timestamp; auto prev_seq_nr = advanced_statistics[node_name].previous_behavior_planner_sequence; auto prev_timestamp = advanced_statistics[node_name].previous_behavior_planner_time_stamp; if (prev_timestamp != 0) { advanced_statistics[node_name].behavior_planner_period.set( static_cast<double>(timestamp - prev_timestamp) / static_cast<double>(seq_nr - prev_seq_nr)); } advanced_statistics[node_name].previous_behavior_planner_sequence = seq_nr; advanced_statistics[node_name].previous_behavior_planner_time_stamp = timestamp; } } advanced_statistics[node_name].latency.set(timestamp_in_ns - min_time_stamp); std::cout << std::endl; std::cout << \"Statistics:\" << std::endl; std::cout << \" latency: \" << advanced_statistics[node_name].latency << std::endl; if (does_contain_hot_path) { dropped_samples[node_name][\"hotpath\"].set(hot_path_drops); advanced_statistics[node_name].hot_path_latency.set(hot_path_latency_in_ns); std::cout << \" hot path: \" << \\ \"FrontLidarDriver/RearLidarDriver (latest) -> ObjectCollisionEstimator\" << std::endl; std::cout << \" hot path latency: \" << advanced_statistics[node_name].hot_path_latency << std::endl; std::cout << \" hot path drops: \" << dropped_samples[node_name][\"hotpath\"] << std::endl; } if (does_contain_behavior_planner) { std::cout << \" behavior planner period: \" << advanced_statistics[node_name].behavior_planner_period << std::endl; } std::cout << \"----------------------------------------------------------\" << std::endl; std::cout << std::endl; } #endif // REFERENCE_SYSTEM__SAMPLE_MANAGEMENT_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/sensor_8hpp/","text":"reference_system/include/reference_system/nodes/rclcpp/sensor.hpp Namespaces Name nodes nodes::rclcpp_system Classes Name class nodes::rclcpp_system::Sensor Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__RCLCPP__SENSOR_HPP_ #define REFERENCE_SYSTEM__NODES__RCLCPP__SENSOR_HPP_ #include <chrono> #include <string> #include <utility> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/sample_management.hpp\" #include \"reference_system/msg_types.hpp\" namespace nodes { namespace rclcpp_system { class Sensor : public rclcpp::Node { public: explicit Sensor(const SensorSettings & settings) : Node(settings.node_name) { publisher_ = this->create_publisher<message_t>(settings.topic_name, 1); timer_ = this->create_wall_timer( settings.cycle_time, [this] {timer_callback();}); } private: void timer_callback() { uint64_t timestamp = now_as_int(); auto message = publisher_->borrow_loaned_message(); message.get().size = 0; set_sample(this->get_name(), sequence_number_++, 0, timestamp, message.get()); publisher_->publish(std::move(message)); } private: rclcpp::Publisher<message_t>::SharedPtr publisher_; rclcpp::TimerBase::SharedPtr timer_; uint32_t sequence_number_ = 0; }; } // namespace rclcpp_system } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__RCLCPP__SENSOR_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_system/include/reference_system/nodes/rclcpp/sensor.hpp"},{"location":"Files/sensor_8hpp/#reference_systemincludereference_systemnodesrclcppsensorhpp","text":"","title":"reference_system/include/reference_system/nodes/rclcpp/sensor.hpp"},{"location":"Files/sensor_8hpp/#namespaces","text":"Name nodes nodes::rclcpp_system","title":"Namespaces"},{"location":"Files/sensor_8hpp/#classes","text":"Name class nodes::rclcpp_system::Sensor","title":"Classes"},{"location":"Files/sensor_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__RCLCPP__SENSOR_HPP_ #define REFERENCE_SYSTEM__NODES__RCLCPP__SENSOR_HPP_ #include <chrono> #include <string> #include <utility> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/sample_management.hpp\" #include \"reference_system/msg_types.hpp\" namespace nodes { namespace rclcpp_system { class Sensor : public rclcpp::Node { public: explicit Sensor(const SensorSettings & settings) : Node(settings.node_name) { publisher_ = this->create_publisher<message_t>(settings.topic_name, 1); timer_ = this->create_wall_timer( settings.cycle_time, [this] {timer_callback();}); } private: void timer_callback() { uint64_t timestamp = now_as_int(); auto message = publisher_->borrow_loaned_message(); message.get().size = 0; set_sample(this->get_name(), sequence_number_++, 0, timestamp, message.get()); publisher_->publish(std::move(message)); } private: rclcpp::Publisher<message_t>::SharedPtr publisher_; rclcpp::TimerBase::SharedPtr timer_; uint32_t sequence_number_ = 0; }; } // namespace rclcpp_system } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__RCLCPP__SENSOR_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/settings_8hpp/","text":"reference_system/include/reference_system/nodes/settings.hpp Namespaces Name nodes Classes Name struct nodes::CommandSettings struct nodes::FusionSettings struct nodes::TransformSettings struct nodes::IntersectionSettings struct nodes::IntersectionSettings::Connection struct nodes::CyclicSettings struct nodes::SensorSettings Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__SETTINGS_HPP_ #define REFERENCE_SYSTEM__NODES__SETTINGS_HPP_ #include <chrono> #include <string> #include <vector> namespace nodes { struct CommandSettings { std::string node_name; std::string input_topic; }; struct FusionSettings { std::string node_name; std::string input_0; std::string input_1; std::string output_topic; uint64_t number_crunch_limit; }; struct TransformSettings { std::string node_name; std::string input_topic; std::string output_topic; uint64_t number_crunch_limit; }; struct IntersectionSettings { struct Connection { std::string input_topic; std::string output_topic; uint64_t number_crunch_limit; }; std::string node_name; std::vector<Connection> connections; }; struct CyclicSettings { std::string node_name; std::vector<std::string> inputs; std::string output_topic; uint64_t number_crunch_limit; std::chrono::nanoseconds cycle_time; }; struct SensorSettings { std::string node_name; std::string topic_name; std::chrono::nanoseconds cycle_time; }; } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__SETTINGS_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_system/include/reference_system/nodes/settings.hpp"},{"location":"Files/settings_8hpp/#reference_systemincludereference_systemnodessettingshpp","text":"","title":"reference_system/include/reference_system/nodes/settings.hpp"},{"location":"Files/settings_8hpp/#namespaces","text":"Name nodes","title":"Namespaces"},{"location":"Files/settings_8hpp/#classes","text":"Name struct nodes::CommandSettings struct nodes::FusionSettings struct nodes::TransformSettings struct nodes::IntersectionSettings struct nodes::IntersectionSettings::Connection struct nodes::CyclicSettings struct nodes::SensorSettings","title":"Classes"},{"location":"Files/settings_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__SETTINGS_HPP_ #define REFERENCE_SYSTEM__NODES__SETTINGS_HPP_ #include <chrono> #include <string> #include <vector> namespace nodes { struct CommandSettings { std::string node_name; std::string input_topic; }; struct FusionSettings { std::string node_name; std::string input_0; std::string input_1; std::string output_topic; uint64_t number_crunch_limit; }; struct TransformSettings { std::string node_name; std::string input_topic; std::string output_topic; uint64_t number_crunch_limit; }; struct IntersectionSettings { struct Connection { std::string input_topic; std::string output_topic; uint64_t number_crunch_limit; }; std::string node_name; std::vector<Connection> connections; }; struct CyclicSettings { std::string node_name; std::vector<std::string> inputs; std::string output_topic; uint64_t number_crunch_limit; std::chrono::nanoseconds cycle_time; }; struct SensorSettings { std::string node_name; std::string topic_name; std::chrono::nanoseconds cycle_time; }; } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__SETTINGS_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/std__latency_8py/","text":"autoware_reference_system/test/std_latency.py Namespaces Name std_latency Source code # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from bokeh.models import ColumnDataSource from bokeh.models.ranges import FactorRange from bokeh.models.tools import HoverTool from bokeh.models.widgets.markups import Div from bokeh.models.widgets.tables import DataTable, TableColumn from bokeh.palettes import cividis from bokeh.plotting import figure from bokeh.transform import factor_cmap from constants import SIZE_AXIS_LABEL, SIZE_CATEGORY_LABEL, SIZE_MAJOR_LABEL, SIZE_TITLE from constants import SIZE_TABLE_ROW, SIZE_TABLE_WIDTH import pandas as pd def summary(path, duration, size): data, test_name, hot_path_name = parseLogSummary(path, duration) x = [] all_data = { 'exe': [], 'rmw': [], 'type': [], 'low': [], 'mean': [], 'high': [], 'std_dev': [], 'top': [], 'bottom': [] } for results in data: exe = results[0] rmw = results[1] for data_type in results[2]['hot_path']: all_data['exe'].append(exe) all_data['rmw'].append(rmw) all_data['type'].append(data_type) all_data['low'].append(results[2]['hot_path'][data_type]['low']) all_data['mean'].append(results[2]['hot_path'][data_type]['mean']) all_data['high'].append(results[2]['hot_path'][data_type]['high']) all_data['std_dev'].append(results[2]['hot_path'][data_type]['std_dev']) all_data['top'].append(results[2]['hot_path'][data_type]['top']) all_data['bottom'].append(results[2]['hot_path'][data_type]['bottom']) # add behavior planner data to dataframe cyclic_node = 'behavior_planner' data_type = 'period' all_data['exe'].append(exe) all_data['rmw'].append(rmw) all_data['type'].append(data_type) all_data['low'].append(results[2][cyclic_node][data_type]['low']) all_data['mean'].append(results[2][cyclic_node][data_type]['mean']) all_data['high'].append(results[2][cyclic_node][data_type]['high']) all_data['std_dev'].append(results[2][cyclic_node][data_type]['std_dev']) all_data['top'].append(results[2][cyclic_node][data_type]['top']) all_data['bottom'].append(results[2][cyclic_node][data_type]['bottom']) df = pd.DataFrame.from_records( all_data, columns=[ 'exe', 'rmw', 'type', 'low', 'mean', 'high', 'top', 'bottom', 'std_dev']) # sort by exe and rmw df = df.sort_values(['exe', 'rmw'], ascending=True) exes = [] rmws = [] for exe in df.exe: for rmw in df.rmw: # add exe and rmw to list if exe not in exes: exes.append(exe) if rmw not in rmws: rmws.append(rmw) for exe in exes: for rmw in rmws: x.append((exe, rmw)) latency = df.type == 'latency' dropped = df.type == 'dropped' period = df.type == 'period' latency_source = ColumnDataSource(df[latency]) dropped_source = ColumnDataSource(df[dropped]) period_source = ColumnDataSource(df[period]) # add exe and rmw list of tuples for x axis latency_source.data['x'] = x dropped_source.data['x'] = x period_source.data['x'] = x # initialize list of figures std_figs = [] # initialize latency figure test_info = str(duration) + 's [' + hot_path_name + ']' latency_fig = figure( title='Latency Summary ' + test_info, x_axis_label=f'Executors (with RMW)', y_axis_label='Average Latency (ms)', x_range=FactorRange(*x), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) latency_fig.segment( x, df.high[latency].values, x, df.low[latency].values, color='black', line_width=2) latency_fig.vbar( width=0.2, x='x', top='top', bottom='bottom', line_color='black', line_width=1, source=latency_source, fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) latency_fig.scatter( size=25, x='x', y='high', source=latency_source, line_color='black', line_width=2, marker='dash', fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) latency_fig.scatter( size=25, x='x', y='low', source=latency_source, line_color='black', line_width=2, marker='dash', fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) latency_fig.y_range.start = 0 latency_fig.x_range.range_padding = 0.1 latency_fig.title.text_font_size = SIZE_TITLE latency_fig.xaxis.axis_label_text_font_size = SIZE_AXIS_LABEL latency_fig.yaxis.axis_label_text_font_size = SIZE_AXIS_LABEL latency_fig.yaxis.major_label_text_font_size = SIZE_MAJOR_LABEL latency_fig.below[0].group_text_font_size = SIZE_CATEGORY_LABEL latency_fig.below[0].major_label_text_font_size = SIZE_MAJOR_LABEL # initialize dropped message figure dropped_fig = figure( title='Dropped Messages Summary ' + test_info, x_axis_label=f'Executors (with RMW)', y_axis_label='Dropped Messages', x_range=FactorRange(*x), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) dropped_fig.segment( x, df.high[dropped].values, x, df.low[dropped].values, color='black', line_width=2) dropped_fig.vbar( width=0.2, x='x', top='mean', source=dropped_source, line_color='black', line_width=1, fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) dropped_fig.scatter( size=25, x='x', y='high', source=dropped_source, line_color='black', line_width=2, marker='dash', fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) dropped_fig.y_range.start = 0 dropped_fig.x_range.range_padding = 0.1 dropped_fig.title.text_font_size = SIZE_TITLE dropped_fig.xaxis.axis_label_text_font_size = SIZE_AXIS_LABEL dropped_fig.yaxis.axis_label_text_font_size = SIZE_AXIS_LABEL dropped_fig.yaxis.major_label_text_font_size = SIZE_MAJOR_LABEL dropped_fig.below[0].group_text_font_size = SIZE_CATEGORY_LABEL dropped_fig.below[0].major_label_text_font_size = SIZE_MAJOR_LABEL # initialize period figure period_fig = figure( title='Behavior Planner Jitter Summary ' + str(duration) + 's', x_axis_label=f'Executors (with RMW)', y_axis_label='Period (ms)', x_range=FactorRange(*x), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) period_fig.segment( x, df.high[period].values, x, df.low[period].values, color='black', line_width=2) period_fig.vbar( width=0.2, x='x', top='top', bottom='bottom', source=period_source, line_color='black', line_width=1, fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) period_fig.scatter( size=25, x='x', y='high', source=period_source, line_color='black', line_width=2, marker='dash', fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) period_fig.scatter( size=25, x='x', y='low', source=period_source, line_color='black', line_width=2, marker='dash', fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) period_fig.y_range.start = 0 period_fig.x_range.range_padding = 0.1 period_fig.title.text_font_size = SIZE_TITLE period_fig.xaxis.axis_label_text_font_size = SIZE_AXIS_LABEL period_fig.yaxis.axis_label_text_font_size = SIZE_AXIS_LABEL period_fig.yaxis.major_label_text_font_size = SIZE_MAJOR_LABEL period_fig.below[0].group_text_font_size = SIZE_CATEGORY_LABEL period_fig.below[0].major_label_text_font_size = SIZE_MAJOR_LABEL # add latency hover tool latency_hover = HoverTool() latency_hover.tooltips = [ ('Average Latency', '@{mean}{0.00}ms'), ('Minimum Latency', '@{low}{0.00}ms'), ('Maximum Latency', '@{high}{0.00}ms'), ] latency_fig.add_tools(latency_hover) # add dropped messages hover tool dropped_hover = HoverTool() dropped_hover.tooltips = [ ('Dropped Messages Average', '@{mean}{0.00}'), ('Dropped Messages Min', '@{low}{0.00}'), ('Dropped Messages Max', '@{high}{0.00}'), ] dropped_fig.add_tools(dropped_hover) # add period hover tool period_hover = HoverTool() period_hover.tooltips = [ ('Period Average', '@{mean}{0.00}ms'), ('Period Min', '@{low}{0.00}ms'), ('Period Max', '@{high}{0.00}ms'), ] period_fig.add_tools(period_hover) # add tables # create tables columns = [TableColumn(field=col, title=col) for col in df[latency].columns] latency_table_title = Div( text='<b>Latency Summary Table ' + test_info + '</b>', width=SIZE_TABLE_WIDTH, height=SIZE_TABLE_ROW) latency_table = [ latency_table_title, DataTable( columns=columns, source=ColumnDataSource(df[latency].round(decimals=3)), autosize_mode='fit_viewport', margin=(0, 10, 10, 10), height=(len(df[latency].exe.values.tolist()) * SIZE_TABLE_ROW), width=SIZE_TABLE_WIDTH)] dropped_table_title = Div( text='<b>Dropped Messages Summary Table ' + test_info + '</b>', width=SIZE_TABLE_WIDTH, height=SIZE_TABLE_ROW) dropped_table = [ dropped_table_title, DataTable( columns=columns, source=ColumnDataSource(df[dropped].round(decimals=1)), autosize_mode='fit_viewport', margin=(0, 10, 10, 10), height=(len(df[dropped].exe.values.tolist()) * SIZE_TABLE_ROW), width=SIZE_TABLE_WIDTH)] period_table_title = Div( text='<b>Behavior Planner Jitter Summary Table ' + str(duration) + 's</b>', width=SIZE_TABLE_WIDTH, height=SIZE_TABLE_ROW) period_table = [ period_table_title, DataTable( columns=columns, source=ColumnDataSource(df[period].round(decimals=3)), autosize_mode='fit_viewport', margin=(0, 10, 10, 10), height=(len(df[period].exe.values.tolist()) * SIZE_TABLE_ROW), width=SIZE_TABLE_WIDTH)] std_figs = [ [latency_table], [latency_fig], [dropped_table], [dropped_fig], [period_table], [period_fig]] return std_figs def parseLogSummary(path, duration): # open file data = open(path).read().splitlines() # hold info on each test (start line and end line) log_map = {} in_test = False test_name = '' hot_path_name = '' log_map = [] count = 0 for index, line in enumerate(data): if 'generate_std_trace' in line: if str(duration) in line: if 'Start' in line: search = ': generate_std_traces_' test_name = line[line.find(search) + len(search):line.find('.py')] rmw_idx = test_name.find('_rmw') exe = test_name[0:rmw_idx] rmw = test_name[rmw_idx + 1:test_name.rfind('_')] start_time = line[line.find('[') + 1:line.find(']') - 1] log_map.append( [exe, rmw, { 'start': start_time, 'end': 0, 'hot_path': { 'latency': {}, 'dropped': {} }, 'behavior_planner': { 'period': {} } }]) in_test = True elif 'Passed' in line: in_test = False count += 1 # if within a test, add parse current line to dataframe if in_test: if 'hot path' in line: if 'hot path:' in line: indent = ' ' hot_path_name = line[line.find('hot path:') + len('hot path:' + indent):] if 'latency' in line: end_time = line[line.find('[') + 1:line.find(']') - 1] log_map[count][2]['end'] = end_time stats = parseStats(line) if stats is not None: log_map[count][2]['hot_path']['latency'] = stats elif 'drops' in line: end_time = line[line.find('[') + 1:line.find(']') - 1] log_map[count][2]['end'] = end_time stats = parseStats(line) if stats is not None: log_map[count][2]['hot_path']['dropped'] = stats elif 'period' in line: # behavior planner period # log_map[count][2]['behavior_planner']['period'] = \\ # float(line[line.find('period') + len('period: '):line.find('ms')]) stats = parseStats(line) if stats is not None: log_map[count][2]['behavior_planner']['period'] = stats return log_map, test_name, hot_path_name def parseStats(line): # assume all stats in milliseconds stats = { 'timestamp': 0.0, 'low': 0.0, 'high': 0.0, 'mean': 0.0, 'std_dev': 0.0, 'top': 0.0, 'bottom': 0.0 } try: stats['timestamp'] = float( line[line.find('[') + 1:line.find(']') - 1]) * 1000 # convert to ms parsed_stats = line.split(',') stats['low'] = parsed_stats[0][parsed_stats[0].find('min') + len('min='):] stats['high'] = parsed_stats[1][parsed_stats[1].find('max') + len('max='):] stats['mean'] = parsed_stats[2][parsed_stats[2].find('average') + len('average='):] stats['std_dev'] = \\ parsed_stats[3][parsed_stats[3].find('deviation') + len('deviation='):-1] for val in stats: if isinstance(stats[val], str): if stats[val].endswith('ms'): stats[val] = stats[val][:-2] stats[val] = float(stats[val]) stats['top'] = stats['mean'] + stats['std_dev'] stats['bottom'] = stats['mean'] - stats['std_dev'] if stats['bottom'] < 0: stats['bottom'] = 0 except IndexError as e: print('Line incomplete:') print('[line]: ' + line) print('Returning None for this line') print(e) stats = None return stats Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/test/std_latency.py"},{"location":"Files/std__latency_8py/#autoware_reference_systemteststd_latencypy","text":"","title":"autoware_reference_system/test/std_latency.py"},{"location":"Files/std__latency_8py/#namespaces","text":"Name std_latency","title":"Namespaces"},{"location":"Files/std__latency_8py/#source-code","text":"# Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from bokeh.models import ColumnDataSource from bokeh.models.ranges import FactorRange from bokeh.models.tools import HoverTool from bokeh.models.widgets.markups import Div from bokeh.models.widgets.tables import DataTable, TableColumn from bokeh.palettes import cividis from bokeh.plotting import figure from bokeh.transform import factor_cmap from constants import SIZE_AXIS_LABEL, SIZE_CATEGORY_LABEL, SIZE_MAJOR_LABEL, SIZE_TITLE from constants import SIZE_TABLE_ROW, SIZE_TABLE_WIDTH import pandas as pd def summary(path, duration, size): data, test_name, hot_path_name = parseLogSummary(path, duration) x = [] all_data = { 'exe': [], 'rmw': [], 'type': [], 'low': [], 'mean': [], 'high': [], 'std_dev': [], 'top': [], 'bottom': [] } for results in data: exe = results[0] rmw = results[1] for data_type in results[2]['hot_path']: all_data['exe'].append(exe) all_data['rmw'].append(rmw) all_data['type'].append(data_type) all_data['low'].append(results[2]['hot_path'][data_type]['low']) all_data['mean'].append(results[2]['hot_path'][data_type]['mean']) all_data['high'].append(results[2]['hot_path'][data_type]['high']) all_data['std_dev'].append(results[2]['hot_path'][data_type]['std_dev']) all_data['top'].append(results[2]['hot_path'][data_type]['top']) all_data['bottom'].append(results[2]['hot_path'][data_type]['bottom']) # add behavior planner data to dataframe cyclic_node = 'behavior_planner' data_type = 'period' all_data['exe'].append(exe) all_data['rmw'].append(rmw) all_data['type'].append(data_type) all_data['low'].append(results[2][cyclic_node][data_type]['low']) all_data['mean'].append(results[2][cyclic_node][data_type]['mean']) all_data['high'].append(results[2][cyclic_node][data_type]['high']) all_data['std_dev'].append(results[2][cyclic_node][data_type]['std_dev']) all_data['top'].append(results[2][cyclic_node][data_type]['top']) all_data['bottom'].append(results[2][cyclic_node][data_type]['bottom']) df = pd.DataFrame.from_records( all_data, columns=[ 'exe', 'rmw', 'type', 'low', 'mean', 'high', 'top', 'bottom', 'std_dev']) # sort by exe and rmw df = df.sort_values(['exe', 'rmw'], ascending=True) exes = [] rmws = [] for exe in df.exe: for rmw in df.rmw: # add exe and rmw to list if exe not in exes: exes.append(exe) if rmw not in rmws: rmws.append(rmw) for exe in exes: for rmw in rmws: x.append((exe, rmw)) latency = df.type == 'latency' dropped = df.type == 'dropped' period = df.type == 'period' latency_source = ColumnDataSource(df[latency]) dropped_source = ColumnDataSource(df[dropped]) period_source = ColumnDataSource(df[period]) # add exe and rmw list of tuples for x axis latency_source.data['x'] = x dropped_source.data['x'] = x period_source.data['x'] = x # initialize list of figures std_figs = [] # initialize latency figure test_info = str(duration) + 's [' + hot_path_name + ']' latency_fig = figure( title='Latency Summary ' + test_info, x_axis_label=f'Executors (with RMW)', y_axis_label='Average Latency (ms)', x_range=FactorRange(*x), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) latency_fig.segment( x, df.high[latency].values, x, df.low[latency].values, color='black', line_width=2) latency_fig.vbar( width=0.2, x='x', top='top', bottom='bottom', line_color='black', line_width=1, source=latency_source, fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) latency_fig.scatter( size=25, x='x', y='high', source=latency_source, line_color='black', line_width=2, marker='dash', fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) latency_fig.scatter( size=25, x='x', y='low', source=latency_source, line_color='black', line_width=2, marker='dash', fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) latency_fig.y_range.start = 0 latency_fig.x_range.range_padding = 0.1 latency_fig.title.text_font_size = SIZE_TITLE latency_fig.xaxis.axis_label_text_font_size = SIZE_AXIS_LABEL latency_fig.yaxis.axis_label_text_font_size = SIZE_AXIS_LABEL latency_fig.yaxis.major_label_text_font_size = SIZE_MAJOR_LABEL latency_fig.below[0].group_text_font_size = SIZE_CATEGORY_LABEL latency_fig.below[0].major_label_text_font_size = SIZE_MAJOR_LABEL # initialize dropped message figure dropped_fig = figure( title='Dropped Messages Summary ' + test_info, x_axis_label=f'Executors (with RMW)', y_axis_label='Dropped Messages', x_range=FactorRange(*x), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) dropped_fig.segment( x, df.high[dropped].values, x, df.low[dropped].values, color='black', line_width=2) dropped_fig.vbar( width=0.2, x='x', top='mean', source=dropped_source, line_color='black', line_width=1, fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) dropped_fig.scatter( size=25, x='x', y='high', source=dropped_source, line_color='black', line_width=2, marker='dash', fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) dropped_fig.y_range.start = 0 dropped_fig.x_range.range_padding = 0.1 dropped_fig.title.text_font_size = SIZE_TITLE dropped_fig.xaxis.axis_label_text_font_size = SIZE_AXIS_LABEL dropped_fig.yaxis.axis_label_text_font_size = SIZE_AXIS_LABEL dropped_fig.yaxis.major_label_text_font_size = SIZE_MAJOR_LABEL dropped_fig.below[0].group_text_font_size = SIZE_CATEGORY_LABEL dropped_fig.below[0].major_label_text_font_size = SIZE_MAJOR_LABEL # initialize period figure period_fig = figure( title='Behavior Planner Jitter Summary ' + str(duration) + 's', x_axis_label=f'Executors (with RMW)', y_axis_label='Period (ms)', x_range=FactorRange(*x), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) period_fig.segment( x, df.high[period].values, x, df.low[period].values, color='black', line_width=2) period_fig.vbar( width=0.2, x='x', top='top', bottom='bottom', source=period_source, line_color='black', line_width=1, fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) period_fig.scatter( size=25, x='x', y='high', source=period_source, line_color='black', line_width=2, marker='dash', fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) period_fig.scatter( size=25, x='x', y='low', source=period_source, line_color='black', line_width=2, marker='dash', fill_color=factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=1, end=2) ) period_fig.y_range.start = 0 period_fig.x_range.range_padding = 0.1 period_fig.title.text_font_size = SIZE_TITLE period_fig.xaxis.axis_label_text_font_size = SIZE_AXIS_LABEL period_fig.yaxis.axis_label_text_font_size = SIZE_AXIS_LABEL period_fig.yaxis.major_label_text_font_size = SIZE_MAJOR_LABEL period_fig.below[0].group_text_font_size = SIZE_CATEGORY_LABEL period_fig.below[0].major_label_text_font_size = SIZE_MAJOR_LABEL # add latency hover tool latency_hover = HoverTool() latency_hover.tooltips = [ ('Average Latency', '@{mean}{0.00}ms'), ('Minimum Latency', '@{low}{0.00}ms'), ('Maximum Latency', '@{high}{0.00}ms'), ] latency_fig.add_tools(latency_hover) # add dropped messages hover tool dropped_hover = HoverTool() dropped_hover.tooltips = [ ('Dropped Messages Average', '@{mean}{0.00}'), ('Dropped Messages Min', '@{low}{0.00}'), ('Dropped Messages Max', '@{high}{0.00}'), ] dropped_fig.add_tools(dropped_hover) # add period hover tool period_hover = HoverTool() period_hover.tooltips = [ ('Period Average', '@{mean}{0.00}ms'), ('Period Min', '@{low}{0.00}ms'), ('Period Max', '@{high}{0.00}ms'), ] period_fig.add_tools(period_hover) # add tables # create tables columns = [TableColumn(field=col, title=col) for col in df[latency].columns] latency_table_title = Div( text='<b>Latency Summary Table ' + test_info + '</b>', width=SIZE_TABLE_WIDTH, height=SIZE_TABLE_ROW) latency_table = [ latency_table_title, DataTable( columns=columns, source=ColumnDataSource(df[latency].round(decimals=3)), autosize_mode='fit_viewport', margin=(0, 10, 10, 10), height=(len(df[latency].exe.values.tolist()) * SIZE_TABLE_ROW), width=SIZE_TABLE_WIDTH)] dropped_table_title = Div( text='<b>Dropped Messages Summary Table ' + test_info + '</b>', width=SIZE_TABLE_WIDTH, height=SIZE_TABLE_ROW) dropped_table = [ dropped_table_title, DataTable( columns=columns, source=ColumnDataSource(df[dropped].round(decimals=1)), autosize_mode='fit_viewport', margin=(0, 10, 10, 10), height=(len(df[dropped].exe.values.tolist()) * SIZE_TABLE_ROW), width=SIZE_TABLE_WIDTH)] period_table_title = Div( text='<b>Behavior Planner Jitter Summary Table ' + str(duration) + 's</b>', width=SIZE_TABLE_WIDTH, height=SIZE_TABLE_ROW) period_table = [ period_table_title, DataTable( columns=columns, source=ColumnDataSource(df[period].round(decimals=3)), autosize_mode='fit_viewport', margin=(0, 10, 10, 10), height=(len(df[period].exe.values.tolist()) * SIZE_TABLE_ROW), width=SIZE_TABLE_WIDTH)] std_figs = [ [latency_table], [latency_fig], [dropped_table], [dropped_fig], [period_table], [period_fig]] return std_figs def parseLogSummary(path, duration): # open file data = open(path).read().splitlines() # hold info on each test (start line and end line) log_map = {} in_test = False test_name = '' hot_path_name = '' log_map = [] count = 0 for index, line in enumerate(data): if 'generate_std_trace' in line: if str(duration) in line: if 'Start' in line: search = ': generate_std_traces_' test_name = line[line.find(search) + len(search):line.find('.py')] rmw_idx = test_name.find('_rmw') exe = test_name[0:rmw_idx] rmw = test_name[rmw_idx + 1:test_name.rfind('_')] start_time = line[line.find('[') + 1:line.find(']') - 1] log_map.append( [exe, rmw, { 'start': start_time, 'end': 0, 'hot_path': { 'latency': {}, 'dropped': {} }, 'behavior_planner': { 'period': {} } }]) in_test = True elif 'Passed' in line: in_test = False count += 1 # if within a test, add parse current line to dataframe if in_test: if 'hot path' in line: if 'hot path:' in line: indent = ' ' hot_path_name = line[line.find('hot path:') + len('hot path:' + indent):] if 'latency' in line: end_time = line[line.find('[') + 1:line.find(']') - 1] log_map[count][2]['end'] = end_time stats = parseStats(line) if stats is not None: log_map[count][2]['hot_path']['latency'] = stats elif 'drops' in line: end_time = line[line.find('[') + 1:line.find(']') - 1] log_map[count][2]['end'] = end_time stats = parseStats(line) if stats is not None: log_map[count][2]['hot_path']['dropped'] = stats elif 'period' in line: # behavior planner period # log_map[count][2]['behavior_planner']['period'] = \\ # float(line[line.find('period') + len('period: '):line.find('ms')]) stats = parseStats(line) if stats is not None: log_map[count][2]['behavior_planner']['period'] = stats return log_map, test_name, hot_path_name def parseStats(line): # assume all stats in milliseconds stats = { 'timestamp': 0.0, 'low': 0.0, 'high': 0.0, 'mean': 0.0, 'std_dev': 0.0, 'top': 0.0, 'bottom': 0.0 } try: stats['timestamp'] = float( line[line.find('[') + 1:line.find(']') - 1]) * 1000 # convert to ms parsed_stats = line.split(',') stats['low'] = parsed_stats[0][parsed_stats[0].find('min') + len('min='):] stats['high'] = parsed_stats[1][parsed_stats[1].find('max') + len('max='):] stats['mean'] = parsed_stats[2][parsed_stats[2].find('average') + len('average='):] stats['std_dev'] = \\ parsed_stats[3][parsed_stats[3].find('deviation') + len('deviation='):-1] for val in stats: if isinstance(stats[val], str): if stats[val].endswith('ms'): stats[val] = stats[val][:-2] stats[val] = float(stats[val]) stats['top'] = stats['mean'] + stats['std_dev'] stats['bottom'] = stats['mean'] - stats['std_dev'] if stats['bottom'] < 0: stats['bottom'] = 0 except IndexError as e: print('Line incomplete:') print('[line]: ' + line) print('Returning None for this line') print(e) stats = None return stats Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/systems_8hpp/","text":"reference_system/include/reference_system/system/systems.hpp Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__SYSTEM__SYSTEMS_HPP_ #define REFERENCE_SYSTEM__SYSTEM__SYSTEMS_HPP_ // Add available systems here #include \"reference_system/system/type/rclcpp_system.hpp\" #endif // REFERENCE_SYSTEM__SYSTEM__SYSTEMS_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_system/include/reference_system/system/systems.hpp"},{"location":"Files/systems_8hpp/#reference_systemincludereference_systemsystemsystemshpp","text":"","title":"reference_system/include/reference_system/system/systems.hpp"},{"location":"Files/systems_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__SYSTEM__SYSTEMS_HPP_ #define REFERENCE_SYSTEM__SYSTEM__SYSTEMS_HPP_ // Add available systems here #include \"reference_system/system/type/rclcpp_system.hpp\" #endif // REFERENCE_SYSTEM__SYSTEM__SYSTEMS_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/test__autoware__reference__system_8cpp/","text":"autoware_reference_system/test/test_autoware_reference_system.cpp Functions Name TEST (TestReferenceSystemAutoware , DummyTest ) Functions Documentation function TEST TEST( TestReferenceSystemAutoware , DummyTest ) Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include \"gtest/gtest.h\" TEST(TestReferenceSystemAutoware, DummyTest) { EXPECT_EQ(1, 1); } Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/test/test_autoware_reference_system.cpp"},{"location":"Files/test__autoware__reference__system_8cpp/#autoware_reference_systemtesttest_autoware_reference_systemcpp","text":"","title":"autoware_reference_system/test/test_autoware_reference_system.cpp"},{"location":"Files/test__autoware__reference__system_8cpp/#functions","text":"Name TEST (TestReferenceSystemAutoware , DummyTest )","title":"Functions"},{"location":"Files/test__autoware__reference__system_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/test__autoware__reference__system_8cpp/#function-test","text":"TEST( TestReferenceSystemAutoware , DummyTest )","title":"function TEST"},{"location":"Files/test__autoware__reference__system_8cpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include \"gtest/gtest.h\" TEST(TestReferenceSystemAutoware, DummyTest) { EXPECT_EQ(1, 1); } Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/test__fixtures_8hpp/","text":"reference_system/test/test_fixtures.hpp Classes Name class TestNodeGraph Types Name using std::chrono::milliseconds milliseconds Functions Name template <typename SystemType ,typename NodeType ,typename SettingsType > auto create_node (SettingsType settings) Attributes Name constexpr uint64_t CRUNCH Types Documentation using milliseconds using milliseconds = std::chrono::milliseconds; Functions Documentation function create_node template <typename SystemType , typename NodeType , typename SettingsType > auto create_node( SettingsType settings ) Attributes Documentation variable CRUNCH static constexpr uint64_t CRUNCH = 65536; Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef TEST_FIXTURES_HPP_ #define TEST_FIXTURES_HPP_ #include <rclcpp/rclcpp.hpp> #include <gtest/gtest.h> #include <memory> class TestNodeGraph : public ::testing::Test { public: void SetUp() { rclcpp::init(0, nullptr); } void TearDown() { rclcpp::shutdown(); } }; using milliseconds = std::chrono::milliseconds; static constexpr uint64_t CRUNCH = 65536; template<typename SystemType, typename NodeType, typename SettingsType> auto create_node(SettingsType settings) ->std::shared_ptr<typename SystemType::NodeBaseType> { auto node = std::make_shared<NodeType>(settings); return node; } #endif // TEST_FIXTURES_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_system/test/test_fixtures.hpp"},{"location":"Files/test__fixtures_8hpp/#reference_systemtesttest_fixtureshpp","text":"","title":"reference_system/test/test_fixtures.hpp"},{"location":"Files/test__fixtures_8hpp/#classes","text":"Name class TestNodeGraph","title":"Classes"},{"location":"Files/test__fixtures_8hpp/#types","text":"Name using std::chrono::milliseconds milliseconds","title":"Types"},{"location":"Files/test__fixtures_8hpp/#functions","text":"Name template <typename SystemType ,typename NodeType ,typename SettingsType > auto create_node (SettingsType settings)","title":"Functions"},{"location":"Files/test__fixtures_8hpp/#attributes","text":"Name constexpr uint64_t CRUNCH","title":"Attributes"},{"location":"Files/test__fixtures_8hpp/#types-documentation","text":"","title":"Types Documentation"},{"location":"Files/test__fixtures_8hpp/#using-milliseconds","text":"using milliseconds = std::chrono::milliseconds;","title":"using milliseconds"},{"location":"Files/test__fixtures_8hpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/test__fixtures_8hpp/#function-create_node","text":"template <typename SystemType , typename NodeType , typename SettingsType > auto create_node( SettingsType settings )","title":"function create_node"},{"location":"Files/test__fixtures_8hpp/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Files/test__fixtures_8hpp/#variable-crunch","text":"static constexpr uint64_t CRUNCH = 65536;","title":"variable CRUNCH"},{"location":"Files/test__fixtures_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef TEST_FIXTURES_HPP_ #define TEST_FIXTURES_HPP_ #include <rclcpp/rclcpp.hpp> #include <gtest/gtest.h> #include <memory> class TestNodeGraph : public ::testing::Test { public: void SetUp() { rclcpp::init(0, nullptr); } void TearDown() { rclcpp::shutdown(); } }; using milliseconds = std::chrono::milliseconds; static constexpr uint64_t CRUNCH = 65536; template<typename SystemType, typename NodeType, typename SettingsType> auto create_node(SettingsType settings) ->std::shared_ptr<typename SystemType::NodeBaseType> { auto node = std::make_shared<NodeType>(settings); return node; } #endif // TEST_FIXTURES_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/test__number__cruncher_8cpp/","text":"reference_system/test/test_number_cruncher.cpp Functions Name TEST (test_number_cruncher , number_cruncher ) TEST (test_number_cruncher , crunch_time ) Functions Documentation function TEST TEST( test_number_cruncher , number_cruncher ) function TEST TEST( test_number_cruncher , crunch_time ) Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <gtest/gtest.h> #include <string> #include \"reference_system/number_cruncher.hpp\" TEST(test_number_cruncher, number_cruncher) { auto primes = number_cruncher(10); // 2, 3, 5, 7 EXPECT_EQ(primes, 4); primes = number_cruncher(20); // 11, 13, 17, 19 EXPECT_EQ(primes, 8); primes = number_cruncher(30); // 23, 29 EXPECT_EQ(primes, 10); } TEST(test_number_cruncher, crunch_time) { auto expected_fast = get_crunch_time_in_ms(100); auto expected_slow = get_crunch_time_in_ms(65536); // lower maximum number should result in faster crunch times EXPECT_LT(expected_fast, expected_slow); } Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_system/test/test_number_cruncher.cpp"},{"location":"Files/test__number__cruncher_8cpp/#reference_systemtesttest_number_crunchercpp","text":"","title":"reference_system/test/test_number_cruncher.cpp"},{"location":"Files/test__number__cruncher_8cpp/#functions","text":"Name TEST (test_number_cruncher , number_cruncher ) TEST (test_number_cruncher , crunch_time )","title":"Functions"},{"location":"Files/test__number__cruncher_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/test__number__cruncher_8cpp/#function-test","text":"TEST( test_number_cruncher , number_cruncher )","title":"function TEST"},{"location":"Files/test__number__cruncher_8cpp/#function-test_1","text":"TEST( test_number_cruncher , crunch_time )","title":"function TEST"},{"location":"Files/test__number__cruncher_8cpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <gtest/gtest.h> #include <string> #include \"reference_system/number_cruncher.hpp\" TEST(test_number_cruncher, number_cruncher) { auto primes = number_cruncher(10); // 2, 3, 5, 7 EXPECT_EQ(primes, 4); primes = number_cruncher(20); // 11, 13, 17, 19 EXPECT_EQ(primes, 8); primes = number_cruncher(30); // 23, 29 EXPECT_EQ(primes, 10); } TEST(test_number_cruncher, crunch_time) { auto expected_fast = get_crunch_time_in_ms(100); auto expected_slow = get_crunch_time_in_ms(65536); // lower maximum number should result in faster crunch times EXPECT_LT(expected_fast, expected_slow); } Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/test__platform_8py/","text":"autoware_reference_system/test/test_platform.py Namespaces Name test_platform Source code # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import multiprocessing import platform # this file has @variables@ that are meant to be automatically replaced # by values using the `configure_file` CMake function during the build platforms = {} # TODO(flynneva): move this to its own file for portability # can add more supported platforms here platforms['rpi4-linux-rt'] = { 'common-name': 'raspberrypi4', 'machine': 'aarch64', 'processor': 'aarch64', 'system': 'Linux', 'flavor': 'ubuntu', 'cores': 4, 'realtime': True } def test_platform(record_property): # get current system information record_property('TEST_ID', '9ad8a388-b674-4706-991d-56654dc734e1') system, node, release, version, machine, processor = platform.uname() platform_supported = False for pform in platforms: if(platforms[pform]['system'] == system): if(platforms[pform]['processor'] == processor): platform_supported = True assert multiprocessing.cpu_count() == platforms[pform]['cores'] if(platforms[pform]['realtime']): assert 'PREEMPT_RT' in version if platform_supported: print('platform supported') assert True else: print('platform unsupported') assert False Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/test/test_platform.py"},{"location":"Files/test__platform_8py/#autoware_reference_systemtesttest_platformpy","text":"","title":"autoware_reference_system/test/test_platform.py"},{"location":"Files/test__platform_8py/#namespaces","text":"Name test_platform","title":"Namespaces"},{"location":"Files/test__platform_8py/#source-code","text":"# Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import multiprocessing import platform # this file has @variables@ that are meant to be automatically replaced # by values using the `configure_file` CMake function during the build platforms = {} # TODO(flynneva): move this to its own file for portability # can add more supported platforms here platforms['rpi4-linux-rt'] = { 'common-name': 'raspberrypi4', 'machine': 'aarch64', 'processor': 'aarch64', 'system': 'Linux', 'flavor': 'ubuntu', 'cores': 4, 'realtime': True } def test_platform(record_property): # get current system information record_property('TEST_ID', '9ad8a388-b674-4706-991d-56654dc734e1') system, node, release, version, machine, processor = platform.uname() platform_supported = False for pform in platforms: if(platforms[pform]['system'] == system): if(platforms[pform]['processor'] == processor): platform_supported = True assert multiprocessing.cpu_count() == platforms[pform]['cores'] if(platforms[pform]['realtime']): assert 'PREEMPT_RT' in version if platform_supported: print('platform supported') assert True else: print('platform unsupported') assert False Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/test__reference__system__rclcpp_8cpp/","text":"reference_system/test/test_reference_system_rclcpp.cpp Types Name using RclcppSystem SystemType Functions Name TEST_F ( TestNodeGraph , rclcpp_sensor_node ) TEST_F ( TestNodeGraph , rclcpp_transform_node ) TEST_F ( TestNodeGraph , rclcpp_intersection_node ) TEST_F ( TestNodeGraph , rclcpp_fusion_node ) TEST_F ( TestNodeGraph , rclcpp_cyclic_node ) TEST_F ( TestNodeGraph , rclcpp_command_node ) Types Documentation using SystemType using SystemType = RclcppSystem; Functions Documentation function TEST_F TEST_F( TestNodeGraph , rclcpp_sensor_node ) function TEST_F TEST_F( TestNodeGraph , rclcpp_transform_node ) function TEST_F TEST_F( TestNodeGraph , rclcpp_intersection_node ) function TEST_F TEST_F( TestNodeGraph , rclcpp_fusion_node ) function TEST_F TEST_F( TestNodeGraph , rclcpp_cyclic_node ) function TEST_F TEST_F( TestNodeGraph , rclcpp_command_node ) Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <gtest/gtest.h> #include <string> #include \"test_fixtures.hpp\" #include \"rclcpp/node_interfaces/node_graph.hpp\" #include \"reference_system/system/systems.hpp\" // set the system to use using SystemType = RclcppSystem; TEST_F(TestNodeGraph, rclcpp_sensor_node) { auto settings = nodes::SensorSettings(); settings.node_name = \"SensorNode\"; settings.topic_name = settings.node_name; settings.cycle_time = milliseconds(100); // create node auto node = create_node<SystemType, SystemType::Sensor, nodes::SensorSettings>(settings); // confirm node was initialized with settings EXPECT_EQ(node->get_name(), settings.node_name); // TODO(flynneva): update node graph API for galactic and rolling // get node graph of node // auto * node_graph = node->get_node_graph_interface().get(); // ASSERT_NE(nullptr, node_graph); // auto topic_names_and_types = node_graph->get_topic_names_and_types(false); // // sensor nodes should publish one topic // EXPECT_EQ(size_t(3), topic_names_and_types.size()); // EXPECT_EQ(size_t(1), node_graph->count_publishers(settings.topic_name)); } TEST_F(TestNodeGraph, rclcpp_transform_node) { auto settings = nodes::TransformSettings(); settings.node_name = \"TransformNode\"; settings.input_topic = settings.node_name + \"1\"; settings.output_topic = settings.node_name; settings.number_crunch_limit = CRUNCH; // create node auto node = create_node<SystemType, SystemType::Transform, nodes::TransformSettings>(settings); // confirm node was initialized with settings EXPECT_EQ(node->get_name(), settings.node_name); // get node graph of node // auto * node_graph = node->get_node_graph_interface().get(); // ASSERT_NE(nullptr, node_graph); // auto topic_names_and_types = node_graph->get_topic_names_and_types(false); // // transform nodes should publish one topic and subscribe to one topic // size_t pubs = 1; // size_t subs = 1; // size_t total_pubs_and_subs = pubs + subs + size_t(2); // 2 for rosout and parameter_events // EXPECT_EQ(total_pubs_and_subs, topic_names_and_types.size()); // EXPECT_EQ(pubs, node_graph->count_publishers(settings.output_topic)); // EXPECT_EQ(subs, node_graph->count_subscribers(settings.input_topic)); } TEST_F(TestNodeGraph, rclcpp_intersection_node) { auto settings = nodes::IntersectionSettings(); settings.node_name = \"IntersectionNode\"; std::string input_topic = settings.node_name + \"_in_\"; settings.connections.emplace_back(nodes::IntersectionSettings::Connection()); settings.connections.emplace_back(nodes::IntersectionSettings::Connection()); settings.connections[0].input_topic = input_topic + \"1\"; settings.connections[0].output_topic = settings.node_name + \"1\"; settings.connections[0].number_crunch_limit = CRUNCH; settings.connections[1].input_topic = input_topic + \"2\"; settings.connections[1].output_topic = settings.node_name + \"2\"; settings.connections[1].number_crunch_limit = CRUNCH; // create node auto node = create_node<SystemType, SystemType::Intersection, nodes::IntersectionSettings>(settings); // confirm node was initialized with settings EXPECT_EQ(node->get_name(), settings.node_name); // get node graph of node // auto * node_graph = node->get_node_graph_interface().get(); // ASSERT_NE(nullptr, node_graph); // auto topic_names_and_types = node_graph->get_topic_names_and_types(false); // // intersection nodes should publish two topics and subscribe to two topics // auto pubs = settings.connections.size(); // auto subs = settings.connections.size(); // auto total_pubs_and_subs = pubs + subs + 2; // 2 for rosout and parameter_events // EXPECT_EQ(total_pubs_and_subs, topic_names_and_types.size()); // for (auto connection : settings.connections) { // EXPECT_EQ(size_t(1), node_graph->count_publishers(connection.output_topic)); // EXPECT_EQ(size_t(1), node_graph->count_subscribers(connection.input_topic)); // } } TEST_F(TestNodeGraph, rclcpp_fusion_node) { auto settings = nodes::FusionSettings(); settings.node_name = \"FusionNode\"; settings.input_0 = settings.node_name + \"1\"; settings.input_1 = settings.node_name + \"2\"; settings.number_crunch_limit = CRUNCH; settings.output_topic = settings.node_name; // create node auto node = create_node<SystemType, SystemType::Fusion, nodes::FusionSettings>(settings); // confirm node was initialized with settings EXPECT_EQ(node->get_name(), settings.node_name); // get node graph of node // auto * node_graph = node->get_node_graph_interface().get(); // ASSERT_NE(nullptr, node_graph); // auto topic_names_and_types = node_graph->get_topic_names_and_types(false); // intersection nodes should publish two topics and subscribe to two topics // size_t pubs = 1; // size_t subs = 2; // size_t total_pubs_and_subs = pubs + subs + 2; // 2 for rosout and parameter_events // EXPECT_EQ(total_pubs_and_subs, topic_names_and_types.size()); // EXPECT_EQ(size_t(1), node_graph->count_publishers(settings.node_name)); // EXPECT_EQ(size_t(1), node_graph->count_subscribers(settings.input_0)); // EXPECT_EQ(size_t(1), node_graph->count_subscribers(settings.input_1)); } TEST_F(TestNodeGraph, rclcpp_cyclic_node) { auto settings = nodes::CyclicSettings(); settings.node_name = \"CyclicNode\"; settings.inputs.emplace_back(settings.node_name + \"1\"); settings.inputs.emplace_back(settings.node_name + \"2\"); settings.inputs.emplace_back(settings.node_name + \"3\"); settings.number_crunch_limit = CRUNCH; settings.output_topic = settings.node_name; // create node auto node = create_node<SystemType, SystemType::Cyclic, nodes::CyclicSettings>(settings); // confirm node was initialized with settings EXPECT_EQ(node->get_name(), settings.node_name); // get node graph of node // auto * node_graph = node->get_node_graph_interface().get(); // ASSERT_NE(nullptr, node_graph); // auto topic_names_and_types = node_graph->get_topic_names_and_types(false); // // intersection nodes should publish two topics and subscribe to two topics // size_t pubs = 1; // size_t subs = 3; // auto total_pubs_and_subs = pubs + subs + 2; // 2 for rosout and parameter_events // EXPECT_EQ(total_pubs_and_subs, topic_names_and_types.size()); // EXPECT_EQ(size_t(1), node_graph->count_publishers(settings.node_name)); // EXPECT_EQ(size_t(1), node_graph->count_subscribers(settings.inputs[0])); // EXPECT_EQ(size_t(1), node_graph->count_subscribers(settings.inputs[1])); // EXPECT_EQ(size_t(1), node_graph->count_subscribers(settings.inputs[2])); } TEST_F(TestNodeGraph, rclcpp_command_node) { auto settings = nodes::CommandSettings(); settings.node_name = \"CommandNode\"; settings.input_topic = settings.node_name + \"_in\"; // create node auto node = create_node<SystemType, SystemType::Command, nodes::CommandSettings>(settings); // confirm node was initialized with settings EXPECT_EQ(node->get_name(), settings.node_name); // get node graph of node // auto * node_graph = node->get_node_graph_interface().get(); // ASSERT_NE(nullptr, node_graph); // auto topic_names_and_types = node_graph->get_topic_names_and_types(false); // // intersection nodes should publish two topics and subscribe to two topics // size_t pubs = 0; // size_t subs = 1; // auto total_pubs_and_subs = pubs + subs + 2; // 2 for rosout and parameter_events // EXPECT_EQ(total_pubs_and_subs, topic_names_and_types.size()); // EXPECT_EQ(size_t(0), node_graph->count_publishers(settings.node_name)); // EXPECT_EQ(size_t(1), node_graph->count_subscribers(settings.input_topic)); } Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_system/test/test_reference_system_rclcpp.cpp"},{"location":"Files/test__reference__system__rclcpp_8cpp/#reference_systemtesttest_reference_system_rclcppcpp","text":"","title":"reference_system/test/test_reference_system_rclcpp.cpp"},{"location":"Files/test__reference__system__rclcpp_8cpp/#types","text":"Name using RclcppSystem SystemType","title":"Types"},{"location":"Files/test__reference__system__rclcpp_8cpp/#functions","text":"Name TEST_F ( TestNodeGraph , rclcpp_sensor_node ) TEST_F ( TestNodeGraph , rclcpp_transform_node ) TEST_F ( TestNodeGraph , rclcpp_intersection_node ) TEST_F ( TestNodeGraph , rclcpp_fusion_node ) TEST_F ( TestNodeGraph , rclcpp_cyclic_node ) TEST_F ( TestNodeGraph , rclcpp_command_node )","title":"Functions"},{"location":"Files/test__reference__system__rclcpp_8cpp/#types-documentation","text":"","title":"Types Documentation"},{"location":"Files/test__reference__system__rclcpp_8cpp/#using-systemtype","text":"using SystemType = RclcppSystem;","title":"using SystemType"},{"location":"Files/test__reference__system__rclcpp_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/test__reference__system__rclcpp_8cpp/#function-test_f","text":"TEST_F( TestNodeGraph , rclcpp_sensor_node )","title":"function TEST_F"},{"location":"Files/test__reference__system__rclcpp_8cpp/#function-test_f_1","text":"TEST_F( TestNodeGraph , rclcpp_transform_node )","title":"function TEST_F"},{"location":"Files/test__reference__system__rclcpp_8cpp/#function-test_f_2","text":"TEST_F( TestNodeGraph , rclcpp_intersection_node )","title":"function TEST_F"},{"location":"Files/test__reference__system__rclcpp_8cpp/#function-test_f_3","text":"TEST_F( TestNodeGraph , rclcpp_fusion_node )","title":"function TEST_F"},{"location":"Files/test__reference__system__rclcpp_8cpp/#function-test_f_4","text":"TEST_F( TestNodeGraph , rclcpp_cyclic_node )","title":"function TEST_F"},{"location":"Files/test__reference__system__rclcpp_8cpp/#function-test_f_5","text":"TEST_F( TestNodeGraph , rclcpp_command_node )","title":"function TEST_F"},{"location":"Files/test__reference__system__rclcpp_8cpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <gtest/gtest.h> #include <string> #include \"test_fixtures.hpp\" #include \"rclcpp/node_interfaces/node_graph.hpp\" #include \"reference_system/system/systems.hpp\" // set the system to use using SystemType = RclcppSystem; TEST_F(TestNodeGraph, rclcpp_sensor_node) { auto settings = nodes::SensorSettings(); settings.node_name = \"SensorNode\"; settings.topic_name = settings.node_name; settings.cycle_time = milliseconds(100); // create node auto node = create_node<SystemType, SystemType::Sensor, nodes::SensorSettings>(settings); // confirm node was initialized with settings EXPECT_EQ(node->get_name(), settings.node_name); // TODO(flynneva): update node graph API for galactic and rolling // get node graph of node // auto * node_graph = node->get_node_graph_interface().get(); // ASSERT_NE(nullptr, node_graph); // auto topic_names_and_types = node_graph->get_topic_names_and_types(false); // // sensor nodes should publish one topic // EXPECT_EQ(size_t(3), topic_names_and_types.size()); // EXPECT_EQ(size_t(1), node_graph->count_publishers(settings.topic_name)); } TEST_F(TestNodeGraph, rclcpp_transform_node) { auto settings = nodes::TransformSettings(); settings.node_name = \"TransformNode\"; settings.input_topic = settings.node_name + \"1\"; settings.output_topic = settings.node_name; settings.number_crunch_limit = CRUNCH; // create node auto node = create_node<SystemType, SystemType::Transform, nodes::TransformSettings>(settings); // confirm node was initialized with settings EXPECT_EQ(node->get_name(), settings.node_name); // get node graph of node // auto * node_graph = node->get_node_graph_interface().get(); // ASSERT_NE(nullptr, node_graph); // auto topic_names_and_types = node_graph->get_topic_names_and_types(false); // // transform nodes should publish one topic and subscribe to one topic // size_t pubs = 1; // size_t subs = 1; // size_t total_pubs_and_subs = pubs + subs + size_t(2); // 2 for rosout and parameter_events // EXPECT_EQ(total_pubs_and_subs, topic_names_and_types.size()); // EXPECT_EQ(pubs, node_graph->count_publishers(settings.output_topic)); // EXPECT_EQ(subs, node_graph->count_subscribers(settings.input_topic)); } TEST_F(TestNodeGraph, rclcpp_intersection_node) { auto settings = nodes::IntersectionSettings(); settings.node_name = \"IntersectionNode\"; std::string input_topic = settings.node_name + \"_in_\"; settings.connections.emplace_back(nodes::IntersectionSettings::Connection()); settings.connections.emplace_back(nodes::IntersectionSettings::Connection()); settings.connections[0].input_topic = input_topic + \"1\"; settings.connections[0].output_topic = settings.node_name + \"1\"; settings.connections[0].number_crunch_limit = CRUNCH; settings.connections[1].input_topic = input_topic + \"2\"; settings.connections[1].output_topic = settings.node_name + \"2\"; settings.connections[1].number_crunch_limit = CRUNCH; // create node auto node = create_node<SystemType, SystemType::Intersection, nodes::IntersectionSettings>(settings); // confirm node was initialized with settings EXPECT_EQ(node->get_name(), settings.node_name); // get node graph of node // auto * node_graph = node->get_node_graph_interface().get(); // ASSERT_NE(nullptr, node_graph); // auto topic_names_and_types = node_graph->get_topic_names_and_types(false); // // intersection nodes should publish two topics and subscribe to two topics // auto pubs = settings.connections.size(); // auto subs = settings.connections.size(); // auto total_pubs_and_subs = pubs + subs + 2; // 2 for rosout and parameter_events // EXPECT_EQ(total_pubs_and_subs, topic_names_and_types.size()); // for (auto connection : settings.connections) { // EXPECT_EQ(size_t(1), node_graph->count_publishers(connection.output_topic)); // EXPECT_EQ(size_t(1), node_graph->count_subscribers(connection.input_topic)); // } } TEST_F(TestNodeGraph, rclcpp_fusion_node) { auto settings = nodes::FusionSettings(); settings.node_name = \"FusionNode\"; settings.input_0 = settings.node_name + \"1\"; settings.input_1 = settings.node_name + \"2\"; settings.number_crunch_limit = CRUNCH; settings.output_topic = settings.node_name; // create node auto node = create_node<SystemType, SystemType::Fusion, nodes::FusionSettings>(settings); // confirm node was initialized with settings EXPECT_EQ(node->get_name(), settings.node_name); // get node graph of node // auto * node_graph = node->get_node_graph_interface().get(); // ASSERT_NE(nullptr, node_graph); // auto topic_names_and_types = node_graph->get_topic_names_and_types(false); // intersection nodes should publish two topics and subscribe to two topics // size_t pubs = 1; // size_t subs = 2; // size_t total_pubs_and_subs = pubs + subs + 2; // 2 for rosout and parameter_events // EXPECT_EQ(total_pubs_and_subs, topic_names_and_types.size()); // EXPECT_EQ(size_t(1), node_graph->count_publishers(settings.node_name)); // EXPECT_EQ(size_t(1), node_graph->count_subscribers(settings.input_0)); // EXPECT_EQ(size_t(1), node_graph->count_subscribers(settings.input_1)); } TEST_F(TestNodeGraph, rclcpp_cyclic_node) { auto settings = nodes::CyclicSettings(); settings.node_name = \"CyclicNode\"; settings.inputs.emplace_back(settings.node_name + \"1\"); settings.inputs.emplace_back(settings.node_name + \"2\"); settings.inputs.emplace_back(settings.node_name + \"3\"); settings.number_crunch_limit = CRUNCH; settings.output_topic = settings.node_name; // create node auto node = create_node<SystemType, SystemType::Cyclic, nodes::CyclicSettings>(settings); // confirm node was initialized with settings EXPECT_EQ(node->get_name(), settings.node_name); // get node graph of node // auto * node_graph = node->get_node_graph_interface().get(); // ASSERT_NE(nullptr, node_graph); // auto topic_names_and_types = node_graph->get_topic_names_and_types(false); // // intersection nodes should publish two topics and subscribe to two topics // size_t pubs = 1; // size_t subs = 3; // auto total_pubs_and_subs = pubs + subs + 2; // 2 for rosout and parameter_events // EXPECT_EQ(total_pubs_and_subs, topic_names_and_types.size()); // EXPECT_EQ(size_t(1), node_graph->count_publishers(settings.node_name)); // EXPECT_EQ(size_t(1), node_graph->count_subscribers(settings.inputs[0])); // EXPECT_EQ(size_t(1), node_graph->count_subscribers(settings.inputs[1])); // EXPECT_EQ(size_t(1), node_graph->count_subscribers(settings.inputs[2])); } TEST_F(TestNodeGraph, rclcpp_command_node) { auto settings = nodes::CommandSettings(); settings.node_name = \"CommandNode\"; settings.input_topic = settings.node_name + \"_in\"; // create node auto node = create_node<SystemType, SystemType::Command, nodes::CommandSettings>(settings); // confirm node was initialized with settings EXPECT_EQ(node->get_name(), settings.node_name); // get node graph of node // auto * node_graph = node->get_node_graph_interface().get(); // ASSERT_NE(nullptr, node_graph); // auto topic_names_and_types = node_graph->get_topic_names_and_types(false); // // intersection nodes should publish two topics and subscribe to two topics // size_t pubs = 0; // size_t subs = 1; // auto total_pubs_and_subs = pubs + subs + 2; // 2 for rosout and parameter_events // EXPECT_EQ(total_pubs_and_subs, topic_names_and_types.size()); // EXPECT_EQ(size_t(0), node_graph->count_publishers(settings.node_name)); // EXPECT_EQ(size_t(1), node_graph->count_subscribers(settings.input_topic)); } Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/test__requirements_8py/","text":"autoware_reference_system/test/test_requirements.py Namespaces Name test_requirements Classes Name class test_requirements::TestRequirementsAutowareReferenceSystem Source code # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import os import time import unittest from launch import LaunchDescription from launch.actions import ExecuteProcess import launch_testing import launch_testing.actions from ros2cli.node.direct import DirectNode import ros2topic.api # Tests to check if executable complies with the requirements for # the autoware_reference_system by checking number of nodes, publishers, # subscribers and frequency of some topics # this file has @variables@ that are meant to be automatically replaced # by values using the `configure_file` CMake function during the build checks = {'topic_exists': False, 'pubs_match': False, 'subs_match': False} # define autoware_reference_system requirements for each topic # NOTE: the pub/sub counts are for the topic, not the node itself reference_system = { '/FrontLidarDriver': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/RearLidarDriver': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointCloudMap': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/Visualizer': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/Lanelet2Map': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointsTransformerFront': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointsTransformerRear': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/VoxelGridDownsampler': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointCloudMapLoader': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/EuclideanClusterDetector': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/ObjectCollisionEstimator': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/MPCController': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/ParkingPlanner': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/LanePlanner': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointCloudFusion': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()}, '/NDTLocalizer': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()}, '/VehicleInterface': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/Lanelet2GlobalPlanner': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()}, '/Lanelet2MapLoader': {'pub_count': 1, 'sub_count': 3, 'checks': checks.copy()}, '/BehaviorPlanner': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()} # does not exist as topic but only as a node # '/VehicleDBWSystem': {'pub_count': 0, 'sub_count': 0, 'checks': checks.copy()} } def generate_test_description(): env = os.environ.copy() env['RCUTILS_CONSOLE_OUTPUT_FORMAT'] = '[{severity}] [{name}]: {message}' launch_description = LaunchDescription() proc_under_test = ExecuteProcess( cmd=['@TEST_EXECUTABLE@'], name='@TEST_EXECUTABLE_NAME@', output='screen', env=env, ) launch_description.add_action(proc_under_test) launch_description.add_action( launch_testing.actions.ReadyToTest() ) return launch_description, locals() class TestRequirementsAutowareReferenceSystem(unittest.TestCase): def test_pubs_and_subs(self): with DirectNode([]) as node: seen_topics = {} try: while True: print('topic_monitor looping:') for name in ros2topic.api.get_topic_names(node=node): if name not in seen_topics: seen_topics[name] = {'pub_count': 0, 'sub_count': 0} publishers = node.count_publishers(name) subscribers = node.count_subscribers(name) if seen_topics[name]['pub_count'] < publishers: seen_topics[name]['pub_count'] = publishers if seen_topics[name]['sub_count'] < subscribers: seen_topics[name]['sub_count'] = subscribers if len(seen_topics) > 0: print('Topic monitor data collected') for name in reference_system: if name in seen_topics.keys(): reference_system[name]['checks']['topic_exists'] = True if(reference_system[name]['pub_count'] == seen_topics[name]['pub_count']): reference_system[name]['checks']['pubs_match'] = True else: print('[' + name + '::pubs] EXPECTED: ' + str(reference_system[name]['pub_count'])) print('[' + name + '::pubs] RECEIVED: ' + str(seen_topics[name]['pub_count'])) if(reference_system[name]['sub_count'] == seen_topics[name]['sub_count']): reference_system[name]['checks']['subs_match'] = True else: print('[' + name + '::subs] EXPECTED: ' + str(reference_system[name]['sub_count'])) print('[' + name + '::subs] RECEIVED: ' + str(seen_topics[name]['sub_count'])) self.assertTrue(all(reference_system[name]['checks'].values())) print( f'\\t\\t{name}: ' f\"['topic_exists'=\" f\"{reference_system[name]['checks']['topic_exists']},\" f\" 'pubs_match'=\" f\"{reference_system[name]['checks']['pubs_match']},\" f\" 'subs_match'=\" f\"{reference_system[name]['checks']['subs_match']}]\") # exit while loop, data was collected return # slow down while loop time.sleep(0.5) except SystemError: pass except KeyboardInterrupt: pass Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/test/test_requirements.py"},{"location":"Files/test__requirements_8py/#autoware_reference_systemtesttest_requirementspy","text":"","title":"autoware_reference_system/test/test_requirements.py"},{"location":"Files/test__requirements_8py/#namespaces","text":"Name test_requirements","title":"Namespaces"},{"location":"Files/test__requirements_8py/#classes","text":"Name class test_requirements::TestRequirementsAutowareReferenceSystem","title":"Classes"},{"location":"Files/test__requirements_8py/#source-code","text":"# Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import os import time import unittest from launch import LaunchDescription from launch.actions import ExecuteProcess import launch_testing import launch_testing.actions from ros2cli.node.direct import DirectNode import ros2topic.api # Tests to check if executable complies with the requirements for # the autoware_reference_system by checking number of nodes, publishers, # subscribers and frequency of some topics # this file has @variables@ that are meant to be automatically replaced # by values using the `configure_file` CMake function during the build checks = {'topic_exists': False, 'pubs_match': False, 'subs_match': False} # define autoware_reference_system requirements for each topic # NOTE: the pub/sub counts are for the topic, not the node itself reference_system = { '/FrontLidarDriver': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/RearLidarDriver': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointCloudMap': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/Visualizer': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/Lanelet2Map': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointsTransformerFront': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointsTransformerRear': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/VoxelGridDownsampler': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointCloudMapLoader': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/EuclideanClusterDetector': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/ObjectCollisionEstimator': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/MPCController': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/ParkingPlanner': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/LanePlanner': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointCloudFusion': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()}, '/NDTLocalizer': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()}, '/VehicleInterface': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/Lanelet2GlobalPlanner': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()}, '/Lanelet2MapLoader': {'pub_count': 1, 'sub_count': 3, 'checks': checks.copy()}, '/BehaviorPlanner': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()} # does not exist as topic but only as a node # '/VehicleDBWSystem': {'pub_count': 0, 'sub_count': 0, 'checks': checks.copy()} } def generate_test_description(): env = os.environ.copy() env['RCUTILS_CONSOLE_OUTPUT_FORMAT'] = '[{severity}] [{name}]: {message}' launch_description = LaunchDescription() proc_under_test = ExecuteProcess( cmd=['@TEST_EXECUTABLE@'], name='@TEST_EXECUTABLE_NAME@', output='screen', env=env, ) launch_description.add_action(proc_under_test) launch_description.add_action( launch_testing.actions.ReadyToTest() ) return launch_description, locals() class TestRequirementsAutowareReferenceSystem(unittest.TestCase): def test_pubs_and_subs(self): with DirectNode([]) as node: seen_topics = {} try: while True: print('topic_monitor looping:') for name in ros2topic.api.get_topic_names(node=node): if name not in seen_topics: seen_topics[name] = {'pub_count': 0, 'sub_count': 0} publishers = node.count_publishers(name) subscribers = node.count_subscribers(name) if seen_topics[name]['pub_count'] < publishers: seen_topics[name]['pub_count'] = publishers if seen_topics[name]['sub_count'] < subscribers: seen_topics[name]['sub_count'] = subscribers if len(seen_topics) > 0: print('Topic monitor data collected') for name in reference_system: if name in seen_topics.keys(): reference_system[name]['checks']['topic_exists'] = True if(reference_system[name]['pub_count'] == seen_topics[name]['pub_count']): reference_system[name]['checks']['pubs_match'] = True else: print('[' + name + '::pubs] EXPECTED: ' + str(reference_system[name]['pub_count'])) print('[' + name + '::pubs] RECEIVED: ' + str(seen_topics[name]['pub_count'])) if(reference_system[name]['sub_count'] == seen_topics[name]['sub_count']): reference_system[name]['checks']['subs_match'] = True else: print('[' + name + '::subs] EXPECTED: ' + str(reference_system[name]['sub_count'])) print('[' + name + '::subs] RECEIVED: ' + str(seen_topics[name]['sub_count'])) self.assertTrue(all(reference_system[name]['checks'].values())) print( f'\\t\\t{name}: ' f\"['topic_exists'=\" f\"{reference_system[name]['checks']['topic_exists']},\" f\" 'pubs_match'=\" f\"{reference_system[name]['checks']['pubs_match']},\" f\" 'subs_match'=\" f\"{reference_system[name]['checks']['subs_match']}]\") # exit while loop, data was collected return # slow down while loop time.sleep(0.5) except SystemError: pass except KeyboardInterrupt: pass Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/test__sample__management_8cpp/","text":"reference_system/test/test_sample_management.cpp Functions Name TEST (test_sample_management , set_benchmark_mode ) TEST (test_sample_management , is_in_benchmark_mode ) TEST (test_sample_management , sample_helpers ) TEST (test_sample_management , statistic_value_struct ) TEST (test_sample_management , sample_statistic_struct ) TEST (test_sample_management , print_sample_path ) Functions Documentation function TEST TEST( test_sample_management , set_benchmark_mode ) function TEST TEST( test_sample_management , is_in_benchmark_mode ) function TEST TEST( test_sample_management , sample_helpers ) function TEST TEST( test_sample_management , statistic_value_struct ) function TEST TEST( test_sample_management , sample_statistic_struct ) function TEST TEST( test_sample_management , print_sample_path ) Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <gtest/gtest.h> #include <string> #include \"reference_system/sample_management.hpp\" #include \"reference_system/msg_types.hpp\" TEST(test_sample_management, set_benchmark_mode) { EXPECT_TRUE(set_benchmark_mode(true)); EXPECT_FALSE(set_benchmark_mode(false)); EXPECT_FALSE(set_benchmark_mode(false, false)); } TEST(test_sample_management, is_in_benchmark_mode) { EXPECT_FALSE(is_in_benchmark_mode()); set_benchmark_mode(true); EXPECT_TRUE(is_in_benchmark_mode()); set_benchmark_mode(false); EXPECT_FALSE(is_in_benchmark_mode()); } TEST(test_sample_management, sample_helpers) { message_t sample; std::string node_name = \"test_node\"; uint32_t sequence_number = 10; uint32_t dropped_samples = 5; uint64_t timestamp = 8675309; set_sample(node_name, sequence_number, dropped_samples, timestamp, sample); // EXPECT_EQ(sample.stats[0].node_name.data(), node_name.data()); // see reference_interfaces for more details // 4kb msg = 4032 = 63 * 64 bytes, 64 bytes = TransmissionStats length EXPECT_EQ(sample.stats.size(), size_t(63)); EXPECT_EQ(sample.stats[0].sequence_number, sequence_number); EXPECT_EQ(sample.stats[0].dropped_samples, dropped_samples); EXPECT_EQ(sample.stats[0].timestamp, timestamp); auto retrieved_stamp = get_sample_timestamp(&sample); EXPECT_EQ(retrieved_stamp, timestamp); auto retrieved_sequence_number = get_sample_sequence_number(&sample); EXPECT_EQ(retrieved_sequence_number, sequence_number); auto retrieved_dropped_samples = get_missed_samples_and_update_seq_nr(&sample, sequence_number); // should be zero based on sequence number EXPECT_EQ(retrieved_dropped_samples, uint32_t(0)); } TEST(test_sample_management, statistic_value_struct) { auto stats = statistic_value_t(); stats.suffix = \"the_suffix\"; // simulate multiple messages coming in stats.set(1); stats.set(4); stats.set(5); stats.set(7); EXPECT_EQ(stats.average, 4.25); EXPECT_EQ(stats.deviation, 2.5); EXPECT_EQ(stats.min, uint64_t(1)); EXPECT_EQ(stats.max, uint64_t(7)); EXPECT_EQ(stats.current, uint64_t(7)); EXPECT_EQ(stats.total_number, uint64_t(4)); EXPECT_EQ(stats.suffix, \"the_suffix\"); EXPECT_EQ(stats.adjustment, static_cast<double>(0.0)); } TEST(test_sample_management, sample_statistic_struct) { auto stats = sample_statistic_t(); stats.timepoint_of_first_received_sample = 1; stats.previous_behavior_planner_sequence = 2; stats.previous_behavior_planner_time_stamp = 3; EXPECT_EQ(stats.timepoint_of_first_received_sample, uint64_t(1)); EXPECT_EQ(stats.previous_behavior_planner_sequence, uint32_t(2)); EXPECT_EQ(stats.previous_behavior_planner_time_stamp, uint64_t(3)); } TEST(test_sample_management, print_sample_path) { message_t sample; std::string node_name = \"test_node\"; uint32_t sample_size = 105; // TODO(evan.flynn): add test for operator<< print function used within print_sample_path set_benchmark_mode(false); uint64_t timestamp = 1; for (uint32_t i = 0; i < sample_size; i++) { set_sample(node_name, i, 0, timestamp, sample); timestamp += 1; } // message sample size will always be 63 if message type is set to 4kb // see reference_interfaces package for more details EXPECT_EQ(sample.size, size_t(63)); print_sample_path(\"test_node\", uint32_t(1), &sample); } Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_system/test/test_sample_management.cpp"},{"location":"Files/test__sample__management_8cpp/#reference_systemtesttest_sample_managementcpp","text":"","title":"reference_system/test/test_sample_management.cpp"},{"location":"Files/test__sample__management_8cpp/#functions","text":"Name TEST (test_sample_management , set_benchmark_mode ) TEST (test_sample_management , is_in_benchmark_mode ) TEST (test_sample_management , sample_helpers ) TEST (test_sample_management , statistic_value_struct ) TEST (test_sample_management , sample_statistic_struct ) TEST (test_sample_management , print_sample_path )","title":"Functions"},{"location":"Files/test__sample__management_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/test__sample__management_8cpp/#function-test","text":"TEST( test_sample_management , set_benchmark_mode )","title":"function TEST"},{"location":"Files/test__sample__management_8cpp/#function-test_1","text":"TEST( test_sample_management , is_in_benchmark_mode )","title":"function TEST"},{"location":"Files/test__sample__management_8cpp/#function-test_2","text":"TEST( test_sample_management , sample_helpers )","title":"function TEST"},{"location":"Files/test__sample__management_8cpp/#function-test_3","text":"TEST( test_sample_management , statistic_value_struct )","title":"function TEST"},{"location":"Files/test__sample__management_8cpp/#function-test_4","text":"TEST( test_sample_management , sample_statistic_struct )","title":"function TEST"},{"location":"Files/test__sample__management_8cpp/#function-test_5","text":"TEST( test_sample_management , print_sample_path )","title":"function TEST"},{"location":"Files/test__sample__management_8cpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <gtest/gtest.h> #include <string> #include \"reference_system/sample_management.hpp\" #include \"reference_system/msg_types.hpp\" TEST(test_sample_management, set_benchmark_mode) { EXPECT_TRUE(set_benchmark_mode(true)); EXPECT_FALSE(set_benchmark_mode(false)); EXPECT_FALSE(set_benchmark_mode(false, false)); } TEST(test_sample_management, is_in_benchmark_mode) { EXPECT_FALSE(is_in_benchmark_mode()); set_benchmark_mode(true); EXPECT_TRUE(is_in_benchmark_mode()); set_benchmark_mode(false); EXPECT_FALSE(is_in_benchmark_mode()); } TEST(test_sample_management, sample_helpers) { message_t sample; std::string node_name = \"test_node\"; uint32_t sequence_number = 10; uint32_t dropped_samples = 5; uint64_t timestamp = 8675309; set_sample(node_name, sequence_number, dropped_samples, timestamp, sample); // EXPECT_EQ(sample.stats[0].node_name.data(), node_name.data()); // see reference_interfaces for more details // 4kb msg = 4032 = 63 * 64 bytes, 64 bytes = TransmissionStats length EXPECT_EQ(sample.stats.size(), size_t(63)); EXPECT_EQ(sample.stats[0].sequence_number, sequence_number); EXPECT_EQ(sample.stats[0].dropped_samples, dropped_samples); EXPECT_EQ(sample.stats[0].timestamp, timestamp); auto retrieved_stamp = get_sample_timestamp(&sample); EXPECT_EQ(retrieved_stamp, timestamp); auto retrieved_sequence_number = get_sample_sequence_number(&sample); EXPECT_EQ(retrieved_sequence_number, sequence_number); auto retrieved_dropped_samples = get_missed_samples_and_update_seq_nr(&sample, sequence_number); // should be zero based on sequence number EXPECT_EQ(retrieved_dropped_samples, uint32_t(0)); } TEST(test_sample_management, statistic_value_struct) { auto stats = statistic_value_t(); stats.suffix = \"the_suffix\"; // simulate multiple messages coming in stats.set(1); stats.set(4); stats.set(5); stats.set(7); EXPECT_EQ(stats.average, 4.25); EXPECT_EQ(stats.deviation, 2.5); EXPECT_EQ(stats.min, uint64_t(1)); EXPECT_EQ(stats.max, uint64_t(7)); EXPECT_EQ(stats.current, uint64_t(7)); EXPECT_EQ(stats.total_number, uint64_t(4)); EXPECT_EQ(stats.suffix, \"the_suffix\"); EXPECT_EQ(stats.adjustment, static_cast<double>(0.0)); } TEST(test_sample_management, sample_statistic_struct) { auto stats = sample_statistic_t(); stats.timepoint_of_first_received_sample = 1; stats.previous_behavior_planner_sequence = 2; stats.previous_behavior_planner_time_stamp = 3; EXPECT_EQ(stats.timepoint_of_first_received_sample, uint64_t(1)); EXPECT_EQ(stats.previous_behavior_planner_sequence, uint32_t(2)); EXPECT_EQ(stats.previous_behavior_planner_time_stamp, uint64_t(3)); } TEST(test_sample_management, print_sample_path) { message_t sample; std::string node_name = \"test_node\"; uint32_t sample_size = 105; // TODO(evan.flynn): add test for operator<< print function used within print_sample_path set_benchmark_mode(false); uint64_t timestamp = 1; for (uint32_t i = 0; i < sample_size; i++) { set_sample(node_name, i, 0, timestamp, sample); timestamp += 1; } // message sample size will always be 63 if message type is set to 4kb // see reference_interfaces package for more details EXPECT_EQ(sample.size, size_t(63)); print_sample_path(\"test_node\", uint32_t(1), &sample); } Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/trace__utils_8py/","text":"autoware_reference_system/test/trace_utils.py Namespaces Name trace_utils Source code # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from tracetools_analysis.loading import load_file from tracetools_analysis.processor.ros2 import Ros2Handler from tracetools_analysis.utils.ros2 import Ros2DataModelUtil def initDataModel(path): events = load_file(path) handler = Ros2Handler.process(events) # handler.data.print_data() return Ros2DataModelUtil(handler.data) Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/test/trace_utils.py"},{"location":"Files/trace__utils_8py/#autoware_reference_systemtesttrace_utilspy","text":"","title":"autoware_reference_system/test/trace_utils.py"},{"location":"Files/trace__utils_8py/#namespaces","text":"Name trace_utils","title":"Namespaces"},{"location":"Files/trace__utils_8py/#source-code","text":"# Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from tracetools_analysis.loading import load_file from tracetools_analysis.processor.ros2 import Ros2Handler from tracetools_analysis.utils.ros2 import Ros2DataModelUtil def initDataModel(path): events = load_file(path) handler = Ros2Handler.process(events) # handler.data.print_data() return Ros2DataModelUtil(handler.data) Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/transform_8hpp/","text":"reference_system/include/reference_system/nodes/rclcpp/transform.hpp Namespaces Name nodes nodes::rclcpp_system Classes Name class nodes::rclcpp_system::Transform Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__RCLCPP__TRANSFORM_HPP_ #define REFERENCE_SYSTEM__NODES__RCLCPP__TRANSFORM_HPP_ #include <chrono> #include <string> #include <utility> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/number_cruncher.hpp\" #include \"reference_system/sample_management.hpp\" #include \"reference_system/msg_types.hpp\" namespace nodes { namespace rclcpp_system { class Transform : public rclcpp::Node { public: explicit Transform(const TransformSettings & settings) : Node(settings.node_name), number_crunch_limit_(settings.number_crunch_limit) { subscription_ = this->create_subscription<message_t>( settings.input_topic, 1, [this](const message_t::SharedPtr msg) {input_callback(msg);}); publisher_ = this->create_publisher<message_t>(settings.output_topic, 1); } private: void input_callback(const message_t::SharedPtr input_message) { uint64_t timestamp = now_as_int(); auto number_cruncher_result = number_cruncher(number_crunch_limit_); auto output_message = publisher_->borrow_loaned_message(); output_message.get().size = 0; merge_history_into_sample(output_message.get(), input_message); uint32_t missed_samples = get_missed_samples_and_update_seq_nr( input_message, input_sequence_number_); set_sample( this->get_name(), sequence_number_++, missed_samples, timestamp, output_message.get()); // use result so that it is not optimizied away by some clever compiler output_message.get().data[0] = number_cruncher_result; publisher_->publish(std::move(output_message)); } private: rclcpp::Publisher<message_t>::SharedPtr publisher_; rclcpp::Subscription<message_t>::SharedPtr subscription_; uint64_t number_crunch_limit_; uint32_t sequence_number_ = 0; uint32_t input_sequence_number_ = 0; }; } // namespace rclcpp_system } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__RCLCPP__TRANSFORM_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_system/include/reference_system/nodes/rclcpp/transform.hpp"},{"location":"Files/transform_8hpp/#reference_systemincludereference_systemnodesrclcpptransformhpp","text":"","title":"reference_system/include/reference_system/nodes/rclcpp/transform.hpp"},{"location":"Files/transform_8hpp/#namespaces","text":"Name nodes nodes::rclcpp_system","title":"Namespaces"},{"location":"Files/transform_8hpp/#classes","text":"Name class nodes::rclcpp_system::Transform","title":"Classes"},{"location":"Files/transform_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__RCLCPP__TRANSFORM_HPP_ #define REFERENCE_SYSTEM__NODES__RCLCPP__TRANSFORM_HPP_ #include <chrono> #include <string> #include <utility> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/number_cruncher.hpp\" #include \"reference_system/sample_management.hpp\" #include \"reference_system/msg_types.hpp\" namespace nodes { namespace rclcpp_system { class Transform : public rclcpp::Node { public: explicit Transform(const TransformSettings & settings) : Node(settings.node_name), number_crunch_limit_(settings.number_crunch_limit) { subscription_ = this->create_subscription<message_t>( settings.input_topic, 1, [this](const message_t::SharedPtr msg) {input_callback(msg);}); publisher_ = this->create_publisher<message_t>(settings.output_topic, 1); } private: void input_callback(const message_t::SharedPtr input_message) { uint64_t timestamp = now_as_int(); auto number_cruncher_result = number_cruncher(number_crunch_limit_); auto output_message = publisher_->borrow_loaned_message(); output_message.get().size = 0; merge_history_into_sample(output_message.get(), input_message); uint32_t missed_samples = get_missed_samples_and_update_seq_nr( input_message, input_sequence_number_); set_sample( this->get_name(), sequence_number_++, missed_samples, timestamp, output_message.get()); // use result so that it is not optimizied away by some clever compiler output_message.get().data[0] = number_cruncher_result; publisher_->publish(std::move(output_message)); } private: rclcpp::Publisher<message_t>::SharedPtr publisher_; rclcpp::Subscription<message_t>::SharedPtr subscription_; uint64_t number_crunch_limit_; uint32_t sequence_number_ = 0; uint32_t input_sequence_number_ = 0; }; } // namespace rclcpp_system } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__RCLCPP__TRANSFORM_HPP_ Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Files/utils_8py/","text":"autoware_reference_system/test/utils.py Namespaces Name utils Source code # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import errno import os from constants import TRACE_CALLBACK, TRACE_MEMORY, TRACE_STD from errors import UnsupportedTraceTypeError def checkDirPath(path: str): # Check if directory exists, raise error directory does not exist if not os.path.isdir(path): raise NotADirectoryError(errno.ENOENT, os.strerror(errno.ENOENT), path) return def getTraceType(path): # Return the trace type based on the given path if TRACE_CALLBACK in path: return TRACE_CALLBACK elif TRACE_MEMORY in path: return TRACE_MEMORY elif TRACE_STD in path: return TRACE_STD else: raise UnsupportedTraceTypeError( 'The given path is not from a supported trace type: ' + path) def getDirPath(path): # Remove filename from given path and return with trailing `/` return os.path.dirname(path) + '/' def getFileName(path): return os.path.splitext(os.path.basename(path))[0] Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system/test/utils.py"},{"location":"Files/utils_8py/#autoware_reference_systemtestutilspy","text":"","title":"autoware_reference_system/test/utils.py"},{"location":"Files/utils_8py/#namespaces","text":"Name utils","title":"Namespaces"},{"location":"Files/utils_8py/#source-code","text":"# Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import errno import os from constants import TRACE_CALLBACK, TRACE_MEMORY, TRACE_STD from errors import UnsupportedTraceTypeError def checkDirPath(path: str): # Check if directory exists, raise error directory does not exist if not os.path.isdir(path): raise NotADirectoryError(errno.ENOENT, os.strerror(errno.ENOENT), path) return def getTraceType(path): # Return the trace type based on the given path if TRACE_CALLBACK in path: return TRACE_CALLBACK elif TRACE_MEMORY in path: return TRACE_MEMORY elif TRACE_STD in path: return TRACE_STD else: raise UnsupportedTraceTypeError( 'The given path is not from a supported trace type: ' + path) def getDirPath(path): # Remove filename from given path and return with trailing `/` return os.path.dirname(path) + '/' def getFileName(path): return os.path.splitext(os.path.basename(path))[0] Updated on 2021-12-24 at 17:45:36 +0000","title":"Source code"},{"location":"Modules/","text":"Modules Updated on 2021-12-24 at 17:45:36 +0000","title":"Modules"},{"location":"Modules/#modules","text":"Updated on 2021-12-24 at 17:45:36 +0000","title":"Modules"},{"location":"Namespaces/","text":"Namespaces namespace callback_duration namespace constants namespace dropped_messages namespace errors namespace generate_callback_traces namespace generate_reports namespace generate_std_traces namespace generate_summary_reports namespace memory_usage namespace nodes namespace rclcpp_system namespace timing namespace rclcpp namespace reference_interfaces namespace msg namespace Message4kb_Constants namespace TransmissionStats_Constants namespace std::chrono_literals namespace std_latency namespace test_platform namespace test_requirements namespace testing namespace trace_utils namespace unittest namespace utils Updated on 2021-12-24 at 17:45:36 +0000","title":"Namespaces"},{"location":"Namespaces/#namespaces","text":"namespace callback_duration namespace constants namespace dropped_messages namespace errors namespace generate_callback_traces namespace generate_reports namespace generate_std_traces namespace generate_summary_reports namespace memory_usage namespace nodes namespace rclcpp_system namespace timing namespace rclcpp namespace reference_interfaces namespace msg namespace Message4kb_Constants namespace TransmissionStats_Constants namespace std::chrono_literals namespace std_latency namespace test_platform namespace test_requirements namespace testing namespace trace_utils namespace unittest namespace utils Updated on 2021-12-24 at 17:45:36 +0000","title":"Namespaces"},{"location":"Namespaces/namespacecallback__duration/","text":"callback_duration Functions Name def summary (data_model data_model, size size) def individual (data_model data_model, size size) Functions Documentation function summary def summary( data_model data_model, size size ) function individual def individual( data_model data_model, size size ) Updated on 2021-12-24 at 17:45:36 +0000","title":"callback_duration"},{"location":"Namespaces/namespacecallback__duration/#callback_duration","text":"","title":"callback_duration"},{"location":"Namespaces/namespacecallback__duration/#functions","text":"Name def summary (data_model data_model, size size) def individual (data_model data_model, size size)","title":"Functions"},{"location":"Namespaces/namespacecallback__duration/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Namespaces/namespacecallback__duration/#function-summary","text":"def summary( data_model data_model, size size )","title":"function summary"},{"location":"Namespaces/namespacecallback__duration/#function-individual","text":"def individual( data_model data_model, size size ) Updated on 2021-12-24 at 17:45:36 +0000","title":"function individual"},{"location":"Namespaces/namespaceconstants/","text":"constants Attributes Name string TRACE_CALLBACK string TRACE_MEMORY string TRACE_STD string TRACE_DIRECTORY int SIZE_SUMMARY int SIZE_SUBPLOT int SIZE_TABLE_ROW int SIZE_TABLE_WIDTH string SIZE_TITLE string SIZE_AXIS_LABEL string SIZE_CATEGORY_LABEL string SIZE_MAJOR_LABEL Attributes Documentation variable TRACE_CALLBACK string TRACE_CALLBACK = 'tracing'; variable TRACE_MEMORY string TRACE_MEMORY = 'memory'; variable TRACE_STD string TRACE_STD = 'log'; variable TRACE_DIRECTORY string TRACE_DIRECTORY = 'tracing'; variable SIZE_SUMMARY int SIZE_SUMMARY = 800; variable SIZE_SUBPLOT int SIZE_SUBPLOT = 500; variable SIZE_TABLE_ROW int SIZE_TABLE_ROW = 50; variable SIZE_TABLE_WIDTH int SIZE_TABLE_WIDTH = 1250; variable SIZE_TITLE string SIZE_TITLE = '22px'; variable SIZE_AXIS_LABEL string SIZE_AXIS_LABEL = '20px'; variable SIZE_CATEGORY_LABEL string SIZE_CATEGORY_LABEL = '15px'; variable SIZE_MAJOR_LABEL string SIZE_MAJOR_LABEL = '14px'; Updated on 2021-12-24 at 17:45:36 +0000","title":"constants"},{"location":"Namespaces/namespaceconstants/#constants","text":"","title":"constants"},{"location":"Namespaces/namespaceconstants/#attributes","text":"Name string TRACE_CALLBACK string TRACE_MEMORY string TRACE_STD string TRACE_DIRECTORY int SIZE_SUMMARY int SIZE_SUBPLOT int SIZE_TABLE_ROW int SIZE_TABLE_WIDTH string SIZE_TITLE string SIZE_AXIS_LABEL string SIZE_CATEGORY_LABEL string SIZE_MAJOR_LABEL","title":"Attributes"},{"location":"Namespaces/namespaceconstants/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Namespaces/namespaceconstants/#variable-trace_callback","text":"string TRACE_CALLBACK = 'tracing';","title":"variable TRACE_CALLBACK"},{"location":"Namespaces/namespaceconstants/#variable-trace_memory","text":"string TRACE_MEMORY = 'memory';","title":"variable TRACE_MEMORY"},{"location":"Namespaces/namespaceconstants/#variable-trace_std","text":"string TRACE_STD = 'log';","title":"variable TRACE_STD"},{"location":"Namespaces/namespaceconstants/#variable-trace_directory","text":"string TRACE_DIRECTORY = 'tracing';","title":"variable TRACE_DIRECTORY"},{"location":"Namespaces/namespaceconstants/#variable-size_summary","text":"int SIZE_SUMMARY = 800;","title":"variable SIZE_SUMMARY"},{"location":"Namespaces/namespaceconstants/#variable-size_subplot","text":"int SIZE_SUBPLOT = 500;","title":"variable SIZE_SUBPLOT"},{"location":"Namespaces/namespaceconstants/#variable-size_table_row","text":"int SIZE_TABLE_ROW = 50;","title":"variable SIZE_TABLE_ROW"},{"location":"Namespaces/namespaceconstants/#variable-size_table_width","text":"int SIZE_TABLE_WIDTH = 1250;","title":"variable SIZE_TABLE_WIDTH"},{"location":"Namespaces/namespaceconstants/#variable-size_title","text":"string SIZE_TITLE = '22px';","title":"variable SIZE_TITLE"},{"location":"Namespaces/namespaceconstants/#variable-size_axis_label","text":"string SIZE_AXIS_LABEL = '20px';","title":"variable SIZE_AXIS_LABEL"},{"location":"Namespaces/namespaceconstants/#variable-size_category_label","text":"string SIZE_CATEGORY_LABEL = '15px';","title":"variable SIZE_CATEGORY_LABEL"},{"location":"Namespaces/namespaceconstants/#variable-size_major_label","text":"string SIZE_MAJOR_LABEL = '14px'; Updated on 2021-12-24 at 17:45:36 +0000","title":"variable SIZE_MAJOR_LABEL"},{"location":"Namespaces/namespacedropped__messages/","text":"dropped_messages Functions Name def summary (path path, duration duration, size size) def individual (data_model data_model, size size) def parseData (data_model data_model) def getRunTime (start start, end end) def calcTotals (run_time run_time, dataframe dataframe) def generateNodeGraph (dataframe dataframe) def countDropped (dataframe dataframe, node_graph node_graph) Functions Documentation function summary def summary( path path, duration duration, size size ) function individual def individual( data_model data_model, size size ) function parseData def parseData( data_model data_model ) function getRunTime def getRunTime( start start, end end ) function calcTotals def calcTotals( run_time run_time, dataframe dataframe ) function generateNodeGraph def generateNodeGraph( dataframe dataframe ) function countDropped def countDropped( dataframe dataframe, node_graph node_graph ) Updated on 2021-12-24 at 17:45:36 +0000","title":"dropped_messages"},{"location":"Namespaces/namespacedropped__messages/#dropped_messages","text":"","title":"dropped_messages"},{"location":"Namespaces/namespacedropped__messages/#functions","text":"Name def summary (path path, duration duration, size size) def individual (data_model data_model, size size) def parseData (data_model data_model) def getRunTime (start start, end end) def calcTotals (run_time run_time, dataframe dataframe) def generateNodeGraph (dataframe dataframe) def countDropped (dataframe dataframe, node_graph node_graph)","title":"Functions"},{"location":"Namespaces/namespacedropped__messages/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Namespaces/namespacedropped__messages/#function-summary","text":"def summary( path path, duration duration, size size )","title":"function summary"},{"location":"Namespaces/namespacedropped__messages/#function-individual","text":"def individual( data_model data_model, size size )","title":"function individual"},{"location":"Namespaces/namespacedropped__messages/#function-parsedata","text":"def parseData( data_model data_model )","title":"function parseData"},{"location":"Namespaces/namespacedropped__messages/#function-getruntime","text":"def getRunTime( start start, end end )","title":"function getRunTime"},{"location":"Namespaces/namespacedropped__messages/#function-calctotals","text":"def calcTotals( run_time run_time, dataframe dataframe )","title":"function calcTotals"},{"location":"Namespaces/namespacedropped__messages/#function-generatenodegraph","text":"def generateNodeGraph( dataframe dataframe )","title":"function generateNodeGraph"},{"location":"Namespaces/namespacedropped__messages/#function-countdropped","text":"def countDropped( dataframe dataframe, node_graph node_graph ) Updated on 2021-12-24 at 17:45:36 +0000","title":"function countDropped"},{"location":"Namespaces/namespaceerrors/","text":"errors Classes Name class errors::UnsupportedTraceTypeError Updated on 2021-12-24 at 17:45:36 +0000","title":"errors"},{"location":"Namespaces/namespaceerrors/#errors","text":"","title":"errors"},{"location":"Namespaces/namespaceerrors/#classes","text":"Name class errors::UnsupportedTraceTypeError Updated on 2021-12-24 at 17:45:36 +0000","title":"Classes"},{"location":"Namespaces/namespacegenerate__callback__traces/","text":"generate_callback_traces Classes Name class generate_callback_traces::TestGenerateTracesAutowareReferenceSystem Functions Name def generate_test_description () Attributes Name RUNTIME Functions Documentation function generate_test_description def generate_test_description() Attributes Documentation variable RUNTIME RUNTIME = int('@RUNTIME@'); Updated on 2021-12-24 at 17:45:36 +0000","title":"generate_callback_traces"},{"location":"Namespaces/namespacegenerate__callback__traces/#generate_callback_traces","text":"","title":"generate_callback_traces"},{"location":"Namespaces/namespacegenerate__callback__traces/#classes","text":"Name class generate_callback_traces::TestGenerateTracesAutowareReferenceSystem","title":"Classes"},{"location":"Namespaces/namespacegenerate__callback__traces/#functions","text":"Name def generate_test_description ()","title":"Functions"},{"location":"Namespaces/namespacegenerate__callback__traces/#attributes","text":"Name RUNTIME","title":"Attributes"},{"location":"Namespaces/namespacegenerate__callback__traces/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Namespaces/namespacegenerate__callback__traces/#function-generate_test_description","text":"def generate_test_description()","title":"function generate_test_description"},{"location":"Namespaces/namespacegenerate__callback__traces/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Namespaces/namespacegenerate__callback__traces/#variable-runtime","text":"RUNTIME = int('@RUNTIME@'); Updated on 2021-12-24 at 17:45:36 +0000","title":"variable RUNTIME"},{"location":"Namespaces/namespacegenerate__reports/","text":"generate_reports Functions Name def memory_report (wd wd, filename filename) def std_report (wd wd, filename filename) def callback_report (wd wd, filename filename, ros2_data_model ros2_data_model) def dropped_messages_report (wd wd, filename filename, ros2_data_model ros2_data_model) def generate_reports (wd wd, fname fname, trace_type trace_type, ros2_data_model ros2_data_model) Attributes Name string path wd fname trace_type ros2_data_model Functions Documentation function memory_report def memory_report( wd wd, filename filename ) function std_report def std_report( wd wd, filename filename ) function callback_report def callback_report( wd wd, filename filename, ros2_data_model ros2_data_model ) function dropped_messages_report def dropped_messages_report( wd wd, filename filename, ros2_data_model ros2_data_model ) function generate_reports def generate_reports( wd wd, fname fname, trace_type trace_type, ros2_data_model ros2_data_model ) Attributes Documentation variable path string path = 'path'; variable wd wd = getDirPath(path); variable fname fname = getFileName(path); variable trace_type trace_type = getTraceType(wd); variable ros2_data_model ros2_data_model = initDataModel(path); Updated on 2021-12-24 at 17:45:36 +0000","title":"generate_reports"},{"location":"Namespaces/namespacegenerate__reports/#generate_reports","text":"","title":"generate_reports"},{"location":"Namespaces/namespacegenerate__reports/#functions","text":"Name def memory_report (wd wd, filename filename) def std_report (wd wd, filename filename) def callback_report (wd wd, filename filename, ros2_data_model ros2_data_model) def dropped_messages_report (wd wd, filename filename, ros2_data_model ros2_data_model) def generate_reports (wd wd, fname fname, trace_type trace_type, ros2_data_model ros2_data_model)","title":"Functions"},{"location":"Namespaces/namespacegenerate__reports/#attributes","text":"Name string path wd fname trace_type ros2_data_model","title":"Attributes"},{"location":"Namespaces/namespacegenerate__reports/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Namespaces/namespacegenerate__reports/#function-memory_report","text":"def memory_report( wd wd, filename filename )","title":"function memory_report"},{"location":"Namespaces/namespacegenerate__reports/#function-std_report","text":"def std_report( wd wd, filename filename )","title":"function std_report"},{"location":"Namespaces/namespacegenerate__reports/#function-callback_report","text":"def callback_report( wd wd, filename filename, ros2_data_model ros2_data_model )","title":"function callback_report"},{"location":"Namespaces/namespacegenerate__reports/#function-dropped_messages_report","text":"def dropped_messages_report( wd wd, filename filename, ros2_data_model ros2_data_model )","title":"function dropped_messages_report"},{"location":"Namespaces/namespacegenerate__reports/#function-generate_reports","text":"def generate_reports( wd wd, fname fname, trace_type trace_type, ros2_data_model ros2_data_model )","title":"function generate_reports"},{"location":"Namespaces/namespacegenerate__reports/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Namespaces/namespacegenerate__reports/#variable-path","text":"string path = 'path';","title":"variable path"},{"location":"Namespaces/namespacegenerate__reports/#variable-wd","text":"wd = getDirPath(path);","title":"variable wd"},{"location":"Namespaces/namespacegenerate__reports/#variable-fname","text":"fname = getFileName(path);","title":"variable fname"},{"location":"Namespaces/namespacegenerate__reports/#variable-trace_type","text":"trace_type = getTraceType(wd);","title":"variable trace_type"},{"location":"Namespaces/namespacegenerate__reports/#variable-ros2_data_model","text":"ros2_data_model = initDataModel(path); Updated on 2021-12-24 at 17:45:36 +0000","title":"variable ros2_data_model"},{"location":"Namespaces/namespacegenerate__std__traces/","text":"generate_std_traces Classes Name class generate_std_traces::TestGenerateTracesAutowareReferenceSystem Functions Name def generate_test_description () Attributes Name RUNTIME Functions Documentation function generate_test_description def generate_test_description() Attributes Documentation variable RUNTIME RUNTIME = int('@RUNTIME@'); Updated on 2021-12-24 at 17:45:36 +0000","title":"generate_std_traces"},{"location":"Namespaces/namespacegenerate__std__traces/#generate_std_traces","text":"","title":"generate_std_traces"},{"location":"Namespaces/namespacegenerate__std__traces/#classes","text":"Name class generate_std_traces::TestGenerateTracesAutowareReferenceSystem","title":"Classes"},{"location":"Namespaces/namespacegenerate__std__traces/#functions","text":"Name def generate_test_description ()","title":"Functions"},{"location":"Namespaces/namespacegenerate__std__traces/#attributes","text":"Name RUNTIME","title":"Attributes"},{"location":"Namespaces/namespacegenerate__std__traces/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Namespaces/namespacegenerate__std__traces/#function-generate_test_description","text":"def generate_test_description()","title":"function generate_test_description"},{"location":"Namespaces/namespacegenerate__std__traces/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Namespaces/namespacegenerate__std__traces/#variable-runtime","text":"RUNTIME = int('@RUNTIME@'); Updated on 2021-12-24 at 17:45:36 +0000","title":"variable RUNTIME"},{"location":"Namespaces/namespacegenerate__summary__reports/","text":"generate_summary_reports Functions Name def memory_summary_report (path path, duration duration) def std_summary_report (path path, duration duration) def dropped_summary_report (path path, duration duration) def generate_summary_reports (path path, duration duration) Attributes Name path duration wd tracetype Functions Documentation function memory_summary_report def memory_summary_report( path path, duration duration ) function std_summary_report def std_summary_report( path path, duration duration ) function dropped_summary_report def dropped_summary_report( path path, duration duration ) function generate_summary_reports def generate_summary_reports( path path, duration duration ) Attributes Documentation variable path path = sys.argv[1]; variable duration duration = sys.argv[2]; variable wd wd = getDirPath(path); variable tracetype tracetype = getFileName(path); Updated on 2021-12-24 at 17:45:36 +0000","title":"generate_summary_reports"},{"location":"Namespaces/namespacegenerate__summary__reports/#generate_summary_reports","text":"","title":"generate_summary_reports"},{"location":"Namespaces/namespacegenerate__summary__reports/#functions","text":"Name def memory_summary_report (path path, duration duration) def std_summary_report (path path, duration duration) def dropped_summary_report (path path, duration duration) def generate_summary_reports (path path, duration duration)","title":"Functions"},{"location":"Namespaces/namespacegenerate__summary__reports/#attributes","text":"Name path duration wd tracetype","title":"Attributes"},{"location":"Namespaces/namespacegenerate__summary__reports/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Namespaces/namespacegenerate__summary__reports/#function-memory_summary_report","text":"def memory_summary_report( path path, duration duration )","title":"function memory_summary_report"},{"location":"Namespaces/namespacegenerate__summary__reports/#function-std_summary_report","text":"def std_summary_report( path path, duration duration )","title":"function std_summary_report"},{"location":"Namespaces/namespacegenerate__summary__reports/#function-dropped_summary_report","text":"def dropped_summary_report( path path, duration duration )","title":"function dropped_summary_report"},{"location":"Namespaces/namespacegenerate__summary__reports/#function-generate_summary_reports","text":"def generate_summary_reports( path path, duration duration )","title":"function generate_summary_reports"},{"location":"Namespaces/namespacegenerate__summary__reports/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Namespaces/namespacegenerate__summary__reports/#variable-path","text":"path = sys.argv[1];","title":"variable path"},{"location":"Namespaces/namespacegenerate__summary__reports/#variable-duration","text":"duration = sys.argv[2];","title":"variable duration"},{"location":"Namespaces/namespacegenerate__summary__reports/#variable-wd","text":"wd = getDirPath(path);","title":"variable wd"},{"location":"Namespaces/namespacegenerate__summary__reports/#variable-tracetype","text":"tracetype = getFileName(path); Updated on 2021-12-24 at 17:45:36 +0000","title":"variable tracetype"},{"location":"Namespaces/namespacememory__usage/","text":"memory_usage Functions Name def summary (path path, duration duration, size size) def individual (path path, size size) Functions Documentation function summary def summary( path path, duration duration, size size ) function individual def individual( path path, size size ) Updated on 2021-12-24 at 17:45:36 +0000","title":"memory_usage"},{"location":"Namespaces/namespacememory__usage/#memory_usage","text":"","title":"memory_usage"},{"location":"Namespaces/namespacememory__usage/#functions","text":"Name def summary (path path, duration duration, size size) def individual (path path, size size)","title":"Functions"},{"location":"Namespaces/namespacememory__usage/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Namespaces/namespacememory__usage/#function-summary","text":"def summary( path path, duration duration, size size )","title":"function summary"},{"location":"Namespaces/namespacememory__usage/#function-individual","text":"def individual( path path, size size ) Updated on 2021-12-24 at 17:45:36 +0000","title":"function individual"},{"location":"Namespaces/namespacenodes/","text":"nodes Namespaces Name nodes::rclcpp_system nodes::timing Classes Name struct nodes::CommandSettings struct nodes::FusionSettings struct nodes::TransformSettings struct nodes::IntersectionSettings struct nodes::CyclicSettings struct nodes::SensorSettings Updated on 2021-12-24 at 17:45:36 +0000","title":"nodes"},{"location":"Namespaces/namespacenodes/#nodes","text":"","title":"nodes"},{"location":"Namespaces/namespacenodes/#namespaces","text":"Name nodes::rclcpp_system nodes::timing","title":"Namespaces"},{"location":"Namespaces/namespacenodes/#classes","text":"Name struct nodes::CommandSettings struct nodes::FusionSettings struct nodes::TransformSettings struct nodes::IntersectionSettings struct nodes::CyclicSettings struct nodes::SensorSettings Updated on 2021-12-24 at 17:45:36 +0000","title":"Classes"},{"location":"Namespaces/namespacenodes_1_1rclcpp__system/","text":"nodes::rclcpp_system Classes Name class nodes::rclcpp_system::Command class nodes::rclcpp_system::Cyclic class nodes::rclcpp_system::Fusion class nodes::rclcpp_system::Intersection class nodes::rclcpp_system::Sensor class nodes::rclcpp_system::Transform Updated on 2021-12-24 at 17:45:36 +0000","title":"nodes::rclcpp_system"},{"location":"Namespaces/namespacenodes_1_1rclcpp__system/#nodesrclcpp_system","text":"","title":"nodes::rclcpp_system"},{"location":"Namespaces/namespacenodes_1_1rclcpp__system/#classes","text":"Name class nodes::rclcpp_system::Command class nodes::rclcpp_system::Cyclic class nodes::rclcpp_system::Fusion class nodes::rclcpp_system::Intersection class nodes::rclcpp_system::Sensor class nodes::rclcpp_system::Transform Updated on 2021-12-24 at 17:45:36 +0000","title":"Classes"},{"location":"Namespaces/namespacenodes_1_1timing/","text":"nodes::timing Classes Name struct nodes::timing::BenchmarkThroughput struct nodes::timing::BenchmarkCPUUsage struct nodes::timing::Default Updated on 2021-12-24 at 17:45:36 +0000","title":"nodes::timing"},{"location":"Namespaces/namespacenodes_1_1timing/#nodestiming","text":"","title":"nodes::timing"},{"location":"Namespaces/namespacenodes_1_1timing/#classes","text":"Name struct nodes::timing::BenchmarkThroughput struct nodes::timing::BenchmarkCPUUsage struct nodes::timing::Default Updated on 2021-12-24 at 17:45:36 +0000","title":"Classes"},{"location":"Namespaces/namespacerclcpp/","text":"rclcpp Updated on 2021-12-24 at 17:45:36 +0000","title":"rclcpp"},{"location":"Namespaces/namespacerclcpp/#rclcpp","text":"Updated on 2021-12-24 at 17:45:36 +0000","title":"rclcpp"},{"location":"Namespaces/namespacereference__interfaces/","text":"reference_interfaces Namespaces Name reference_interfaces::msg Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_interfaces"},{"location":"Namespaces/namespacereference__interfaces/#reference_interfaces","text":"","title":"reference_interfaces"},{"location":"Namespaces/namespacereference__interfaces/#namespaces","text":"Name reference_interfaces::msg Updated on 2021-12-24 at 17:45:36 +0000","title":"Namespaces"},{"location":"Namespaces/namespacereference__interfaces_1_1msg/","text":"reference_interfaces::msg Namespaces Name reference_interfaces::msg::Message4kb_Constants reference_interfaces::msg::TransmissionStats_Constants Classes Name struct reference_interfaces::msg::Message4kb struct reference_interfaces::msg::TransmissionStats Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_interfaces::msg"},{"location":"Namespaces/namespacereference__interfaces_1_1msg/#reference_interfacesmsg","text":"","title":"reference_interfaces::msg"},{"location":"Namespaces/namespacereference__interfaces_1_1msg/#namespaces","text":"Name reference_interfaces::msg::Message4kb_Constants reference_interfaces::msg::TransmissionStats_Constants","title":"Namespaces"},{"location":"Namespaces/namespacereference__interfaces_1_1msg/#classes","text":"Name struct reference_interfaces::msg::Message4kb struct reference_interfaces::msg::TransmissionStats Updated on 2021-12-24 at 17:45:36 +0000","title":"Classes"},{"location":"Namespaces/namespacereference__interfaces_1_1msg_1_1Message4kb__Constants/","text":"reference_interfaces::msg::Message4kb_Constants Attributes Name const uint64 STATS_CAPACITY Attributes Documentation variable STATS_CAPACITY const uint64 STATS_CAPACITY = 63; Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_interfaces::msg::Message4kb_Constants"},{"location":"Namespaces/namespacereference__interfaces_1_1msg_1_1Message4kb__Constants/#reference_interfacesmsgmessage4kb_constants","text":"","title":"reference_interfaces::msg::Message4kb_Constants"},{"location":"Namespaces/namespacereference__interfaces_1_1msg_1_1Message4kb__Constants/#attributes","text":"Name const uint64 STATS_CAPACITY","title":"Attributes"},{"location":"Namespaces/namespacereference__interfaces_1_1msg_1_1Message4kb__Constants/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Namespaces/namespacereference__interfaces_1_1msg_1_1Message4kb__Constants/#variable-stats_capacity","text":"const uint64 STATS_CAPACITY = 63; Updated on 2021-12-24 at 17:45:36 +0000","title":"variable STATS_CAPACITY"},{"location":"Namespaces/namespacereference__interfaces_1_1msg_1_1TransmissionStats__Constants/","text":"reference_interfaces::msg::TransmissionStats_Constants Attributes Name const uint64 NODE_NAME_LENGTH Attributes Documentation variable NODE_NAME_LENGTH const uint64 NODE_NAME_LENGTH = 48; Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_interfaces::msg::TransmissionStats_Constants"},{"location":"Namespaces/namespacereference__interfaces_1_1msg_1_1TransmissionStats__Constants/#reference_interfacesmsgtransmissionstats_constants","text":"","title":"reference_interfaces::msg::TransmissionStats_Constants"},{"location":"Namespaces/namespacereference__interfaces_1_1msg_1_1TransmissionStats__Constants/#attributes","text":"Name const uint64 NODE_NAME_LENGTH","title":"Attributes"},{"location":"Namespaces/namespacereference__interfaces_1_1msg_1_1TransmissionStats__Constants/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Namespaces/namespacereference__interfaces_1_1msg_1_1TransmissionStats__Constants/#variable-node_name_length","text":"const uint64 NODE_NAME_LENGTH = 48; Updated on 2021-12-24 at 17:45:36 +0000","title":"variable NODE_NAME_LENGTH"},{"location":"Namespaces/namespacestd_1_1chrono__literals/","text":"std::chrono_literals Updated on 2021-12-24 at 17:45:36 +0000","title":"std::chrono_literals"},{"location":"Namespaces/namespacestd_1_1chrono__literals/#stdchrono_literals","text":"Updated on 2021-12-24 at 17:45:36 +0000","title":"std::chrono_literals"},{"location":"Namespaces/namespacestd__latency/","text":"std_latency Functions Name def summary (path path, duration duration, size size) def parseLogSummary (path path, duration duration) def parseStats (line line) Functions Documentation function summary def summary( path path, duration duration, size size ) function parseLogSummary def parseLogSummary( path path, duration duration ) function parseStats def parseStats( line line ) Updated on 2021-12-24 at 17:45:36 +0000","title":"std_latency"},{"location":"Namespaces/namespacestd__latency/#std_latency","text":"","title":"std_latency"},{"location":"Namespaces/namespacestd__latency/#functions","text":"Name def summary (path path, duration duration, size size) def parseLogSummary (path path, duration duration) def parseStats (line line)","title":"Functions"},{"location":"Namespaces/namespacestd__latency/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Namespaces/namespacestd__latency/#function-summary","text":"def summary( path path, duration duration, size size )","title":"function summary"},{"location":"Namespaces/namespacestd__latency/#function-parselogsummary","text":"def parseLogSummary( path path, duration duration )","title":"function parseLogSummary"},{"location":"Namespaces/namespacestd__latency/#function-parsestats","text":"def parseStats( line line ) Updated on 2021-12-24 at 17:45:36 +0000","title":"function parseStats"},{"location":"Namespaces/namespacetest__platform/","text":"test_platform Functions Name def test_platform (record_property record_property) Attributes Name dictionary platforms Functions Documentation function test_platform def test_platform( record_property record_property ) Attributes Documentation variable platforms dictionary platforms = {}; Updated on 2021-12-24 at 17:45:36 +0000","title":"test_platform"},{"location":"Namespaces/namespacetest__platform/#test_platform","text":"","title":"test_platform"},{"location":"Namespaces/namespacetest__platform/#functions","text":"Name def test_platform (record_property record_property)","title":"Functions"},{"location":"Namespaces/namespacetest__platform/#attributes","text":"Name dictionary platforms","title":"Attributes"},{"location":"Namespaces/namespacetest__platform/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Namespaces/namespacetest__platform/#function-test_platform","text":"def test_platform( record_property record_property )","title":"function test_platform"},{"location":"Namespaces/namespacetest__platform/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Namespaces/namespacetest__platform/#variable-platforms","text":"dictionary platforms = {}; Updated on 2021-12-24 at 17:45:36 +0000","title":"variable platforms"},{"location":"Namespaces/namespacetest__requirements/","text":"test_requirements Classes Name class test_requirements::TestRequirementsAutowareReferenceSystem Functions Name def generate_test_description () Attributes Name dictionary checks dictionary reference_system Functions Documentation function generate_test_description def generate_test_description() Attributes Documentation variable checks dictionary checks = {'topic_exists': False, 'pubs_match': False, 'subs_match': False}; variable reference_system dictionary reference_system = { '/FrontLidarDriver': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/RearLidarDriver': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointCloudMap': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/Visualizer': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/Lanelet2Map': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointsTransformerFront': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointsTransformerRear': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/VoxelGridDownsampler': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointCloudMapLoader': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/EuclideanClusterDetector': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/ObjectCollisionEstimator': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/MPCController': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/ParkingPlanner': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/LanePlanner': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointCloudFusion': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()}, '/NDTLocalizer': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()}, '/VehicleInterface': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/Lanelet2GlobalPlanner': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()}, '/Lanelet2MapLoader': {'pub_count': 1, 'sub_count': 3, 'checks': checks.copy()}, '/BehaviorPlanner': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()} # does not exist as topic but only as a node # '/VehicleDBWSystem': {'pub_count': 0, 'sub_count': 0, 'checks': checks.copy()} }; Updated on 2021-12-24 at 17:45:36 +0000","title":"test_requirements"},{"location":"Namespaces/namespacetest__requirements/#test_requirements","text":"","title":"test_requirements"},{"location":"Namespaces/namespacetest__requirements/#classes","text":"Name class test_requirements::TestRequirementsAutowareReferenceSystem","title":"Classes"},{"location":"Namespaces/namespacetest__requirements/#functions","text":"Name def generate_test_description ()","title":"Functions"},{"location":"Namespaces/namespacetest__requirements/#attributes","text":"Name dictionary checks dictionary reference_system","title":"Attributes"},{"location":"Namespaces/namespacetest__requirements/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Namespaces/namespacetest__requirements/#function-generate_test_description","text":"def generate_test_description()","title":"function generate_test_description"},{"location":"Namespaces/namespacetest__requirements/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Namespaces/namespacetest__requirements/#variable-checks","text":"dictionary checks = {'topic_exists': False, 'pubs_match': False, 'subs_match': False};","title":"variable checks"},{"location":"Namespaces/namespacetest__requirements/#variable-reference_system","text":"dictionary reference_system = { '/FrontLidarDriver': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/RearLidarDriver': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointCloudMap': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/Visualizer': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/Lanelet2Map': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointsTransformerFront': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointsTransformerRear': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/VoxelGridDownsampler': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointCloudMapLoader': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/EuclideanClusterDetector': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/ObjectCollisionEstimator': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/MPCController': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/ParkingPlanner': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/LanePlanner': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointCloudFusion': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()}, '/NDTLocalizer': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()}, '/VehicleInterface': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/Lanelet2GlobalPlanner': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()}, '/Lanelet2MapLoader': {'pub_count': 1, 'sub_count': 3, 'checks': checks.copy()}, '/BehaviorPlanner': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()} # does not exist as topic but only as a node # '/VehicleDBWSystem': {'pub_count': 0, 'sub_count': 0, 'checks': checks.copy()} }; Updated on 2021-12-24 at 17:45:36 +0000","title":"variable reference_system"},{"location":"Namespaces/namespacetesting/","text":"testing Updated on 2021-12-24 at 17:45:36 +0000","title":"testing"},{"location":"Namespaces/namespacetesting/#testing","text":"Updated on 2021-12-24 at 17:45:36 +0000","title":"testing"},{"location":"Namespaces/namespacetrace__utils/","text":"trace_utils Functions Name def initDataModel (path path) Functions Documentation function initDataModel def initDataModel( path path ) Updated on 2021-12-24 at 17:45:36 +0000","title":"trace_utils"},{"location":"Namespaces/namespacetrace__utils/#trace_utils","text":"","title":"trace_utils"},{"location":"Namespaces/namespacetrace__utils/#functions","text":"Name def initDataModel (path path)","title":"Functions"},{"location":"Namespaces/namespacetrace__utils/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Namespaces/namespacetrace__utils/#function-initdatamodel","text":"def initDataModel( path path ) Updated on 2021-12-24 at 17:45:36 +0000","title":"function initDataModel"},{"location":"Namespaces/namespaceunittest/","text":"unittest Updated on 2021-12-24 at 17:45:36 +0000","title":"unittest"},{"location":"Namespaces/namespaceunittest/#unittest","text":"Updated on 2021-12-24 at 17:45:36 +0000","title":"unittest"},{"location":"Namespaces/namespaceutils/","text":"utils Functions Name def checkDirPath (str path) def getTraceType (path path) def getDirPath (path path) def getFileName (path path) Functions Documentation function checkDirPath def checkDirPath( str path ) function getTraceType def getTraceType( path path ) function getDirPath def getDirPath( path path ) function getFileName def getFileName( path path ) Updated on 2021-12-24 at 17:45:36 +0000","title":"utils"},{"location":"Namespaces/namespaceutils/#utils","text":"","title":"utils"},{"location":"Namespaces/namespaceutils/#functions","text":"Name def checkDirPath (str path) def getTraceType (path path) def getDirPath (path path) def getFileName (path path)","title":"Functions"},{"location":"Namespaces/namespaceutils/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Namespaces/namespaceutils/#function-checkdirpath","text":"def checkDirPath( str path )","title":"function checkDirPath"},{"location":"Namespaces/namespaceutils/#function-gettracetype","text":"def getTraceType( path path )","title":"function getTraceType"},{"location":"Namespaces/namespaceutils/#function-getdirpath","text":"def getDirPath( path path )","title":"function getDirPath"},{"location":"Namespaces/namespaceutils/#function-getfilename","text":"def getFileName( path path ) Updated on 2021-12-24 at 17:45:36 +0000","title":"function getFileName"},{"location":"Pages/","text":"Pages page Overview page autoware_reference_system page reference_system Updated on 2021-12-24 at 17:45:36 +0000","title":"Pages"},{"location":"Pages/#pages","text":"page Overview page autoware_reference_system page reference_system Updated on 2021-12-24 at 17:45:36 +0000","title":"Pages"},{"location":"Pages/md_README/","text":"Overview With the distributed development of ROS across many different organizations it is sometimes hard to benchmark and concretely show how a certain change to a certain system improves or reduces the performance of that system. For example did a change from one executor to another actually reduce the CPU or was it something else entirely? In order to try and address this problem we at Apex.AI would like to propose a definition of a reference system that simulates a real world scenario - in this first case Autoware.Auto and its lidar data pipeline - that can be repeated no matter the underlying change of any piece of the full stack (i.e. executor, DDS or even RMW). Future reference systems could be proposed that are more complex using the same basic node building blocks within the reference_system package. Reference System A reference system is defined by: A platform is defined by: Hardware (e.g. an off-the-shelf single-board computer, embedded ECU, etc.) if there are multiple configurations available for such hardware, ensure it is specified Operating System (OS) like RT linux, QNX, etc. along with any special configurations made for simplicity and ease of benchmarking, all nodes must run on a single process a fixed number of nodes each node with: a fixed number of publishers and subscribers a fixed processing time or a fixed publishing rate a fixed message type of fixed size to be used for every node . With these defined attributes the reference system can be replicated across many different possible configurations to be used to benchmark each configuration against the other in a reliable and fair manner. With this approach portable and repeatable tests can also be defined to reliably confirm if a given reference system meets the requirements. Supported Platforms To enable as many people as possible to replicate this reference system, the platform(s) were chosen to be easily accessible (inexpensive, high volume), have lots of documentation, large community use and will be supported well into the future. Platforms were not chosen for performance of the reference system - we know we could run \u201cfaster\u201d with a more powerful CPU or GPU but then it would be harder for others to validate findings and test their own configurations. Accessibility is the key here and will be considered if more platforms want to be added to this benchmark list. Platforms: Raspberry Pi 4B : 4 GB RAM version is the assumed default other versions could also be tested / added by the community real-time linux kernel Note: create an issue to add more platforms to the list, keeping in mind the above criteria Concept Overview Rather than trying to write code to cover all potential variations of executors, APIs, and future features we cannot even imagine today we have chosen instead to define what we call a \u201creference system\u201d based on part of a real-world system, Autoware.Auto . The above node graph can be boiled down to only a handful of node \"types\" that are replicated to make this complex system: Node Types: Sensor Node input node to system one publisher, zero subscribers publishes message cyclically at some fixed frequency Transform Node one subscriber, one publisher starts processing for N milliseconds after a message is received publishes message after processing is complete Fusion Node 2 subscribers, one publisher starts processing for N milliseconds after a message is received from all subscriptions publishes message after processing is complete Cyclic Node N subscribers, one publisher cyclically processes all received messages since the last cycle for N milliseconds publishes message after processing is complete Command Node prints output stats everytime a message is received Intersection Node behaves like N transform nodes N subscribers, N publisher bundled together in one-to-one connections starts processing on connection where sample was received publishes message after processing is complete These basic building-block nodes can be mixed-and-matched to create quite complex systems that replicate real-world scenarios to benchmark different configurations against each other. Reference Systems Overview The first reference system benchmark proposed is based on the Autoware.Auto lidar data pipeline as stated above and shown in the node graph image above as well. Autoware Reference System ROS2: Executors: Default: Single Threaded Static Single Threaded Multithreaded Results below show various characteristics of the same simulated system (Autoware.Auto). To add your own executor to the list above follow the how to add your custom executor section below. Benchmark Results Results will be added to different tagged releases along with the specific configurations ran during the tests. Testing and Dependencies Tests and dependencies will be written uniquely for each reference system. Please go to the README.md file specific for the reference system you would like to run to view the instructions on how to set it up and run yourself. Autoware Reference System Contributing If you see a missing configuration on the list above that you would like to see benchmarked against please follow the steps below to request it to be added. look over the open / closed issues to make sure there isn't already an open ticket for the configuration you are looking for create include/reference_system/MY_EXECUTOR_NAME_nodes How to Implement Your Custom Executor Read over the above documentation on the base node types Review the base rclcpp nodes that are provided and determine if your executor can use them If you cannot, implment your own version of each base node type and place the source in with the other nodes in the reference_system . Add your new nodes as a seperate node system in the reference_system package Copy one of the provided example .cpp files from the src/ros2/executor directory and replace the create_autoware_nodes template type with your new node system which should be in the [system/systems.hpp] file already included Add new .cpp source file as a new executable in the CMakelist.txt Add new executable to test wtihin the CMakelist.txt Build and run tests! Setup Raspberry Pi 4 for the test The goal is to provide a clean computation environment for the test avoiding an interference of other Ubuntu components. Setup a constant CPU frequency Frequency is setup to 1.50 GHz for all CPUs # run it as root sudo su echo -n \"setup constant CPU frequency to 1.50 GHz ... \" # disable ondemand governor systemctl disable ondemand # set performance governor for all cpus echo performance | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor >/dev/null # set constant frequency echo 1500000 | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_min_freq >/dev/null echo 1500000 | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_max_freq >/dev/null # reset frequency counters echo 1 | tee /sys/devices/system/cpu/cpu*/cpufreq/stats/reset >/dev/null echo done sleep 1 # get freq info echo `cpufreq-info | grep stats | cut -d ' ' -f 23-25` Isolate CPUs CPU 2,3 are isolated to run tests. sudo apt install -y sysstat u-boot-tools # modify kernel cmdline cd ~ dd if=/boot/firmware/boot.scr of=boot.script bs=72 skip=1 # edit boot.script and modify bootargs to ubuntu@ubuntu:~$ cat boot.script | grep \"setenv bootargs\" | head -1 setenv bootargs \" ${bootargs} rcu_nocbs=2,3 nohz_full=2,3 isolcpus=2,3 irqaffinity=0,1 audit=0 watchdog=0 skew_tick=1 quiet splash\" # generate boot.scr mkimage -A arm64 -O linux -T script -C none -d boot.script boot.scr # replace boot.scr sudo cp boot.scr /boot/firmware/boot.scr sudo reboot # check cmdline ubuntu@ubuntu:~$ cat /proc/cmdline coherent_pool=1M 8250.nr_uarts=1 snd_bcm2835.enable_compat_alsa=0 snd_bcm2835.enable_hdmi=1 bcm2708_fb.fbwidth=0 bcm2708_fb.fbheight=0 bcm2708_fb.fbswap=1 smsc95xx.macaddr=DC:A6:32:2E:5 4:97 vc_mem.mem_base=0x3ec00000 vc_mem.mem_size=0x40000000 net.ifnames=0 dwc_otg.lpm_enable=0 console=ttyS0,115200 console=tty1 root=LABEL=writable rootfstype=ext4 elevator=deadline roo twait fixrtc rcu_nocbs=2,3 nohz_full=2,3 isolcpus=2,3 irqaffinity=0,1 audit=0 watchdog=0 skew_tick=1 quiet splash # check interrupts # Only the number of interrupts handled by CPU 0,1 increases. watch -n1 cat /proc/interrupts # check soft interrupts watch -n1 cat /proc/softirqs # check isolated CPUs cat /sys/devices/system/cpu/isolated 2-3 cat /sys/devices/system/cpu/present 0-3 # run reference system on CPU2 taskset -c 2 install/autoware_reference_system/lib/autoware_reference_system/autoware_default_singlethreaded > /dev/null # get pid RF_PID=`pidof autoware_default_singlethreaded` && cat /proc/$RF_PID/status | grep ^Cpu # check how many threads are running ps -aL | grep $RF_PID 3835 3835 ttyS0 00:03:46 autoware_defaul 3835 3836 ttyS0 00:00:00 autoware_defaul 3835 3837 ttyS0 00:00:00 autoware_defaul 3835 3838 ttyS0 00:00:00 autoware_defaul 3835 3839 ttyS0 00:00:00 gc 3835 3840 ttyS0 00:00:00 dq.builtins 3835 3841 ttyS0 00:00:00 dq.user 3835 3842 ttyS0 00:00:00 tev 3835 3843 ttyS0 00:00:00 recv 3835 3844 ttyS0 00:00:00 recvMC 3835 3845 ttyS0 00:00:00 recvUC 3835 3846 ttyS0 00:00:00 autoware_defaul Hints If you run colcon build on a Raspberry Pi 4 with little memory, use export MAKEFLAGS=\"-j 1\" to inhibit parallelism. Otherwise, the system could hang due to memory swapping. Updated on 2021-12-24 at 17:45:36 +0000","title":"Overview <a href=\"https://github.com/ros-realtime/reference-system/actions/workflows/colcon-build.yml\"><img src=\"https://github.com/ros-realtime/reference-system/actions/workflows/colcon-build.yml/badge.svg\" alt=\"CI status\"/></a>"},{"location":"Pages/md_README/#overview","text":"With the distributed development of ROS across many different organizations it is sometimes hard to benchmark and concretely show how a certain change to a certain system improves or reduces the performance of that system. For example did a change from one executor to another actually reduce the CPU or was it something else entirely? In order to try and address this problem we at Apex.AI would like to propose a definition of a reference system that simulates a real world scenario - in this first case Autoware.Auto and its lidar data pipeline - that can be repeated no matter the underlying change of any piece of the full stack (i.e. executor, DDS or even RMW). Future reference systems could be proposed that are more complex using the same basic node building blocks within the reference_system package.","title":"Overview "},{"location":"Pages/md_README/#reference-system","text":"A reference system is defined by: A platform is defined by: Hardware (e.g. an off-the-shelf single-board computer, embedded ECU, etc.) if there are multiple configurations available for such hardware, ensure it is specified Operating System (OS) like RT linux, QNX, etc. along with any special configurations made for simplicity and ease of benchmarking, all nodes must run on a single process a fixed number of nodes each node with: a fixed number of publishers and subscribers a fixed processing time or a fixed publishing rate a fixed message type of fixed size to be used for every node . With these defined attributes the reference system can be replicated across many different possible configurations to be used to benchmark each configuration against the other in a reliable and fair manner. With this approach portable and repeatable tests can also be defined to reliably confirm if a given reference system meets the requirements.","title":"Reference System"},{"location":"Pages/md_README/#supported-platforms","text":"To enable as many people as possible to replicate this reference system, the platform(s) were chosen to be easily accessible (inexpensive, high volume), have lots of documentation, large community use and will be supported well into the future. Platforms were not chosen for performance of the reference system - we know we could run \u201cfaster\u201d with a more powerful CPU or GPU but then it would be harder for others to validate findings and test their own configurations. Accessibility is the key here and will be considered if more platforms want to be added to this benchmark list. Platforms: Raspberry Pi 4B : 4 GB RAM version is the assumed default other versions could also be tested / added by the community real-time linux kernel Note: create an issue to add more platforms to the list, keeping in mind the above criteria","title":"Supported Platforms"},{"location":"Pages/md_README/#concept-overview","text":"Rather than trying to write code to cover all potential variations of executors, APIs, and future features we cannot even imagine today we have chosen instead to define what we call a \u201creference system\u201d based on part of a real-world system, Autoware.Auto . The above node graph can be boiled down to only a handful of node \"types\" that are replicated to make this complex system: Node Types: Sensor Node input node to system one publisher, zero subscribers publishes message cyclically at some fixed frequency Transform Node one subscriber, one publisher starts processing for N milliseconds after a message is received publishes message after processing is complete Fusion Node 2 subscribers, one publisher starts processing for N milliseconds after a message is received from all subscriptions publishes message after processing is complete Cyclic Node N subscribers, one publisher cyclically processes all received messages since the last cycle for N milliseconds publishes message after processing is complete Command Node prints output stats everytime a message is received Intersection Node behaves like N transform nodes N subscribers, N publisher bundled together in one-to-one connections starts processing on connection where sample was received publishes message after processing is complete These basic building-block nodes can be mixed-and-matched to create quite complex systems that replicate real-world scenarios to benchmark different configurations against each other.","title":"Concept Overview"},{"location":"Pages/md_README/#reference-systems-overview","text":"The first reference system benchmark proposed is based on the Autoware.Auto lidar data pipeline as stated above and shown in the node graph image above as well. Autoware Reference System ROS2: Executors: Default: Single Threaded Static Single Threaded Multithreaded Results below show various characteristics of the same simulated system (Autoware.Auto). To add your own executor to the list above follow the how to add your custom executor section below.","title":"Reference Systems Overview"},{"location":"Pages/md_README/#benchmark-results","text":"Results will be added to different tagged releases along with the specific configurations ran during the tests.","title":"Benchmark Results"},{"location":"Pages/md_README/#testing-and-dependencies","text":"Tests and dependencies will be written uniquely for each reference system. Please go to the README.md file specific for the reference system you would like to run to view the instructions on how to set it up and run yourself. Autoware Reference System","title":"Testing and Dependencies"},{"location":"Pages/md_README/#contributing","text":"If you see a missing configuration on the list above that you would like to see benchmarked against please follow the steps below to request it to be added. look over the open / closed issues to make sure there isn't already an open ticket for the configuration you are looking for create include/reference_system/MY_EXECUTOR_NAME_nodes","title":"Contributing"},{"location":"Pages/md_README/#how-to-implement-your-custom-executor","text":"Read over the above documentation on the base node types Review the base rclcpp nodes that are provided and determine if your executor can use them If you cannot, implment your own version of each base node type and place the source in with the other nodes in the reference_system . Add your new nodes as a seperate node system in the reference_system package Copy one of the provided example .cpp files from the src/ros2/executor directory and replace the create_autoware_nodes template type with your new node system which should be in the [system/systems.hpp] file already included Add new .cpp source file as a new executable in the CMakelist.txt Add new executable to test wtihin the CMakelist.txt Build and run tests!","title":"How to Implement Your Custom Executor"},{"location":"Pages/md_README/#setup-raspberry-pi-4-for-the-test","text":"The goal is to provide a clean computation environment for the test avoiding an interference of other Ubuntu components.","title":"Setup Raspberry Pi 4 for the test"},{"location":"Pages/md_README/#setup-a-constant-cpu-frequency","text":"Frequency is setup to 1.50 GHz for all CPUs # run it as root sudo su echo -n \"setup constant CPU frequency to 1.50 GHz ... \" # disable ondemand governor systemctl disable ondemand # set performance governor for all cpus echo performance | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor >/dev/null # set constant frequency echo 1500000 | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_min_freq >/dev/null echo 1500000 | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_max_freq >/dev/null # reset frequency counters echo 1 | tee /sys/devices/system/cpu/cpu*/cpufreq/stats/reset >/dev/null echo done sleep 1 # get freq info echo `cpufreq-info | grep stats | cut -d ' ' -f 23-25`","title":"Setup a constant CPU frequency"},{"location":"Pages/md_README/#isolate-cpus","text":"CPU 2,3 are isolated to run tests. sudo apt install -y sysstat u-boot-tools # modify kernel cmdline cd ~ dd if=/boot/firmware/boot.scr of=boot.script bs=72 skip=1 # edit boot.script and modify bootargs to ubuntu@ubuntu:~$ cat boot.script | grep \"setenv bootargs\" | head -1 setenv bootargs \" ${bootargs} rcu_nocbs=2,3 nohz_full=2,3 isolcpus=2,3 irqaffinity=0,1 audit=0 watchdog=0 skew_tick=1 quiet splash\" # generate boot.scr mkimage -A arm64 -O linux -T script -C none -d boot.script boot.scr # replace boot.scr sudo cp boot.scr /boot/firmware/boot.scr sudo reboot # check cmdline ubuntu@ubuntu:~$ cat /proc/cmdline coherent_pool=1M 8250.nr_uarts=1 snd_bcm2835.enable_compat_alsa=0 snd_bcm2835.enable_hdmi=1 bcm2708_fb.fbwidth=0 bcm2708_fb.fbheight=0 bcm2708_fb.fbswap=1 smsc95xx.macaddr=DC:A6:32:2E:5 4:97 vc_mem.mem_base=0x3ec00000 vc_mem.mem_size=0x40000000 net.ifnames=0 dwc_otg.lpm_enable=0 console=ttyS0,115200 console=tty1 root=LABEL=writable rootfstype=ext4 elevator=deadline roo twait fixrtc rcu_nocbs=2,3 nohz_full=2,3 isolcpus=2,3 irqaffinity=0,1 audit=0 watchdog=0 skew_tick=1 quiet splash # check interrupts # Only the number of interrupts handled by CPU 0,1 increases. watch -n1 cat /proc/interrupts # check soft interrupts watch -n1 cat /proc/softirqs # check isolated CPUs cat /sys/devices/system/cpu/isolated 2-3 cat /sys/devices/system/cpu/present 0-3 # run reference system on CPU2 taskset -c 2 install/autoware_reference_system/lib/autoware_reference_system/autoware_default_singlethreaded > /dev/null # get pid RF_PID=`pidof autoware_default_singlethreaded` && cat /proc/$RF_PID/status | grep ^Cpu # check how many threads are running ps -aL | grep $RF_PID 3835 3835 ttyS0 00:03:46 autoware_defaul 3835 3836 ttyS0 00:00:00 autoware_defaul 3835 3837 ttyS0 00:00:00 autoware_defaul 3835 3838 ttyS0 00:00:00 autoware_defaul 3835 3839 ttyS0 00:00:00 gc 3835 3840 ttyS0 00:00:00 dq.builtins 3835 3841 ttyS0 00:00:00 dq.user 3835 3842 ttyS0 00:00:00 tev 3835 3843 ttyS0 00:00:00 recv 3835 3844 ttyS0 00:00:00 recvMC 3835 3845 ttyS0 00:00:00 recvUC 3835 3846 ttyS0 00:00:00 autoware_defaul","title":"Isolate CPUs"},{"location":"Pages/md_README/#hints","text":"If you run colcon build on a Raspberry Pi 4 with little memory, use export MAKEFLAGS=\"-j 1\" to inhibit parallelism. Otherwise, the system could hang due to memory swapping. Updated on 2021-12-24 at 17:45:36 +0000","title":"Hints"},{"location":"Pages/md_autoware_reference_system_README/","text":"autoware_reference_system This file is meant to define the Autoware Reference System and all of its nodes, topics and message types. To get started and test this system yourself, head down to the Quick Start section and follow the instructions there. See the generating a node graph using graphviz section on how to generate the above image Evaluation Criteria The autoware reference system was made with a few goals in mind. See the list below to get the complete picture of why certian tests are run and why this system was chosen as a good system to benchmark different executors. Each item below should have a corresponding test report with it or be able to be extracted from an existing test report. See the testing section for more details on how to generate your own test reports. If you believe we are missing another metric to measure executors by, please create an issue and let us know! Key Performance Indicators (KPIs) CPU utilization In general a lower CPU utilization is better since it enables you to choose a smaller CPU or have more functionality on a larger CPU for other things. The lower CPU utilization the better Memory utilization In general a lower memory utilization is better since it enables you to choose a smaller memory or have more space for other things The lower memory utilization the better Use latest samples, count dropped samples This is representative of the real-world where old sensor data is much less valuable than new sensor data For example an image from 30 seconds ago wont help you to drive down the road as much as an image from 0.1 seconds ago) If there is more than one new sample, the old ones will be dropped in favor of the newest sample As a result, dropped messages may mean that information was lost Fusion Nodes may drop messages by design if their inputs have different frequencies, do not count dropped messages for these nodes Transform nodes should not drop messages though, and these should be counted The lower number of dropped samples the better Every Front Lidar sample should cause update in Object Collision Estimator The Front and Rear Lidars have the same publishing frequency This means Object Collision Estimator should run for every lidar sample Count number of executions of Object Collision Estimator and Front Lidar and report any difference The smaller the difference in executions, the better Lowest possible latency from Front Lidar to Object Collision Estimator As in the real world, we want to know as soon as possible if the reference system will collide with something Measure the mean and max latency for this chain of nodes The lower latency of the signal chain the better The Behavior Planner should be as cyclical as possible The desired behavior of the Behavior Planner is to be as cyclical as possible, meaning it should be executed as close to its set frequency of 100ms as possible Measure the jitter and drift over time of the timer callback The lower the jitter and drift of the Behavior Node timer callback the better Message Types A single message type is used for the entire reference system when generating results in order to simplify the setup as well as make it more repeatible and extensible. This means only one message type from the list below is used during any given experimental run for every node in the reference system. Message4kB reference message with a fixed size of 4 kilobytes (kB) Other messages with different fixed sizes could be added here in the future. When reporting results it will be important to include the message type used duing the experiement so that comparisons can be done \"apples to apples\" and not \"apples to pears\". Autoware Reference System Built from a handful of building-block node types , each one of these nodes are meant to simulate a real-world node from the Autoware.Auto project lidar data pipeline. Under each node type are the requirements used for this specific reference system , autoware_reference_system . Future reference systems could have slightly different requirements and still use the same building-block node types. For simplicity's sake, every node except for the command nodes only ever publishes one topic and this topic has the same name as the node that publishes it. However, each topic can be subscribed to by multiple different nodes. Message Type all nodes use the same message type during any single test run default message type : Message4kB to be implemented: Message64kB Message256kB Message512kB Message1024kB Message5120kB Sensor Nodes all sensor nodes have a publishing rate (cycle time) of 100 milliseconds all sensor_nodes publish the same message type total of 5 sensor nodes : Front Lidar Driver Rear Lidar Driver Point Cloud Map Visualizer Lanelet2Map Transform Nodes all transform nodes have one subscriber and one publisher all transform nodes start processing for 50 milliseconds after a message is received publishes message after processing is complete total of 10 transform nodes : Front Points Transformer Rear Points Transformer Voxel Grid Downsampler Point Cloud Map Loader Ray Ground Filter Object Collision Estimator MPC Controller Parking Planner Lane Planner Fusion Nodes all fusion nodes have two subscribers and one publisher for this reference system all fusion nodes start processing for 25 milliseconds after a message is received from all subscriptions all fusion nodes have a max input time difference between the first input received and last input received before publishing of 9999 seconds publishes message after processing is complete total of 5 fusion nodes : Point Cloud Fusion NDT Localizer Vehicle Interface Lanelet2 Global Planner Lanelet 2 Map Loader Cyclic Nodes for this reference system there is only 1 cyclic node this cyclic node has 6 subscribers and one publisher** this cyclic node starts processing for 1 millisecond after a message is received from any** single subscription publishes message after processing is complete Command Nodes all command nodes have 1 subscriber and zero publishers all command nodes prints out the final latency statistics after a message is received on the specified topic total of 2 command nodes : VehicleDBWSystem IntersectionOutput Intersection Nodes for this reference system there is only EuclideanClusterDetector this intersection node has 2 subscribers and 2 publishers publishes message after processing is complete on the correspoding publisher Quick Start This section will go over how to clone, build and run the autoware_reference_system in order to generate your own test reports. Dependencies Before running the tests there are a few prerequisites to complete: Install python depedencies used during test runs and report generation python3 -m pip install psrecord bokeh networkx numpy pandas Install dependencies using the following command from the colcon_ws directory: rosdep install --from-paths src --ignore-src -y Install LTTng and ros2_tracing following the instructions in ros2_tracing Note: if you are setting up a realtime linux kernel for a raspberry pi using this docker file , it should already include LTTng Note: make sure to clone ros2_tracing into the same workspace as where you put the reference-system , the tests will not properly run if they are not in the same directory. Tests will fail if any of the above dependencies are missing on the machine. Once the above steps are complete you sould be ready to configure the setup for your platform and run the tests to generate some results. Configure Processing Time Many nodes in the reference system are actually performing some psuedo work by finding prime numbers up until some maximum value . Depending on the platform, this maximum value will need to be changed so that these nodes do not take an absurd amount of time. This maximum value should be chosen on a platform-by-platform basis so that the total run time of this work takes some desired length of time. In order to make finding this maximum value a bit easier across many different platforms a simple number_cruncher_benchmark is provided that will loop over various maximum values and spit out how long each one takes to run. After running this executable on your platform you should have a good idea what maximum value you should use in your timing configuration so that each node does some measurable work for some desired amount of time. Here is an example output of the number_cruncher_benchmark run on a typical development platform (Intel 9i7): ros2 run autoware_reference_system number_cruncher_benchmark maximum_number run time 64 0.001609ms 128 0.002896ms 256 0.006614ms 512 0.035036ms 1024 0.050957ms 2048 0.092732ms 4096 0.22837ms 8192 0.566779ms 16384 1.48837ms 32768 3.64588ms 65536 9.6687ms 131072 24.1154ms 262144 62.3475ms 524288 162.762ms 1048576 429.882ms 2097152 1149.79ms Run the above command on your system, select your desired run_time and place the corresponding maximum_number in the timing configuration file for the desired nodes. Running the Tests Source your ROS distribution as well as your ros2_tracing overlay, compile this repository using the proper CMake arguments and generate some test results: Make sure you've installed the required dependencies as outlined above before trying to run these tests. Supported CMake Arguments RUN_BENCHMARK Tell CMake to build the benchmark tests that will check the reference system against its requirements before running a sweep of tests to generate trace files and reports Without the RUN_BENCHMARK variable set to ON only the standard linter tests will be run TEST_PLATFORM Test CMake to build the tests to check if the tests are being run from a supported platform or not This flag can be ommited if you would like to run the tests on a development system before running them on a supported platform The platform tests themselves can and should be improved going forward and are only some simple checks today (architecture, number of CPUs, PREEMPT_RT flag, etc.) Set this to ON to check if the current platform is supported SKIP_TRACING Set to ON to skip the ros2_tracing tests, aka the callback tests This can greatly reduce the length of time the colcon test command takes to run ALL_RMWS Set this to ON if you'd like to run tests on all available RMWS as well Otherwise use only default RMW (first one listed by CMake function get_available_rmw_implementations ) Defaults to OFF Make sure you've installed the required dependencies as outlined above before trying to run these tests. # source your ROS distribution source /opt/ros/galactic/setup.bash # cd to your colcon_ws with this repo and `ros2_tracing` inside cd /path/to/colcon_ws # build packages with benchmark tests enabled colcon build --cmake-args -DRUN_BENCHMARK=TRUE -DTEST_PLATFORM=TRUE # IMPORTANT # source the newly built workspace to make sure to use the updated tracetools package source install/local_setup.bash # run tests, generate traces and reports colcon test Note 1: some of the tests require super user privileges, to change thread priorities. If super user privileges are not available, these tests are excluded automatically. Run the above lines from a sudo bash or similar to include those tests. Note 2: during the testing trace data generated from LTTng will be placed in $ROS_HOME/tracing . If the $ROS_HOME/tracing directory is missing the tests will automatically generate it for you. This directory should now hold tracing data and reports for all ros2_tracing tests performed. Additionally, CPU and Memory Usage tests generate data and reports and saves them to $ROS_HOME/memory . Test Results and Reports Reports are automatically generated depending on which tests are run. Below are the locations where each report is stored after successfully running the tests as described above. CPU and Memory Tests results are stored in your ${ROS_HOME}/memory directory if ${ROS_HOME} is not set, it defaults to ${HOME}/.ros/memory Executor KPI tests (Latency, Dropped Messages and Jitter) results are generated directly to the tests streams.log file using std::cout prints reports are generated and stored in the log/latest_test/autoware_reference_system directory ros2_tracing Tests results and reports are stored in your ${ROS_HOME}/tracing directory if ${ROS_HOME} is not set, it defaults to ${HOME}/.ros/tracing More reports can be added going forward. Generating Node Graph Image To generate the image shown above you can take advantage of a program called graphviz that has a command line interface (CLI) command dot . First, check out the provided .dot file within this directory to get an idea of how the dot syntax works (feel free to modify it for your use case or future reference systems ). To generate the .dot file into an .svg image, run the following command: dot -Tsvg autoware_reference_system.dot Note: you can change the generated image type to any of the supported type parameters if you would like a different filetype. Updated on 2021-12-24 at 17:45:36 +0000","title":"autoware_reference_system"},{"location":"Pages/md_autoware_reference_system_README/#autoware_reference_system","text":"This file is meant to define the Autoware Reference System and all of its nodes, topics and message types. To get started and test this system yourself, head down to the Quick Start section and follow the instructions there. See the generating a node graph using graphviz section on how to generate the above image","title":"autoware_reference_system"},{"location":"Pages/md_autoware_reference_system_README/#evaluation-criteria","text":"The autoware reference system was made with a few goals in mind. See the list below to get the complete picture of why certian tests are run and why this system was chosen as a good system to benchmark different executors. Each item below should have a corresponding test report with it or be able to be extracted from an existing test report. See the testing section for more details on how to generate your own test reports. If you believe we are missing another metric to measure executors by, please create an issue and let us know!","title":"Evaluation Criteria"},{"location":"Pages/md_autoware_reference_system_README/#key-performance-indicators-kpis","text":"CPU utilization In general a lower CPU utilization is better since it enables you to choose a smaller CPU or have more functionality on a larger CPU for other things. The lower CPU utilization the better Memory utilization In general a lower memory utilization is better since it enables you to choose a smaller memory or have more space for other things The lower memory utilization the better Use latest samples, count dropped samples This is representative of the real-world where old sensor data is much less valuable than new sensor data For example an image from 30 seconds ago wont help you to drive down the road as much as an image from 0.1 seconds ago) If there is more than one new sample, the old ones will be dropped in favor of the newest sample As a result, dropped messages may mean that information was lost Fusion Nodes may drop messages by design if their inputs have different frequencies, do not count dropped messages for these nodes Transform nodes should not drop messages though, and these should be counted The lower number of dropped samples the better Every Front Lidar sample should cause update in Object Collision Estimator The Front and Rear Lidars have the same publishing frequency This means Object Collision Estimator should run for every lidar sample Count number of executions of Object Collision Estimator and Front Lidar and report any difference The smaller the difference in executions, the better Lowest possible latency from Front Lidar to Object Collision Estimator As in the real world, we want to know as soon as possible if the reference system will collide with something Measure the mean and max latency for this chain of nodes The lower latency of the signal chain the better The Behavior Planner should be as cyclical as possible The desired behavior of the Behavior Planner is to be as cyclical as possible, meaning it should be executed as close to its set frequency of 100ms as possible Measure the jitter and drift over time of the timer callback The lower the jitter and drift of the Behavior Node timer callback the better","title":"Key Performance Indicators (KPIs)"},{"location":"Pages/md_autoware_reference_system_README/#message-types","text":"A single message type is used for the entire reference system when generating results in order to simplify the setup as well as make it more repeatible and extensible. This means only one message type from the list below is used during any given experimental run for every node in the reference system. Message4kB reference message with a fixed size of 4 kilobytes (kB) Other messages with different fixed sizes could be added here in the future. When reporting results it will be important to include the message type used duing the experiement so that comparisons can be done \"apples to apples\" and not \"apples to pears\".","title":"Message Types"},{"location":"Pages/md_autoware_reference_system_README/#autoware-reference-system","text":"Built from a handful of building-block node types , each one of these nodes are meant to simulate a real-world node from the Autoware.Auto project lidar data pipeline. Under each node type are the requirements used for this specific reference system , autoware_reference_system . Future reference systems could have slightly different requirements and still use the same building-block node types. For simplicity's sake, every node except for the command nodes only ever publishes one topic and this topic has the same name as the node that publishes it. However, each topic can be subscribed to by multiple different nodes. Message Type all nodes use the same message type during any single test run default message type : Message4kB to be implemented: Message64kB Message256kB Message512kB Message1024kB Message5120kB Sensor Nodes all sensor nodes have a publishing rate (cycle time) of 100 milliseconds all sensor_nodes publish the same message type total of 5 sensor nodes : Front Lidar Driver Rear Lidar Driver Point Cloud Map Visualizer Lanelet2Map Transform Nodes all transform nodes have one subscriber and one publisher all transform nodes start processing for 50 milliseconds after a message is received publishes message after processing is complete total of 10 transform nodes : Front Points Transformer Rear Points Transformer Voxel Grid Downsampler Point Cloud Map Loader Ray Ground Filter Object Collision Estimator MPC Controller Parking Planner Lane Planner Fusion Nodes all fusion nodes have two subscribers and one publisher for this reference system all fusion nodes start processing for 25 milliseconds after a message is received from all subscriptions all fusion nodes have a max input time difference between the first input received and last input received before publishing of 9999 seconds publishes message after processing is complete total of 5 fusion nodes : Point Cloud Fusion NDT Localizer Vehicle Interface Lanelet2 Global Planner Lanelet 2 Map Loader Cyclic Nodes for this reference system there is only 1 cyclic node this cyclic node has 6 subscribers and one publisher** this cyclic node starts processing for 1 millisecond after a message is received from any** single subscription publishes message after processing is complete Command Nodes all command nodes have 1 subscriber and zero publishers all command nodes prints out the final latency statistics after a message is received on the specified topic total of 2 command nodes : VehicleDBWSystem IntersectionOutput Intersection Nodes for this reference system there is only EuclideanClusterDetector this intersection node has 2 subscribers and 2 publishers publishes message after processing is complete on the correspoding publisher","title":"Autoware Reference System"},{"location":"Pages/md_autoware_reference_system_README/#quick-start","text":"This section will go over how to clone, build and run the autoware_reference_system in order to generate your own test reports.","title":"Quick Start"},{"location":"Pages/md_autoware_reference_system_README/#dependencies","text":"Before running the tests there are a few prerequisites to complete: Install python depedencies used during test runs and report generation python3 -m pip install psrecord bokeh networkx numpy pandas Install dependencies using the following command from the colcon_ws directory: rosdep install --from-paths src --ignore-src -y Install LTTng and ros2_tracing following the instructions in ros2_tracing Note: if you are setting up a realtime linux kernel for a raspberry pi using this docker file , it should already include LTTng Note: make sure to clone ros2_tracing into the same workspace as where you put the reference-system , the tests will not properly run if they are not in the same directory. Tests will fail if any of the above dependencies are missing on the machine. Once the above steps are complete you sould be ready to configure the setup for your platform and run the tests to generate some results.","title":"Dependencies"},{"location":"Pages/md_autoware_reference_system_README/#configure-processing-time","text":"Many nodes in the reference system are actually performing some psuedo work by finding prime numbers up until some maximum value . Depending on the platform, this maximum value will need to be changed so that these nodes do not take an absurd amount of time. This maximum value should be chosen on a platform-by-platform basis so that the total run time of this work takes some desired length of time. In order to make finding this maximum value a bit easier across many different platforms a simple number_cruncher_benchmark is provided that will loop over various maximum values and spit out how long each one takes to run. After running this executable on your platform you should have a good idea what maximum value you should use in your timing configuration so that each node does some measurable work for some desired amount of time. Here is an example output of the number_cruncher_benchmark run on a typical development platform (Intel 9i7): ros2 run autoware_reference_system number_cruncher_benchmark maximum_number run time 64 0.001609ms 128 0.002896ms 256 0.006614ms 512 0.035036ms 1024 0.050957ms 2048 0.092732ms 4096 0.22837ms 8192 0.566779ms 16384 1.48837ms 32768 3.64588ms 65536 9.6687ms 131072 24.1154ms 262144 62.3475ms 524288 162.762ms 1048576 429.882ms 2097152 1149.79ms Run the above command on your system, select your desired run_time and place the corresponding maximum_number in the timing configuration file for the desired nodes.","title":"Configure Processing Time"},{"location":"Pages/md_autoware_reference_system_README/#running-the-tests","text":"Source your ROS distribution as well as your ros2_tracing overlay, compile this repository using the proper CMake arguments and generate some test results: Make sure you've installed the required dependencies as outlined above before trying to run these tests.","title":"Running the Tests"},{"location":"Pages/md_autoware_reference_system_README/#supported-cmake-arguments","text":"RUN_BENCHMARK Tell CMake to build the benchmark tests that will check the reference system against its requirements before running a sweep of tests to generate trace files and reports Without the RUN_BENCHMARK variable set to ON only the standard linter tests will be run TEST_PLATFORM Test CMake to build the tests to check if the tests are being run from a supported platform or not This flag can be ommited if you would like to run the tests on a development system before running them on a supported platform The platform tests themselves can and should be improved going forward and are only some simple checks today (architecture, number of CPUs, PREEMPT_RT flag, etc.) Set this to ON to check if the current platform is supported SKIP_TRACING Set to ON to skip the ros2_tracing tests, aka the callback tests This can greatly reduce the length of time the colcon test command takes to run ALL_RMWS Set this to ON if you'd like to run tests on all available RMWS as well Otherwise use only default RMW (first one listed by CMake function get_available_rmw_implementations ) Defaults to OFF Make sure you've installed the required dependencies as outlined above before trying to run these tests. # source your ROS distribution source /opt/ros/galactic/setup.bash # cd to your colcon_ws with this repo and `ros2_tracing` inside cd /path/to/colcon_ws # build packages with benchmark tests enabled colcon build --cmake-args -DRUN_BENCHMARK=TRUE -DTEST_PLATFORM=TRUE # IMPORTANT # source the newly built workspace to make sure to use the updated tracetools package source install/local_setup.bash # run tests, generate traces and reports colcon test Note 1: some of the tests require super user privileges, to change thread priorities. If super user privileges are not available, these tests are excluded automatically. Run the above lines from a sudo bash or similar to include those tests. Note 2: during the testing trace data generated from LTTng will be placed in $ROS_HOME/tracing . If the $ROS_HOME/tracing directory is missing the tests will automatically generate it for you. This directory should now hold tracing data and reports for all ros2_tracing tests performed. Additionally, CPU and Memory Usage tests generate data and reports and saves them to $ROS_HOME/memory .","title":"Supported CMake Arguments"},{"location":"Pages/md_autoware_reference_system_README/#test-results-and-reports","text":"Reports are automatically generated depending on which tests are run. Below are the locations where each report is stored after successfully running the tests as described above. CPU and Memory Tests results are stored in your ${ROS_HOME}/memory directory if ${ROS_HOME} is not set, it defaults to ${HOME}/.ros/memory Executor KPI tests (Latency, Dropped Messages and Jitter) results are generated directly to the tests streams.log file using std::cout prints reports are generated and stored in the log/latest_test/autoware_reference_system directory ros2_tracing Tests results and reports are stored in your ${ROS_HOME}/tracing directory if ${ROS_HOME} is not set, it defaults to ${HOME}/.ros/tracing More reports can be added going forward.","title":"Test Results and Reports"},{"location":"Pages/md_autoware_reference_system_README/#generating-node-graph-image","text":"To generate the image shown above you can take advantage of a program called graphviz that has a command line interface (CLI) command dot . First, check out the provided .dot file within this directory to get an idea of how the dot syntax works (feel free to modify it for your use case or future reference systems ). To generate the .dot file into an .svg image, run the following command: dot -Tsvg autoware_reference_system.dot Note: you can change the generated image type to any of the supported type parameters if you would like a different filetype. Updated on 2021-12-24 at 17:45:36 +0000","title":"Generating Node Graph Image"},{"location":"Pages/md_reference_system_README/","text":"reference_system This package holds the core node definitions that can be used to build various reference systems that can end up being quite complex. These reference systems can then be used to benchmark, test and evaluate various changes to the core middleware being used (e.g. executors, QoS settings, DDSs', etc.). See autoware_reference_system as an example as to how one could use these nodes to build a simulated real-world system for benchmarking and testing purposes. Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_system"},{"location":"Pages/md_reference_system_README/#reference_system","text":"This package holds the core node definitions that can be used to build various reference systems that can end up being quite complex. These reference systems can then be used to benchmark, test and evaluate various changes to the core middleware being used (e.g. executors, QoS settings, DDSs', etc.). See autoware_reference_system as an example as to how one could use these nodes to build a simulated real-world system for benchmarking and testing purposes. Updated on 2021-12-24 at 17:45:36 +0000","title":"reference_system"}]}