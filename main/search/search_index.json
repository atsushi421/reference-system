{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"Classes/","text":"Classes struct RclcppSystem class SampleManagementSettings A singleton for sample management settings that may differ between experiments. class TestNodeGraph namespace benchmark namespace conftest namespace nodes struct CommandSettings struct CyclicSettings struct FusionSettings struct IntersectionSettings struct Connection struct SensorSettings struct TransformSettings namespace rclcpp_system class Command class Cyclic struct subscription_t class Fusion struct subscription_t class Intersection struct Connection class Sensor class Transform namespace timing struct BenchmarkCPUUsage struct BenchmarkThroughput struct Default namespace rclcpp namespace reference_interfaces namespace msg struct Message4kb namespace Message4kb_Constants struct TransmissionStats namespace TransmissionStats_Constants namespace reference_system_py namespace benchmark namespace callback_duration namespace constants namespace dropped_messages namespace memory_usage namespace plot_utils namespace std_latency namespace trace_utils struct sample_statistic_t namespace setup struct statistic_value_t namespace std::chrono_literals namespace test_platform namespace test_requirements class TestRequirementsAutowareReferenceSystem namespace testing namespace unittest Updated on 2022-04-30 at 21:32:33 +0000","title":"Classes"},{"location":"Classes/#classes","text":"struct RclcppSystem class SampleManagementSettings A singleton for sample management settings that may differ between experiments. class TestNodeGraph namespace benchmark namespace conftest namespace nodes struct CommandSettings struct CyclicSettings struct FusionSettings struct IntersectionSettings struct Connection struct SensorSettings struct TransformSettings namespace rclcpp_system class Command class Cyclic struct subscription_t class Fusion struct subscription_t class Intersection struct Connection class Sensor class Transform namespace timing struct BenchmarkCPUUsage struct BenchmarkThroughput struct Default namespace rclcpp namespace reference_interfaces namespace msg struct Message4kb namespace Message4kb_Constants struct TransmissionStats namespace TransmissionStats_Constants namespace reference_system_py namespace benchmark namespace callback_duration namespace constants namespace dropped_messages namespace memory_usage namespace plot_utils namespace std_latency namespace trace_utils struct sample_statistic_t namespace setup struct statistic_value_t namespace std::chrono_literals namespace test_platform namespace test_requirements class TestRequirementsAutowareReferenceSystem namespace testing namespace unittest Updated on 2022-04-30 at 21:32:33 +0000","title":"Classes"},{"location":"Classes/classSampleManagementSettings/","text":"SampleManagementSettings A singleton for sample management settings that may differ between experiments. #include <sample_management.hpp> Public Functions Name SampleManagementSettings & get () void set_hot_path (const std::set< std::string > & hot_path_nodes, const std::set< std::string > & hot_path_roots, const std::string & hot_path_sink) const std::string & hot_path_sink () const bool is_hot_path_root (const std::string & name) const bool is_hot_path_node (const std::string & name) const std::string hot_path_name () const void set_benchmark_mode (bool value) bool is_in_benchmark_mode () const Public Functions Documentation function get static inline SampleManagementSettings & get() function set_hot_path inline void set_hot_path( const std::set< std::string > & hot_path_nodes, const std::set< std::string > & hot_path_roots, const std::string & hot_path_sink ) function hot_path_sink inline const std::string & hot_path_sink() const function is_hot_path_root inline bool is_hot_path_root( const std::string & name ) const function is_hot_path_node inline bool is_hot_path_node( const std::string & name ) const function hot_path_name inline std::string hot_path_name() const function set_benchmark_mode inline void set_benchmark_mode( bool value ) function is_in_benchmark_mode inline bool is_in_benchmark_mode() const Updated on 2022-04-30 at 21:32:33 +0000","title":"SampleManagementSettings"},{"location":"Classes/classSampleManagementSettings/#samplemanagementsettings","text":"A singleton for sample management settings that may differ between experiments. #include <sample_management.hpp>","title":"SampleManagementSettings"},{"location":"Classes/classSampleManagementSettings/#public-functions","text":"Name SampleManagementSettings & get () void set_hot_path (const std::set< std::string > & hot_path_nodes, const std::set< std::string > & hot_path_roots, const std::string & hot_path_sink) const std::string & hot_path_sink () const bool is_hot_path_root (const std::string & name) const bool is_hot_path_node (const std::string & name) const std::string hot_path_name () const void set_benchmark_mode (bool value) bool is_in_benchmark_mode () const","title":"Public Functions"},{"location":"Classes/classSampleManagementSettings/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classSampleManagementSettings/#function-get","text":"static inline SampleManagementSettings & get()","title":"function get"},{"location":"Classes/classSampleManagementSettings/#function-set_hot_path","text":"inline void set_hot_path( const std::set< std::string > & hot_path_nodes, const std::set< std::string > & hot_path_roots, const std::string & hot_path_sink )","title":"function set_hot_path"},{"location":"Classes/classSampleManagementSettings/#function-hot_path_sink","text":"inline const std::string & hot_path_sink() const","title":"function hot_path_sink"},{"location":"Classes/classSampleManagementSettings/#function-is_hot_path_root","text":"inline bool is_hot_path_root( const std::string & name ) const","title":"function is_hot_path_root"},{"location":"Classes/classSampleManagementSettings/#function-is_hot_path_node","text":"inline bool is_hot_path_node( const std::string & name ) const","title":"function is_hot_path_node"},{"location":"Classes/classSampleManagementSettings/#function-hot_path_name","text":"inline std::string hot_path_name() const","title":"function hot_path_name"},{"location":"Classes/classSampleManagementSettings/#function-set_benchmark_mode","text":"inline void set_benchmark_mode( bool value )","title":"function set_benchmark_mode"},{"location":"Classes/classSampleManagementSettings/#function-is_in_benchmark_mode","text":"inline bool is_in_benchmark_mode() const Updated on 2022-04-30 at 21:32:33 +0000","title":"function is_in_benchmark_mode"},{"location":"Classes/classTestNodeGraph/","text":"TestNodeGraph Inherits from testing::Test Public Functions Name void SetUp () void TearDown () Public Functions Documentation function SetUp inline void SetUp() function TearDown inline void TearDown() Updated on 2022-04-30 at 21:32:33 +0000","title":"TestNodeGraph"},{"location":"Classes/classTestNodeGraph/#testnodegraph","text":"Inherits from testing::Test","title":"TestNodeGraph"},{"location":"Classes/classTestNodeGraph/#public-functions","text":"Name void SetUp () void TearDown ()","title":"Public Functions"},{"location":"Classes/classTestNodeGraph/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classTestNodeGraph/#function-setup","text":"inline void SetUp()","title":"function SetUp"},{"location":"Classes/classTestNodeGraph/#function-teardown","text":"inline void TearDown() Updated on 2022-04-30 at 21:32:33 +0000","title":"function TearDown"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Command/","text":"nodes::rclcpp_system::Command Inherits from rclcpp::Node Public Functions Name Command (const CommandSettings & settings) Public Functions Documentation function Command inline explicit Command( const CommandSettings & settings ) Updated on 2022-04-30 at 21:32:33 +0000","title":"nodes::rclcpp_system::Command"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Command/#nodesrclcpp_systemcommand","text":"Inherits from rclcpp::Node","title":"nodes::rclcpp_system::Command"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Command/#public-functions","text":"Name Command (const CommandSettings & settings)","title":"Public Functions"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Command/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Command/#function-command","text":"inline explicit Command( const CommandSettings & settings ) Updated on 2022-04-30 at 21:32:33 +0000","title":"function Command"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Cyclic/","text":"nodes::rclcpp_system::Cyclic Inherits from rclcpp::Node Public Functions Name Cyclic (const CyclicSettings & settings) Public Functions Documentation function Cyclic inline explicit Cyclic( const CyclicSettings & settings ) Updated on 2022-04-30 at 21:32:33 +0000","title":"nodes::rclcpp_system::Cyclic"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Cyclic/#nodesrclcpp_systemcyclic","text":"Inherits from rclcpp::Node","title":"nodes::rclcpp_system::Cyclic"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Cyclic/#public-functions","text":"Name Cyclic (const CyclicSettings & settings)","title":"Public Functions"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Cyclic/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Cyclic/#function-cyclic","text":"inline explicit Cyclic( const CyclicSettings & settings ) Updated on 2022-04-30 at 21:32:33 +0000","title":"function Cyclic"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Fusion/","text":"nodes::rclcpp_system::Fusion Inherits from rclcpp::Node Public Functions Name Fusion (const FusionSettings & settings) Public Functions Documentation function Fusion inline explicit Fusion( const FusionSettings & settings ) Updated on 2022-04-30 at 21:32:33 +0000","title":"nodes::rclcpp_system::Fusion"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Fusion/#nodesrclcpp_systemfusion","text":"Inherits from rclcpp::Node","title":"nodes::rclcpp_system::Fusion"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Fusion/#public-functions","text":"Name Fusion (const FusionSettings & settings)","title":"Public Functions"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Fusion/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Fusion/#function-fusion","text":"inline explicit Fusion( const FusionSettings & settings ) Updated on 2022-04-30 at 21:32:33 +0000","title":"function Fusion"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Intersection/","text":"nodes::rclcpp_system::Intersection Inherits from rclcpp::Node Public Functions Name Intersection (const IntersectionSettings & settings) rclcpp::CallbackGroup::SharedPtr get_callback_group_of_subscription (const std::string & input_topic) Public Functions Documentation function Intersection inline explicit Intersection( const IntersectionSettings & settings ) function get_callback_group_of_subscription inline rclcpp::CallbackGroup::SharedPtr get_callback_group_of_subscription( const std::string & input_topic ) Updated on 2022-04-30 at 21:32:33 +0000","title":"nodes::rclcpp_system::Intersection"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Intersection/#nodesrclcpp_systemintersection","text":"Inherits from rclcpp::Node","title":"nodes::rclcpp_system::Intersection"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Intersection/#public-functions","text":"Name Intersection (const IntersectionSettings & settings) rclcpp::CallbackGroup::SharedPtr get_callback_group_of_subscription (const std::string & input_topic)","title":"Public Functions"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Intersection/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Intersection/#function-intersection","text":"inline explicit Intersection( const IntersectionSettings & settings )","title":"function Intersection"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Intersection/#function-get_callback_group_of_subscription","text":"inline rclcpp::CallbackGroup::SharedPtr get_callback_group_of_subscription( const std::string & input_topic ) Updated on 2022-04-30 at 21:32:33 +0000","title":"function get_callback_group_of_subscription"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Sensor/","text":"nodes::rclcpp_system::Sensor Inherits from rclcpp::Node Public Functions Name Sensor (const SensorSettings & settings) Public Functions Documentation function Sensor inline explicit Sensor( const SensorSettings & settings ) Updated on 2022-04-30 at 21:32:33 +0000","title":"nodes::rclcpp_system::Sensor"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Sensor/#nodesrclcpp_systemsensor","text":"Inherits from rclcpp::Node","title":"nodes::rclcpp_system::Sensor"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Sensor/#public-functions","text":"Name Sensor (const SensorSettings & settings)","title":"Public Functions"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Sensor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Sensor/#function-sensor","text":"inline explicit Sensor( const SensorSettings & settings ) Updated on 2022-04-30 at 21:32:33 +0000","title":"function Sensor"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Transform/","text":"nodes::rclcpp_system::Transform Inherits from rclcpp::Node Public Functions Name Transform (const TransformSettings & settings) Public Functions Documentation function Transform inline explicit Transform( const TransformSettings & settings ) Updated on 2022-04-30 at 21:32:33 +0000","title":"nodes::rclcpp_system::Transform"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Transform/#nodesrclcpp_systemtransform","text":"Inherits from rclcpp::Node","title":"nodes::rclcpp_system::Transform"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Transform/#public-functions","text":"Name Transform (const TransformSettings & settings)","title":"Public Functions"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Transform/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classnodes_1_1rclcpp__system_1_1Transform/#function-transform","text":"inline explicit Transform( const TransformSettings & settings ) Updated on 2022-04-30 at 21:32:33 +0000","title":"function Transform"},{"location":"Classes/classtest__requirements_1_1TestRequirementsAutowareReferenceSystem/","text":"test_requirements::TestRequirementsAutowareReferenceSystem Inherits from unittest.TestCase Public Functions Name def test_pubs_and_subs (self self) Public Functions Documentation function test_pubs_and_subs def test_pubs_and_subs( self self ) Updated on 2022-04-30 at 21:32:33 +0000","title":"test_requirements::TestRequirementsAutowareReferenceSystem"},{"location":"Classes/classtest__requirements_1_1TestRequirementsAutowareReferenceSystem/#test_requirementstestrequirementsautowarereferencesystem","text":"Inherits from unittest.TestCase","title":"test_requirements::TestRequirementsAutowareReferenceSystem"},{"location":"Classes/classtest__requirements_1_1TestRequirementsAutowareReferenceSystem/#public-functions","text":"Name def test_pubs_and_subs (self self)","title":"Public Functions"},{"location":"Classes/classtest__requirements_1_1TestRequirementsAutowareReferenceSystem/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/classtest__requirements_1_1TestRequirementsAutowareReferenceSystem/#function-test_pubs_and_subs","text":"def test_pubs_and_subs( self self ) Updated on 2022-04-30 at 21:32:33 +0000","title":"function test_pubs_and_subs"},{"location":"Classes/structRclcppSystem/","text":"RclcppSystem Public Types Name using rclcpp::Node NodeBaseType using nodes::rclcpp_system::Command Command using nodes::rclcpp_system::Cyclic Cyclic using nodes::rclcpp_system::Fusion Fusion using nodes::rclcpp_system::Intersection Intersection using nodes::rclcpp_system::Sensor Sensor using nodes::rclcpp_system::Transform Transform Public Types Documentation using NodeBaseType using RclcppSystem::NodeBaseType = rclcpp::Node; using Command using RclcppSystem::Command = nodes::rclcpp_system::Command; using Cyclic using RclcppSystem::Cyclic = nodes::rclcpp_system::Cyclic; using Fusion using RclcppSystem::Fusion = nodes::rclcpp_system::Fusion; using Intersection using RclcppSystem::Intersection = nodes::rclcpp_system::Intersection; using Sensor using RclcppSystem::Sensor = nodes::rclcpp_system::Sensor; using Transform using RclcppSystem::Transform = nodes::rclcpp_system::Transform; Updated on 2022-04-30 at 21:32:33 +0000","title":"RclcppSystem"},{"location":"Classes/structRclcppSystem/#rclcppsystem","text":"","title":"RclcppSystem"},{"location":"Classes/structRclcppSystem/#public-types","text":"Name using rclcpp::Node NodeBaseType using nodes::rclcpp_system::Command Command using nodes::rclcpp_system::Cyclic Cyclic using nodes::rclcpp_system::Fusion Fusion using nodes::rclcpp_system::Intersection Intersection using nodes::rclcpp_system::Sensor Sensor using nodes::rclcpp_system::Transform Transform","title":"Public Types"},{"location":"Classes/structRclcppSystem/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Classes/structRclcppSystem/#using-nodebasetype","text":"using RclcppSystem::NodeBaseType = rclcpp::Node;","title":"using NodeBaseType"},{"location":"Classes/structRclcppSystem/#using-command","text":"using RclcppSystem::Command = nodes::rclcpp_system::Command;","title":"using Command"},{"location":"Classes/structRclcppSystem/#using-cyclic","text":"using RclcppSystem::Cyclic = nodes::rclcpp_system::Cyclic;","title":"using Cyclic"},{"location":"Classes/structRclcppSystem/#using-fusion","text":"using RclcppSystem::Fusion = nodes::rclcpp_system::Fusion;","title":"using Fusion"},{"location":"Classes/structRclcppSystem/#using-intersection","text":"using RclcppSystem::Intersection = nodes::rclcpp_system::Intersection;","title":"using Intersection"},{"location":"Classes/structRclcppSystem/#using-sensor","text":"using RclcppSystem::Sensor = nodes::rclcpp_system::Sensor;","title":"using Sensor"},{"location":"Classes/structRclcppSystem/#using-transform","text":"using RclcppSystem::Transform = nodes::rclcpp_system::Transform; Updated on 2022-04-30 at 21:32:33 +0000","title":"using Transform"},{"location":"Classes/structnodes_1_1CommandSettings/","text":"nodes::CommandSettings Public Attributes Name std::string node_name std::string input_topic Public Attributes Documentation variable node_name std::string node_name; variable input_topic std::string input_topic; Updated on 2022-04-30 at 21:32:33 +0000","title":"nodes::CommandSettings"},{"location":"Classes/structnodes_1_1CommandSettings/#nodescommandsettings","text":"","title":"nodes::CommandSettings"},{"location":"Classes/structnodes_1_1CommandSettings/#public-attributes","text":"Name std::string node_name std::string input_topic","title":"Public Attributes"},{"location":"Classes/structnodes_1_1CommandSettings/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structnodes_1_1CommandSettings/#variable-node_name","text":"std::string node_name;","title":"variable node_name"},{"location":"Classes/structnodes_1_1CommandSettings/#variable-input_topic","text":"std::string input_topic; Updated on 2022-04-30 at 21:32:33 +0000","title":"variable input_topic"},{"location":"Classes/structnodes_1_1CyclicSettings/","text":"nodes::CyclicSettings Public Attributes Name std::string node_name std::vector< std::string > inputs std::string output_topic uint64_t number_crunch_limit std::chrono::nanoseconds cycle_time Public Attributes Documentation variable node_name std::string node_name; variable inputs std::vector< std::string > inputs; variable output_topic std::string output_topic; variable number_crunch_limit uint64_t number_crunch_limit; variable cycle_time std::chrono::nanoseconds cycle_time; Updated on 2022-04-30 at 21:32:33 +0000","title":"nodes::CyclicSettings"},{"location":"Classes/structnodes_1_1CyclicSettings/#nodescyclicsettings","text":"","title":"nodes::CyclicSettings"},{"location":"Classes/structnodes_1_1CyclicSettings/#public-attributes","text":"Name std::string node_name std::vector< std::string > inputs std::string output_topic uint64_t number_crunch_limit std::chrono::nanoseconds cycle_time","title":"Public Attributes"},{"location":"Classes/structnodes_1_1CyclicSettings/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structnodes_1_1CyclicSettings/#variable-node_name","text":"std::string node_name;","title":"variable node_name"},{"location":"Classes/structnodes_1_1CyclicSettings/#variable-inputs","text":"std::vector< std::string > inputs;","title":"variable inputs"},{"location":"Classes/structnodes_1_1CyclicSettings/#variable-output_topic","text":"std::string output_topic;","title":"variable output_topic"},{"location":"Classes/structnodes_1_1CyclicSettings/#variable-number_crunch_limit","text":"uint64_t number_crunch_limit;","title":"variable number_crunch_limit"},{"location":"Classes/structnodes_1_1CyclicSettings/#variable-cycle_time","text":"std::chrono::nanoseconds cycle_time; Updated on 2022-04-30 at 21:32:33 +0000","title":"variable cycle_time"},{"location":"Classes/structnodes_1_1FusionSettings/","text":"nodes::FusionSettings Public Attributes Name std::string node_name std::string input_0 std::string input_1 std::string output_topic uint64_t number_crunch_limit Public Attributes Documentation variable node_name std::string node_name; variable input_0 std::string input_0; variable input_1 std::string input_1; variable output_topic std::string output_topic; variable number_crunch_limit uint64_t number_crunch_limit; Updated on 2022-04-30 at 21:32:33 +0000","title":"nodes::FusionSettings"},{"location":"Classes/structnodes_1_1FusionSettings/#nodesfusionsettings","text":"","title":"nodes::FusionSettings"},{"location":"Classes/structnodes_1_1FusionSettings/#public-attributes","text":"Name std::string node_name std::string input_0 std::string input_1 std::string output_topic uint64_t number_crunch_limit","title":"Public Attributes"},{"location":"Classes/structnodes_1_1FusionSettings/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structnodes_1_1FusionSettings/#variable-node_name","text":"std::string node_name;","title":"variable node_name"},{"location":"Classes/structnodes_1_1FusionSettings/#variable-input_0","text":"std::string input_0;","title":"variable input_0"},{"location":"Classes/structnodes_1_1FusionSettings/#variable-input_1","text":"std::string input_1;","title":"variable input_1"},{"location":"Classes/structnodes_1_1FusionSettings/#variable-output_topic","text":"std::string output_topic;","title":"variable output_topic"},{"location":"Classes/structnodes_1_1FusionSettings/#variable-number_crunch_limit","text":"uint64_t number_crunch_limit; Updated on 2022-04-30 at 21:32:33 +0000","title":"variable number_crunch_limit"},{"location":"Classes/structnodes_1_1IntersectionSettings/","text":"nodes::IntersectionSettings Public Classes Name struct Connection Public Attributes Name std::string node_name std::vector< Connection > connections Public Attributes Documentation variable node_name std::string node_name; variable connections std::vector< Connection > connections; Updated on 2022-04-30 at 21:32:33 +0000","title":"nodes::IntersectionSettings"},{"location":"Classes/structnodes_1_1IntersectionSettings/#nodesintersectionsettings","text":"","title":"nodes::IntersectionSettings"},{"location":"Classes/structnodes_1_1IntersectionSettings/#public-classes","text":"Name struct Connection","title":"Public Classes"},{"location":"Classes/structnodes_1_1IntersectionSettings/#public-attributes","text":"Name std::string node_name std::vector< Connection > connections","title":"Public Attributes"},{"location":"Classes/structnodes_1_1IntersectionSettings/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structnodes_1_1IntersectionSettings/#variable-node_name","text":"std::string node_name;","title":"variable node_name"},{"location":"Classes/structnodes_1_1IntersectionSettings/#variable-connections","text":"std::vector< Connection > connections; Updated on 2022-04-30 at 21:32:33 +0000","title":"variable connections"},{"location":"Classes/structnodes_1_1IntersectionSettings_1_1Connection/","text":"nodes::IntersectionSettings::Connection Public Attributes Name std::string input_topic std::string output_topic uint64_t number_crunch_limit Public Attributes Documentation variable input_topic std::string input_topic; variable output_topic std::string output_topic; variable number_crunch_limit uint64_t number_crunch_limit; Updated on 2022-04-30 at 21:32:33 +0000","title":"nodes::IntersectionSettings::Connection"},{"location":"Classes/structnodes_1_1IntersectionSettings_1_1Connection/#nodesintersectionsettingsconnection","text":"","title":"nodes::IntersectionSettings::Connection"},{"location":"Classes/structnodes_1_1IntersectionSettings_1_1Connection/#public-attributes","text":"Name std::string input_topic std::string output_topic uint64_t number_crunch_limit","title":"Public Attributes"},{"location":"Classes/structnodes_1_1IntersectionSettings_1_1Connection/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structnodes_1_1IntersectionSettings_1_1Connection/#variable-input_topic","text":"std::string input_topic;","title":"variable input_topic"},{"location":"Classes/structnodes_1_1IntersectionSettings_1_1Connection/#variable-output_topic","text":"std::string output_topic;","title":"variable output_topic"},{"location":"Classes/structnodes_1_1IntersectionSettings_1_1Connection/#variable-number_crunch_limit","text":"uint64_t number_crunch_limit; Updated on 2022-04-30 at 21:32:33 +0000","title":"variable number_crunch_limit"},{"location":"Classes/structnodes_1_1SensorSettings/","text":"nodes::SensorSettings Public Attributes Name std::string node_name std::string topic_name std::chrono::nanoseconds cycle_time Public Attributes Documentation variable node_name std::string node_name; variable topic_name std::string topic_name; variable cycle_time std::chrono::nanoseconds cycle_time; Updated on 2022-04-30 at 21:32:33 +0000","title":"nodes::SensorSettings"},{"location":"Classes/structnodes_1_1SensorSettings/#nodessensorsettings","text":"","title":"nodes::SensorSettings"},{"location":"Classes/structnodes_1_1SensorSettings/#public-attributes","text":"Name std::string node_name std::string topic_name std::chrono::nanoseconds cycle_time","title":"Public Attributes"},{"location":"Classes/structnodes_1_1SensorSettings/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structnodes_1_1SensorSettings/#variable-node_name","text":"std::string node_name;","title":"variable node_name"},{"location":"Classes/structnodes_1_1SensorSettings/#variable-topic_name","text":"std::string topic_name;","title":"variable topic_name"},{"location":"Classes/structnodes_1_1SensorSettings/#variable-cycle_time","text":"std::chrono::nanoseconds cycle_time; Updated on 2022-04-30 at 21:32:33 +0000","title":"variable cycle_time"},{"location":"Classes/structnodes_1_1TransformSettings/","text":"nodes::TransformSettings Public Attributes Name std::string node_name std::string input_topic std::string output_topic uint64_t number_crunch_limit Public Attributes Documentation variable node_name std::string node_name; variable input_topic std::string input_topic; variable output_topic std::string output_topic; variable number_crunch_limit uint64_t number_crunch_limit; Updated on 2022-04-30 at 21:32:33 +0000","title":"nodes::TransformSettings"},{"location":"Classes/structnodes_1_1TransformSettings/#nodestransformsettings","text":"","title":"nodes::TransformSettings"},{"location":"Classes/structnodes_1_1TransformSettings/#public-attributes","text":"Name std::string node_name std::string input_topic std::string output_topic uint64_t number_crunch_limit","title":"Public Attributes"},{"location":"Classes/structnodes_1_1TransformSettings/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structnodes_1_1TransformSettings/#variable-node_name","text":"std::string node_name;","title":"variable node_name"},{"location":"Classes/structnodes_1_1TransformSettings/#variable-input_topic","text":"std::string input_topic;","title":"variable input_topic"},{"location":"Classes/structnodes_1_1TransformSettings/#variable-output_topic","text":"std::string output_topic;","title":"variable output_topic"},{"location":"Classes/structnodes_1_1TransformSettings/#variable-number_crunch_limit","text":"uint64_t number_crunch_limit; Updated on 2022-04-30 at 21:32:33 +0000","title":"variable number_crunch_limit"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Cyclic_1_1subscription__t/","text":"nodes::rclcpp_system::Cyclic::subscription_t Public Attributes Name rclcpp::Subscription< message_t >::SharedPtr subscription uint32_t sequence_number message_t::SharedPtr cache Public Attributes Documentation variable subscription rclcpp::Subscription< message_t >::SharedPtr subscription; variable sequence_number uint32_t sequence_number = 0; variable cache message_t::SharedPtr cache; Updated on 2022-04-30 at 21:32:33 +0000","title":"nodes::rclcpp_system::Cyclic::subscription_t"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Cyclic_1_1subscription__t/#nodesrclcpp_systemcyclicsubscription_t","text":"","title":"nodes::rclcpp_system::Cyclic::subscription_t"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Cyclic_1_1subscription__t/#public-attributes","text":"Name rclcpp::Subscription< message_t >::SharedPtr subscription uint32_t sequence_number message_t::SharedPtr cache","title":"Public Attributes"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Cyclic_1_1subscription__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Cyclic_1_1subscription__t/#variable-subscription","text":"rclcpp::Subscription< message_t >::SharedPtr subscription;","title":"variable subscription"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Cyclic_1_1subscription__t/#variable-sequence_number","text":"uint32_t sequence_number = 0;","title":"variable sequence_number"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Cyclic_1_1subscription__t/#variable-cache","text":"message_t::SharedPtr cache; Updated on 2022-04-30 at 21:32:33 +0000","title":"variable cache"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Fusion_1_1subscription__t/","text":"nodes::rclcpp_system::Fusion::subscription_t Public Attributes Name rclcpp::Subscription< message_t >::SharedPtr subscription uint32_t sequence_number message_t::SharedPtr cache Public Attributes Documentation variable subscription rclcpp::Subscription< message_t >::SharedPtr subscription; variable sequence_number uint32_t sequence_number = 0; variable cache message_t::SharedPtr cache; Updated on 2022-04-30 at 21:32:33 +0000","title":"nodes::rclcpp_system::Fusion::subscription_t"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Fusion_1_1subscription__t/#nodesrclcpp_systemfusionsubscription_t","text":"","title":"nodes::rclcpp_system::Fusion::subscription_t"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Fusion_1_1subscription__t/#public-attributes","text":"Name rclcpp::Subscription< message_t >::SharedPtr subscription uint32_t sequence_number message_t::SharedPtr cache","title":"Public Attributes"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Fusion_1_1subscription__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Fusion_1_1subscription__t/#variable-subscription","text":"rclcpp::Subscription< message_t >::SharedPtr subscription;","title":"variable subscription"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Fusion_1_1subscription__t/#variable-sequence_number","text":"uint32_t sequence_number = 0;","title":"variable sequence_number"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Fusion_1_1subscription__t/#variable-cache","text":"message_t::SharedPtr cache; Updated on 2022-04-30 at 21:32:33 +0000","title":"variable cache"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Intersection_1_1Connection/","text":"nodes::rclcpp_system::Intersection::Connection Public Attributes Name rclcpp::Publisher< message_t >::SharedPtr publisher rclcpp::Subscription< message_t >::SharedPtr subscription rclcpp::CallbackGroup::SharedPtr callback_group uint64_t number_crunch_limit uint32_t sequence_number uint32_t input_sequence_number Public Attributes Documentation variable publisher rclcpp::Publisher< message_t >::SharedPtr publisher; variable subscription rclcpp::Subscription< message_t >::SharedPtr subscription; variable callback_group rclcpp::CallbackGroup::SharedPtr callback_group; variable number_crunch_limit uint64_t number_crunch_limit; variable sequence_number uint32_t sequence_number = 0; variable input_sequence_number uint32_t input_sequence_number = 0; Updated on 2022-04-30 at 21:32:33 +0000","title":"nodes::rclcpp_system::Intersection::Connection"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Intersection_1_1Connection/#nodesrclcpp_systemintersectionconnection","text":"","title":"nodes::rclcpp_system::Intersection::Connection"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Intersection_1_1Connection/#public-attributes","text":"Name rclcpp::Publisher< message_t >::SharedPtr publisher rclcpp::Subscription< message_t >::SharedPtr subscription rclcpp::CallbackGroup::SharedPtr callback_group uint64_t number_crunch_limit uint32_t sequence_number uint32_t input_sequence_number","title":"Public Attributes"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Intersection_1_1Connection/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Intersection_1_1Connection/#variable-publisher","text":"rclcpp::Publisher< message_t >::SharedPtr publisher;","title":"variable publisher"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Intersection_1_1Connection/#variable-subscription","text":"rclcpp::Subscription< message_t >::SharedPtr subscription;","title":"variable subscription"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Intersection_1_1Connection/#variable-callback_group","text":"rclcpp::CallbackGroup::SharedPtr callback_group;","title":"variable callback_group"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Intersection_1_1Connection/#variable-number_crunch_limit","text":"uint64_t number_crunch_limit;","title":"variable number_crunch_limit"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Intersection_1_1Connection/#variable-sequence_number","text":"uint32_t sequence_number = 0;","title":"variable sequence_number"},{"location":"Classes/structnodes_1_1rclcpp__system_1_1Intersection_1_1Connection/#variable-input_sequence_number","text":"uint32_t input_sequence_number = 0; Updated on 2022-04-30 at 21:32:33 +0000","title":"variable input_sequence_number"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/","text":"nodes::timing::BenchmarkCPUUsage Public Types Name using std::chrono::nanoseconds time_t using std::chrono::milliseconds milliseconds using std::chrono::seconds seconds Public Attributes Name constexpr time_t FRONT_LIDAR_DRIVER constexpr time_t REAR_LIDAR_DRIVER constexpr time_t POINT_CLOUD_MAP constexpr time_t VISUALIZER constexpr time_t LANELET2MAP constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS constexpr uint64_t POINTS_TRANSFORMER_FRONT constexpr uint64_t POINTS_TRANSFORMER_REAR constexpr uint64_t VOXEL_GRID_DOWNSAMPLER constexpr uint64_t POINT_CLOUD_MAP_LOADER constexpr uint64_t RAY_GROUND_FILTER constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR constexpr uint64_t EUCLIDEAN_INTERSECTION constexpr uint64_t OBJECT_COLLISION_ESTIMATOR constexpr uint64_t MPC_CONTROLLER constexpr uint64_t PARKING_PLANNER constexpr uint64_t LANE_PLANNER constexpr uint64_t POINT_CLOUD_FUSION constexpr uint64_t NDT_LOCALIZER constexpr uint64_t VEHICLE_INTERFACE constexpr uint64_t LANELET_2_GLOBAL_PLANNER constexpr uint64_t LANELET_2_MAP_LOADER constexpr uint64_t BEHAVIOR_PLANNER constexpr time_t BEHAVIOR_PLANNER_CYCLE Public Types Documentation using time_t using nodes::timing::BenchmarkCPUUsage::time_t = std::chrono::nanoseconds; using milliseconds using nodes::timing::BenchmarkCPUUsage::milliseconds = std::chrono::milliseconds; using seconds using nodes::timing::BenchmarkCPUUsage::seconds = std::chrono::seconds; Public Attributes Documentation variable FRONT_LIDAR_DRIVER static constexpr time_t FRONT_LIDAR_DRIVER = Default::FRONT_LIDAR_DRIVER; variable REAR_LIDAR_DRIVER static constexpr time_t REAR_LIDAR_DRIVER = Default::REAR_LIDAR_DRIVER; variable POINT_CLOUD_MAP static constexpr time_t POINT_CLOUD_MAP = Default::POINT_CLOUD_MAP; variable VISUALIZER static constexpr time_t VISUALIZER = Default::VISUALIZER; variable LANELET2MAP static constexpr time_t LANELET2MAP = Default::LANELET2MAP; variable EUCLIDEAN_CLUSTER_SETTINGS static constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS = Default::EUCLIDEAN_CLUSTER_SETTINGS; variable POINTS_TRANSFORMER_FRONT static constexpr uint64_t POINTS_TRANSFORMER_FRONT = 0; variable POINTS_TRANSFORMER_REAR static constexpr uint64_t POINTS_TRANSFORMER_REAR = 0; variable VOXEL_GRID_DOWNSAMPLER static constexpr uint64_t VOXEL_GRID_DOWNSAMPLER = 0; variable POINT_CLOUD_MAP_LOADER static constexpr uint64_t POINT_CLOUD_MAP_LOADER = 0; variable RAY_GROUND_FILTER static constexpr uint64_t RAY_GROUND_FILTER = 0; variable EUCLIDEAN_CLUSTER_DETECTOR static constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR = 0; variable EUCLIDEAN_INTERSECTION static constexpr uint64_t EUCLIDEAN_INTERSECTION = 0; variable OBJECT_COLLISION_ESTIMATOR static constexpr uint64_t OBJECT_COLLISION_ESTIMATOR = 0; variable MPC_CONTROLLER static constexpr uint64_t MPC_CONTROLLER = 0; variable PARKING_PLANNER static constexpr uint64_t PARKING_PLANNER = 0; variable LANE_PLANNER static constexpr uint64_t LANE_PLANNER = 0; variable POINT_CLOUD_FUSION static constexpr uint64_t POINT_CLOUD_FUSION = 0; variable NDT_LOCALIZER static constexpr uint64_t NDT_LOCALIZER = 0; variable VEHICLE_INTERFACE static constexpr uint64_t VEHICLE_INTERFACE = 0; variable LANELET_2_GLOBAL_PLANNER static constexpr uint64_t LANELET_2_GLOBAL_PLANNER = 0; variable LANELET_2_MAP_LOADER static constexpr uint64_t LANELET_2_MAP_LOADER = 0; variable BEHAVIOR_PLANNER static constexpr uint64_t BEHAVIOR_PLANNER = 0; variable BEHAVIOR_PLANNER_CYCLE static constexpr time_t BEHAVIOR_PLANNER_CYCLE = Default::BEHAVIOR_PLANNER_CYCLE; Updated on 2022-04-30 at 21:32:33 +0000","title":"nodes::timing::BenchmarkCPUUsage"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#nodestimingbenchmarkcpuusage","text":"","title":"nodes::timing::BenchmarkCPUUsage"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#public-types","text":"Name using std::chrono::nanoseconds time_t using std::chrono::milliseconds milliseconds using std::chrono::seconds seconds","title":"Public Types"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#public-attributes","text":"Name constexpr time_t FRONT_LIDAR_DRIVER constexpr time_t REAR_LIDAR_DRIVER constexpr time_t POINT_CLOUD_MAP constexpr time_t VISUALIZER constexpr time_t LANELET2MAP constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS constexpr uint64_t POINTS_TRANSFORMER_FRONT constexpr uint64_t POINTS_TRANSFORMER_REAR constexpr uint64_t VOXEL_GRID_DOWNSAMPLER constexpr uint64_t POINT_CLOUD_MAP_LOADER constexpr uint64_t RAY_GROUND_FILTER constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR constexpr uint64_t EUCLIDEAN_INTERSECTION constexpr uint64_t OBJECT_COLLISION_ESTIMATOR constexpr uint64_t MPC_CONTROLLER constexpr uint64_t PARKING_PLANNER constexpr uint64_t LANE_PLANNER constexpr uint64_t POINT_CLOUD_FUSION constexpr uint64_t NDT_LOCALIZER constexpr uint64_t VEHICLE_INTERFACE constexpr uint64_t LANELET_2_GLOBAL_PLANNER constexpr uint64_t LANELET_2_MAP_LOADER constexpr uint64_t BEHAVIOR_PLANNER constexpr time_t BEHAVIOR_PLANNER_CYCLE","title":"Public Attributes"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#using-time_t","text":"using nodes::timing::BenchmarkCPUUsage::time_t = std::chrono::nanoseconds;","title":"using time_t"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#using-milliseconds","text":"using nodes::timing::BenchmarkCPUUsage::milliseconds = std::chrono::milliseconds;","title":"using milliseconds"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#using-seconds","text":"using nodes::timing::BenchmarkCPUUsage::seconds = std::chrono::seconds;","title":"using seconds"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-front_lidar_driver","text":"static constexpr time_t FRONT_LIDAR_DRIVER = Default::FRONT_LIDAR_DRIVER;","title":"variable FRONT_LIDAR_DRIVER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-rear_lidar_driver","text":"static constexpr time_t REAR_LIDAR_DRIVER = Default::REAR_LIDAR_DRIVER;","title":"variable REAR_LIDAR_DRIVER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-point_cloud_map","text":"static constexpr time_t POINT_CLOUD_MAP = Default::POINT_CLOUD_MAP;","title":"variable POINT_CLOUD_MAP"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-visualizer","text":"static constexpr time_t VISUALIZER = Default::VISUALIZER;","title":"variable VISUALIZER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-lanelet2map","text":"static constexpr time_t LANELET2MAP = Default::LANELET2MAP;","title":"variable LANELET2MAP"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-euclidean_cluster_settings","text":"static constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS = Default::EUCLIDEAN_CLUSTER_SETTINGS;","title":"variable EUCLIDEAN_CLUSTER_SETTINGS"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-points_transformer_front","text":"static constexpr uint64_t POINTS_TRANSFORMER_FRONT = 0;","title":"variable POINTS_TRANSFORMER_FRONT"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-points_transformer_rear","text":"static constexpr uint64_t POINTS_TRANSFORMER_REAR = 0;","title":"variable POINTS_TRANSFORMER_REAR"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-voxel_grid_downsampler","text":"static constexpr uint64_t VOXEL_GRID_DOWNSAMPLER = 0;","title":"variable VOXEL_GRID_DOWNSAMPLER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-point_cloud_map_loader","text":"static constexpr uint64_t POINT_CLOUD_MAP_LOADER = 0;","title":"variable POINT_CLOUD_MAP_LOADER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-ray_ground_filter","text":"static constexpr uint64_t RAY_GROUND_FILTER = 0;","title":"variable RAY_GROUND_FILTER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-euclidean_cluster_detector","text":"static constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR = 0;","title":"variable EUCLIDEAN_CLUSTER_DETECTOR"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-euclidean_intersection","text":"static constexpr uint64_t EUCLIDEAN_INTERSECTION = 0;","title":"variable EUCLIDEAN_INTERSECTION"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-object_collision_estimator","text":"static constexpr uint64_t OBJECT_COLLISION_ESTIMATOR = 0;","title":"variable OBJECT_COLLISION_ESTIMATOR"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-mpc_controller","text":"static constexpr uint64_t MPC_CONTROLLER = 0;","title":"variable MPC_CONTROLLER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-parking_planner","text":"static constexpr uint64_t PARKING_PLANNER = 0;","title":"variable PARKING_PLANNER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-lane_planner","text":"static constexpr uint64_t LANE_PLANNER = 0;","title":"variable LANE_PLANNER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-point_cloud_fusion","text":"static constexpr uint64_t POINT_CLOUD_FUSION = 0;","title":"variable POINT_CLOUD_FUSION"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-ndt_localizer","text":"static constexpr uint64_t NDT_LOCALIZER = 0;","title":"variable NDT_LOCALIZER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-vehicle_interface","text":"static constexpr uint64_t VEHICLE_INTERFACE = 0;","title":"variable VEHICLE_INTERFACE"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-lanelet_2_global_planner","text":"static constexpr uint64_t LANELET_2_GLOBAL_PLANNER = 0;","title":"variable LANELET_2_GLOBAL_PLANNER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-lanelet_2_map_loader","text":"static constexpr uint64_t LANELET_2_MAP_LOADER = 0;","title":"variable LANELET_2_MAP_LOADER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-behavior_planner","text":"static constexpr uint64_t BEHAVIOR_PLANNER = 0;","title":"variable BEHAVIOR_PLANNER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkCPUUsage/#variable-behavior_planner_cycle","text":"static constexpr time_t BEHAVIOR_PLANNER_CYCLE = Default::BEHAVIOR_PLANNER_CYCLE; Updated on 2022-04-30 at 21:32:33 +0000","title":"variable BEHAVIOR_PLANNER_CYCLE"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/","text":"nodes::timing::BenchmarkThroughput Public Types Name using std::chrono::nanoseconds time_t using std::chrono::milliseconds milliseconds using std::chrono::seconds seconds Public Attributes Name constexpr time_t FRONT_LIDAR_DRIVER constexpr time_t REAR_LIDAR_DRIVER constexpr time_t POINT_CLOUD_MAP constexpr time_t VISUALIZER constexpr time_t LANELET2MAP constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS constexpr uint64_t POINTS_TRANSFORMER_FRONT constexpr uint64_t POINTS_TRANSFORMER_REAR constexpr uint64_t VOXEL_GRID_DOWNSAMPLER constexpr uint64_t POINT_CLOUD_MAP_LOADER constexpr uint64_t RAY_GROUND_FILTER constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR constexpr uint64_t EUCLIDEAN_INTERSECTION constexpr uint64_t OBJECT_COLLISION_ESTIMATOR constexpr uint64_t MPC_CONTROLLER constexpr uint64_t PARKING_PLANNER constexpr uint64_t LANE_PLANNER constexpr uint64_t POINT_CLOUD_FUSION constexpr uint64_t NDT_LOCALIZER constexpr uint64_t VEHICLE_INTERFACE constexpr uint64_t LANELET_2_GLOBAL_PLANNER constexpr uint64_t LANELET_2_MAP_LOADER constexpr uint64_t BEHAVIOR_PLANNER constexpr time_t BEHAVIOR_PLANNER_CYCLE Public Types Documentation using time_t using nodes::timing::BenchmarkThroughput::time_t = std::chrono::nanoseconds; using milliseconds using nodes::timing::BenchmarkThroughput::milliseconds = std::chrono::milliseconds; using seconds using nodes::timing::BenchmarkThroughput::seconds = std::chrono::seconds; Public Attributes Documentation variable FRONT_LIDAR_DRIVER static constexpr time_t FRONT_LIDAR_DRIVER = milliseconds(0); variable REAR_LIDAR_DRIVER static constexpr time_t REAR_LIDAR_DRIVER = milliseconds(0); variable POINT_CLOUD_MAP static constexpr time_t POINT_CLOUD_MAP = milliseconds(0); variable VISUALIZER static constexpr time_t VISUALIZER = milliseconds(0); variable LANELET2MAP static constexpr time_t LANELET2MAP = milliseconds(0); variable EUCLIDEAN_CLUSTER_SETTINGS static constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS = milliseconds(0); variable POINTS_TRANSFORMER_FRONT static constexpr uint64_t POINTS_TRANSFORMER_FRONT = 0; variable POINTS_TRANSFORMER_REAR static constexpr uint64_t POINTS_TRANSFORMER_REAR = 0; variable VOXEL_GRID_DOWNSAMPLER static constexpr uint64_t VOXEL_GRID_DOWNSAMPLER = 0; variable POINT_CLOUD_MAP_LOADER static constexpr uint64_t POINT_CLOUD_MAP_LOADER = 0; variable RAY_GROUND_FILTER static constexpr uint64_t RAY_GROUND_FILTER = 0; variable EUCLIDEAN_CLUSTER_DETECTOR static constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR = 0; variable EUCLIDEAN_INTERSECTION static constexpr uint64_t EUCLIDEAN_INTERSECTION = 0; variable OBJECT_COLLISION_ESTIMATOR static constexpr uint64_t OBJECT_COLLISION_ESTIMATOR = 0; variable MPC_CONTROLLER static constexpr uint64_t MPC_CONTROLLER = 0; variable PARKING_PLANNER static constexpr uint64_t PARKING_PLANNER = 0; variable LANE_PLANNER static constexpr uint64_t LANE_PLANNER = 0; variable POINT_CLOUD_FUSION static constexpr uint64_t POINT_CLOUD_FUSION = 0; variable NDT_LOCALIZER static constexpr uint64_t NDT_LOCALIZER = 0; variable VEHICLE_INTERFACE static constexpr uint64_t VEHICLE_INTERFACE = 0; variable LANELET_2_GLOBAL_PLANNER static constexpr uint64_t LANELET_2_GLOBAL_PLANNER = 0; variable LANELET_2_MAP_LOADER static constexpr uint64_t LANELET_2_MAP_LOADER = 0; variable BEHAVIOR_PLANNER static constexpr uint64_t BEHAVIOR_PLANNER = 0; variable BEHAVIOR_PLANNER_CYCLE static constexpr time_t BEHAVIOR_PLANNER_CYCLE = milliseconds(0); Updated on 2022-04-30 at 21:32:33 +0000","title":"nodes::timing::BenchmarkThroughput"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#nodestimingbenchmarkthroughput","text":"","title":"nodes::timing::BenchmarkThroughput"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#public-types","text":"Name using std::chrono::nanoseconds time_t using std::chrono::milliseconds milliseconds using std::chrono::seconds seconds","title":"Public Types"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#public-attributes","text":"Name constexpr time_t FRONT_LIDAR_DRIVER constexpr time_t REAR_LIDAR_DRIVER constexpr time_t POINT_CLOUD_MAP constexpr time_t VISUALIZER constexpr time_t LANELET2MAP constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS constexpr uint64_t POINTS_TRANSFORMER_FRONT constexpr uint64_t POINTS_TRANSFORMER_REAR constexpr uint64_t VOXEL_GRID_DOWNSAMPLER constexpr uint64_t POINT_CLOUD_MAP_LOADER constexpr uint64_t RAY_GROUND_FILTER constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR constexpr uint64_t EUCLIDEAN_INTERSECTION constexpr uint64_t OBJECT_COLLISION_ESTIMATOR constexpr uint64_t MPC_CONTROLLER constexpr uint64_t PARKING_PLANNER constexpr uint64_t LANE_PLANNER constexpr uint64_t POINT_CLOUD_FUSION constexpr uint64_t NDT_LOCALIZER constexpr uint64_t VEHICLE_INTERFACE constexpr uint64_t LANELET_2_GLOBAL_PLANNER constexpr uint64_t LANELET_2_MAP_LOADER constexpr uint64_t BEHAVIOR_PLANNER constexpr time_t BEHAVIOR_PLANNER_CYCLE","title":"Public Attributes"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#using-time_t","text":"using nodes::timing::BenchmarkThroughput::time_t = std::chrono::nanoseconds;","title":"using time_t"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#using-milliseconds","text":"using nodes::timing::BenchmarkThroughput::milliseconds = std::chrono::milliseconds;","title":"using milliseconds"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#using-seconds","text":"using nodes::timing::BenchmarkThroughput::seconds = std::chrono::seconds;","title":"using seconds"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-front_lidar_driver","text":"static constexpr time_t FRONT_LIDAR_DRIVER = milliseconds(0);","title":"variable FRONT_LIDAR_DRIVER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-rear_lidar_driver","text":"static constexpr time_t REAR_LIDAR_DRIVER = milliseconds(0);","title":"variable REAR_LIDAR_DRIVER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-point_cloud_map","text":"static constexpr time_t POINT_CLOUD_MAP = milliseconds(0);","title":"variable POINT_CLOUD_MAP"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-visualizer","text":"static constexpr time_t VISUALIZER = milliseconds(0);","title":"variable VISUALIZER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-lanelet2map","text":"static constexpr time_t LANELET2MAP = milliseconds(0);","title":"variable LANELET2MAP"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-euclidean_cluster_settings","text":"static constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS = milliseconds(0);","title":"variable EUCLIDEAN_CLUSTER_SETTINGS"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-points_transformer_front","text":"static constexpr uint64_t POINTS_TRANSFORMER_FRONT = 0;","title":"variable POINTS_TRANSFORMER_FRONT"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-points_transformer_rear","text":"static constexpr uint64_t POINTS_TRANSFORMER_REAR = 0;","title":"variable POINTS_TRANSFORMER_REAR"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-voxel_grid_downsampler","text":"static constexpr uint64_t VOXEL_GRID_DOWNSAMPLER = 0;","title":"variable VOXEL_GRID_DOWNSAMPLER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-point_cloud_map_loader","text":"static constexpr uint64_t POINT_CLOUD_MAP_LOADER = 0;","title":"variable POINT_CLOUD_MAP_LOADER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-ray_ground_filter","text":"static constexpr uint64_t RAY_GROUND_FILTER = 0;","title":"variable RAY_GROUND_FILTER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-euclidean_cluster_detector","text":"static constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR = 0;","title":"variable EUCLIDEAN_CLUSTER_DETECTOR"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-euclidean_intersection","text":"static constexpr uint64_t EUCLIDEAN_INTERSECTION = 0;","title":"variable EUCLIDEAN_INTERSECTION"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-object_collision_estimator","text":"static constexpr uint64_t OBJECT_COLLISION_ESTIMATOR = 0;","title":"variable OBJECT_COLLISION_ESTIMATOR"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-mpc_controller","text":"static constexpr uint64_t MPC_CONTROLLER = 0;","title":"variable MPC_CONTROLLER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-parking_planner","text":"static constexpr uint64_t PARKING_PLANNER = 0;","title":"variable PARKING_PLANNER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-lane_planner","text":"static constexpr uint64_t LANE_PLANNER = 0;","title":"variable LANE_PLANNER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-point_cloud_fusion","text":"static constexpr uint64_t POINT_CLOUD_FUSION = 0;","title":"variable POINT_CLOUD_FUSION"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-ndt_localizer","text":"static constexpr uint64_t NDT_LOCALIZER = 0;","title":"variable NDT_LOCALIZER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-vehicle_interface","text":"static constexpr uint64_t VEHICLE_INTERFACE = 0;","title":"variable VEHICLE_INTERFACE"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-lanelet_2_global_planner","text":"static constexpr uint64_t LANELET_2_GLOBAL_PLANNER = 0;","title":"variable LANELET_2_GLOBAL_PLANNER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-lanelet_2_map_loader","text":"static constexpr uint64_t LANELET_2_MAP_LOADER = 0;","title":"variable LANELET_2_MAP_LOADER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-behavior_planner","text":"static constexpr uint64_t BEHAVIOR_PLANNER = 0;","title":"variable BEHAVIOR_PLANNER"},{"location":"Classes/structnodes_1_1timing_1_1BenchmarkThroughput/#variable-behavior_planner_cycle","text":"static constexpr time_t BEHAVIOR_PLANNER_CYCLE = milliseconds(0); Updated on 2022-04-30 at 21:32:33 +0000","title":"variable BEHAVIOR_PLANNER_CYCLE"},{"location":"Classes/structnodes_1_1timing_1_1Default/","text":"nodes::timing::Default Public Types Name using std::chrono::nanoseconds time_t using std::chrono::milliseconds milliseconds Public Attributes Name constexpr time_t FRONT_LIDAR_DRIVER constexpr time_t REAR_LIDAR_DRIVER constexpr time_t POINT_CLOUD_MAP constexpr time_t VISUALIZER constexpr time_t LANELET2MAP constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS constexpr uint64_t POINTS_TRANSFORMER_FRONT constexpr uint64_t POINTS_TRANSFORMER_REAR constexpr uint64_t VOXEL_GRID_DOWNSAMPLER constexpr uint64_t POINT_CLOUD_MAP_LOADER constexpr uint64_t RAY_GROUND_FILTER constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR constexpr uint64_t EUCLIDEAN_INTERSECTION constexpr uint64_t OBJECT_COLLISION_ESTIMATOR constexpr uint64_t MPC_CONTROLLER constexpr uint64_t PARKING_PLANNER constexpr uint64_t LANE_PLANNER constexpr uint64_t POINT_CLOUD_FUSION constexpr uint64_t NDT_LOCALIZER constexpr uint64_t VEHICLE_INTERFACE constexpr uint64_t LANELET_2_GLOBAL_PLANNER constexpr uint64_t LANELET_2_MAP_LOADER constexpr uint64_t BEHAVIOR_PLANNER constexpr time_t BEHAVIOR_PLANNER_CYCLE Public Types Documentation using time_t using nodes::timing::Default::time_t = std::chrono::nanoseconds; using milliseconds using nodes::timing::Default::milliseconds = std::chrono::milliseconds; Public Attributes Documentation variable FRONT_LIDAR_DRIVER static constexpr time_t FRONT_LIDAR_DRIVER = milliseconds(100); variable REAR_LIDAR_DRIVER static constexpr time_t REAR_LIDAR_DRIVER = milliseconds(100); variable POINT_CLOUD_MAP static constexpr time_t POINT_CLOUD_MAP = milliseconds(120); variable VISUALIZER static constexpr time_t VISUALIZER = milliseconds(60); variable LANELET2MAP static constexpr time_t LANELET2MAP = milliseconds(100); variable EUCLIDEAN_CLUSTER_SETTINGS static constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS = milliseconds(25); variable POINTS_TRANSFORMER_FRONT static constexpr uint64_t POINTS_TRANSFORMER_FRONT = 4096; variable POINTS_TRANSFORMER_REAR static constexpr uint64_t POINTS_TRANSFORMER_REAR = 4096; variable VOXEL_GRID_DOWNSAMPLER static constexpr uint64_t VOXEL_GRID_DOWNSAMPLER = 4096; variable POINT_CLOUD_MAP_LOADER static constexpr uint64_t POINT_CLOUD_MAP_LOADER = 4096; variable RAY_GROUND_FILTER static constexpr uint64_t RAY_GROUND_FILTER = 4096; variable EUCLIDEAN_CLUSTER_DETECTOR static constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR = 4096; variable EUCLIDEAN_INTERSECTION static constexpr uint64_t EUCLIDEAN_INTERSECTION = 4096; variable OBJECT_COLLISION_ESTIMATOR static constexpr uint64_t OBJECT_COLLISION_ESTIMATOR = 4096; variable MPC_CONTROLLER static constexpr uint64_t MPC_CONTROLLER = 4096; variable PARKING_PLANNER static constexpr uint64_t PARKING_PLANNER = 4096; variable LANE_PLANNER static constexpr uint64_t LANE_PLANNER = 4096; variable POINT_CLOUD_FUSION static constexpr uint64_t POINT_CLOUD_FUSION = 4096; variable NDT_LOCALIZER static constexpr uint64_t NDT_LOCALIZER = 4096; variable VEHICLE_INTERFACE static constexpr uint64_t VEHICLE_INTERFACE = 4096; variable LANELET_2_GLOBAL_PLANNER static constexpr uint64_t LANELET_2_GLOBAL_PLANNER = 4096; variable LANELET_2_MAP_LOADER static constexpr uint64_t LANELET_2_MAP_LOADER = 4096; variable BEHAVIOR_PLANNER static constexpr uint64_t BEHAVIOR_PLANNER = 4096; variable BEHAVIOR_PLANNER_CYCLE static constexpr time_t BEHAVIOR_PLANNER_CYCLE = milliseconds(100); Updated on 2022-04-30 at 21:32:33 +0000","title":"nodes::timing::Default"},{"location":"Classes/structnodes_1_1timing_1_1Default/#nodestimingdefault","text":"","title":"nodes::timing::Default"},{"location":"Classes/structnodes_1_1timing_1_1Default/#public-types","text":"Name using std::chrono::nanoseconds time_t using std::chrono::milliseconds milliseconds","title":"Public Types"},{"location":"Classes/structnodes_1_1timing_1_1Default/#public-attributes","text":"Name constexpr time_t FRONT_LIDAR_DRIVER constexpr time_t REAR_LIDAR_DRIVER constexpr time_t POINT_CLOUD_MAP constexpr time_t VISUALIZER constexpr time_t LANELET2MAP constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS constexpr uint64_t POINTS_TRANSFORMER_FRONT constexpr uint64_t POINTS_TRANSFORMER_REAR constexpr uint64_t VOXEL_GRID_DOWNSAMPLER constexpr uint64_t POINT_CLOUD_MAP_LOADER constexpr uint64_t RAY_GROUND_FILTER constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR constexpr uint64_t EUCLIDEAN_INTERSECTION constexpr uint64_t OBJECT_COLLISION_ESTIMATOR constexpr uint64_t MPC_CONTROLLER constexpr uint64_t PARKING_PLANNER constexpr uint64_t LANE_PLANNER constexpr uint64_t POINT_CLOUD_FUSION constexpr uint64_t NDT_LOCALIZER constexpr uint64_t VEHICLE_INTERFACE constexpr uint64_t LANELET_2_GLOBAL_PLANNER constexpr uint64_t LANELET_2_MAP_LOADER constexpr uint64_t BEHAVIOR_PLANNER constexpr time_t BEHAVIOR_PLANNER_CYCLE","title":"Public Attributes"},{"location":"Classes/structnodes_1_1timing_1_1Default/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Classes/structnodes_1_1timing_1_1Default/#using-time_t","text":"using nodes::timing::Default::time_t = std::chrono::nanoseconds;","title":"using time_t"},{"location":"Classes/structnodes_1_1timing_1_1Default/#using-milliseconds","text":"using nodes::timing::Default::milliseconds = std::chrono::milliseconds;","title":"using milliseconds"},{"location":"Classes/structnodes_1_1timing_1_1Default/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-front_lidar_driver","text":"static constexpr time_t FRONT_LIDAR_DRIVER = milliseconds(100);","title":"variable FRONT_LIDAR_DRIVER"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-rear_lidar_driver","text":"static constexpr time_t REAR_LIDAR_DRIVER = milliseconds(100);","title":"variable REAR_LIDAR_DRIVER"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-point_cloud_map","text":"static constexpr time_t POINT_CLOUD_MAP = milliseconds(120);","title":"variable POINT_CLOUD_MAP"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-visualizer","text":"static constexpr time_t VISUALIZER = milliseconds(60);","title":"variable VISUALIZER"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-lanelet2map","text":"static constexpr time_t LANELET2MAP = milliseconds(100);","title":"variable LANELET2MAP"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-euclidean_cluster_settings","text":"static constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS = milliseconds(25);","title":"variable EUCLIDEAN_CLUSTER_SETTINGS"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-points_transformer_front","text":"static constexpr uint64_t POINTS_TRANSFORMER_FRONT = 4096;","title":"variable POINTS_TRANSFORMER_FRONT"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-points_transformer_rear","text":"static constexpr uint64_t POINTS_TRANSFORMER_REAR = 4096;","title":"variable POINTS_TRANSFORMER_REAR"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-voxel_grid_downsampler","text":"static constexpr uint64_t VOXEL_GRID_DOWNSAMPLER = 4096;","title":"variable VOXEL_GRID_DOWNSAMPLER"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-point_cloud_map_loader","text":"static constexpr uint64_t POINT_CLOUD_MAP_LOADER = 4096;","title":"variable POINT_CLOUD_MAP_LOADER"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-ray_ground_filter","text":"static constexpr uint64_t RAY_GROUND_FILTER = 4096;","title":"variable RAY_GROUND_FILTER"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-euclidean_cluster_detector","text":"static constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR = 4096;","title":"variable EUCLIDEAN_CLUSTER_DETECTOR"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-euclidean_intersection","text":"static constexpr uint64_t EUCLIDEAN_INTERSECTION = 4096;","title":"variable EUCLIDEAN_INTERSECTION"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-object_collision_estimator","text":"static constexpr uint64_t OBJECT_COLLISION_ESTIMATOR = 4096;","title":"variable OBJECT_COLLISION_ESTIMATOR"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-mpc_controller","text":"static constexpr uint64_t MPC_CONTROLLER = 4096;","title":"variable MPC_CONTROLLER"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-parking_planner","text":"static constexpr uint64_t PARKING_PLANNER = 4096;","title":"variable PARKING_PLANNER"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-lane_planner","text":"static constexpr uint64_t LANE_PLANNER = 4096;","title":"variable LANE_PLANNER"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-point_cloud_fusion","text":"static constexpr uint64_t POINT_CLOUD_FUSION = 4096;","title":"variable POINT_CLOUD_FUSION"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-ndt_localizer","text":"static constexpr uint64_t NDT_LOCALIZER = 4096;","title":"variable NDT_LOCALIZER"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-vehicle_interface","text":"static constexpr uint64_t VEHICLE_INTERFACE = 4096;","title":"variable VEHICLE_INTERFACE"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-lanelet_2_global_planner","text":"static constexpr uint64_t LANELET_2_GLOBAL_PLANNER = 4096;","title":"variable LANELET_2_GLOBAL_PLANNER"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-lanelet_2_map_loader","text":"static constexpr uint64_t LANELET_2_MAP_LOADER = 4096;","title":"variable LANELET_2_MAP_LOADER"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-behavior_planner","text":"static constexpr uint64_t BEHAVIOR_PLANNER = 4096;","title":"variable BEHAVIOR_PLANNER"},{"location":"Classes/structnodes_1_1timing_1_1Default/#variable-behavior_planner_cycle","text":"static constexpr time_t BEHAVIOR_PLANNER_CYCLE = milliseconds(100); Updated on 2022-04-30 at 21:32:33 +0000","title":"variable BEHAVIOR_PLANNER_CYCLE"},{"location":"Classes/structreference__interfaces_1_1msg_1_1Message4kb/","text":"reference_interfaces::msg::Message4kb Public Attributes Name uint64 size reference_interfaces::msg::TransmissionStats stats int64 data Public Attributes Documentation variable size uint64 size; variable stats reference_interfaces::msg::TransmissionStats stats; variable data int64 data; Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_interfaces::msg::Message4kb"},{"location":"Classes/structreference__interfaces_1_1msg_1_1Message4kb/#reference_interfacesmsgmessage4kb","text":"","title":"reference_interfaces::msg::Message4kb"},{"location":"Classes/structreference__interfaces_1_1msg_1_1Message4kb/#public-attributes","text":"Name uint64 size reference_interfaces::msg::TransmissionStats stats int64 data","title":"Public Attributes"},{"location":"Classes/structreference__interfaces_1_1msg_1_1Message4kb/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structreference__interfaces_1_1msg_1_1Message4kb/#variable-size","text":"uint64 size;","title":"variable size"},{"location":"Classes/structreference__interfaces_1_1msg_1_1Message4kb/#variable-stats","text":"reference_interfaces::msg::TransmissionStats stats;","title":"variable stats"},{"location":"Classes/structreference__interfaces_1_1msg_1_1Message4kb/#variable-data","text":"int64 data; Updated on 2022-04-30 at 21:32:33 +0000","title":"variable data"},{"location":"Classes/structreference__interfaces_1_1msg_1_1TransmissionStats/","text":"reference_interfaces::msg::TransmissionStats Public Attributes Name uint64 timestamp uint32 sequence_number uint32 dropped_samples char node_name Public Attributes Documentation variable timestamp uint64 timestamp; variable sequence_number uint32 sequence_number; variable dropped_samples uint32 dropped_samples; variable node_name char node_name; Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_interfaces::msg::TransmissionStats"},{"location":"Classes/structreference__interfaces_1_1msg_1_1TransmissionStats/#reference_interfacesmsgtransmissionstats","text":"","title":"reference_interfaces::msg::TransmissionStats"},{"location":"Classes/structreference__interfaces_1_1msg_1_1TransmissionStats/#public-attributes","text":"Name uint64 timestamp uint32 sequence_number uint32 dropped_samples char node_name","title":"Public Attributes"},{"location":"Classes/structreference__interfaces_1_1msg_1_1TransmissionStats/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structreference__interfaces_1_1msg_1_1TransmissionStats/#variable-timestamp","text":"uint64 timestamp;","title":"variable timestamp"},{"location":"Classes/structreference__interfaces_1_1msg_1_1TransmissionStats/#variable-sequence_number","text":"uint32 sequence_number;","title":"variable sequence_number"},{"location":"Classes/structreference__interfaces_1_1msg_1_1TransmissionStats/#variable-dropped_samples","text":"uint32 dropped_samples;","title":"variable dropped_samples"},{"location":"Classes/structreference__interfaces_1_1msg_1_1TransmissionStats/#variable-node_name","text":"char node_name; Updated on 2022-04-30 at 21:32:33 +0000","title":"variable node_name"},{"location":"Classes/structsample__statistic__t/","text":"sample_statistic_t Public Attributes Name uint64_t timepoint_of_first_received_sample uint32_t previous_behavior_planner_sequence uint64_t previous_behavior_planner_time_stamp statistic_value_t latency statistic_value_t hot_path_latency statistic_value_t behavior_planner_period Public Attributes Documentation variable timepoint_of_first_received_sample uint64_t timepoint_of_first_received_sample = 0; variable previous_behavior_planner_sequence uint32_t previous_behavior_planner_sequence = 0; variable previous_behavior_planner_time_stamp uint64_t previous_behavior_planner_time_stamp = 0; variable latency statistic_value_t latency; variable hot_path_latency statistic_value_t hot_path_latency; variable behavior_planner_period statistic_value_t behavior_planner_period; Updated on 2022-04-30 at 21:32:33 +0000","title":"sample_statistic_t"},{"location":"Classes/structsample__statistic__t/#sample_statistic_t","text":"","title":"sample_statistic_t"},{"location":"Classes/structsample__statistic__t/#public-attributes","text":"Name uint64_t timepoint_of_first_received_sample uint32_t previous_behavior_planner_sequence uint64_t previous_behavior_planner_time_stamp statistic_value_t latency statistic_value_t hot_path_latency statistic_value_t behavior_planner_period","title":"Public Attributes"},{"location":"Classes/structsample__statistic__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structsample__statistic__t/#variable-timepoint_of_first_received_sample","text":"uint64_t timepoint_of_first_received_sample = 0;","title":"variable timepoint_of_first_received_sample"},{"location":"Classes/structsample__statistic__t/#variable-previous_behavior_planner_sequence","text":"uint32_t previous_behavior_planner_sequence = 0;","title":"variable previous_behavior_planner_sequence"},{"location":"Classes/structsample__statistic__t/#variable-previous_behavior_planner_time_stamp","text":"uint64_t previous_behavior_planner_time_stamp = 0;","title":"variable previous_behavior_planner_time_stamp"},{"location":"Classes/structsample__statistic__t/#variable-latency","text":"statistic_value_t latency;","title":"variable latency"},{"location":"Classes/structsample__statistic__t/#variable-hot_path_latency","text":"statistic_value_t hot_path_latency;","title":"variable hot_path_latency"},{"location":"Classes/structsample__statistic__t/#variable-behavior_planner_period","text":"statistic_value_t behavior_planner_period; Updated on 2022-04-30 at 21:32:33 +0000","title":"variable behavior_planner_period"},{"location":"Classes/structstatistic__value__t/","text":"statistic_value_t Public Functions Name void set (const uint64_t value) Public Attributes Name double average double deviation uint64_t min uint64_t max uint64_t current double total_number std::string suffix double adjustment double m2 Public Functions Documentation function set inline void set( const uint64_t value ) Public Attributes Documentation variable average double average = 0.0; variable deviation double deviation = 0.0; variable min uint64_t min = std::numeric_limits<uint64_t>::max(); variable max uint64_t max = 0; variable current uint64_t current = 0; variable total_number double total_number = 0.0; variable suffix std::string suffix; variable adjustment double adjustment = 0.0; variable m2 double m2 = 0.0; Updated on 2022-04-30 at 21:32:33 +0000","title":"statistic_value_t"},{"location":"Classes/structstatistic__value__t/#statistic_value_t","text":"","title":"statistic_value_t"},{"location":"Classes/structstatistic__value__t/#public-functions","text":"Name void set (const uint64_t value)","title":"Public Functions"},{"location":"Classes/structstatistic__value__t/#public-attributes","text":"Name double average double deviation uint64_t min uint64_t max uint64_t current double total_number std::string suffix double adjustment double m2","title":"Public Attributes"},{"location":"Classes/structstatistic__value__t/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Classes/structstatistic__value__t/#function-set","text":"inline void set( const uint64_t value )","title":"function set"},{"location":"Classes/structstatistic__value__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Classes/structstatistic__value__t/#variable-average","text":"double average = 0.0;","title":"variable average"},{"location":"Classes/structstatistic__value__t/#variable-deviation","text":"double deviation = 0.0;","title":"variable deviation"},{"location":"Classes/structstatistic__value__t/#variable-min","text":"uint64_t min = std::numeric_limits<uint64_t>::max();","title":"variable min"},{"location":"Classes/structstatistic__value__t/#variable-max","text":"uint64_t max = 0;","title":"variable max"},{"location":"Classes/structstatistic__value__t/#variable-current","text":"uint64_t current = 0;","title":"variable current"},{"location":"Classes/structstatistic__value__t/#variable-total_number","text":"double total_number = 0.0;","title":"variable total_number"},{"location":"Classes/structstatistic__value__t/#variable-suffix","text":"std::string suffix;","title":"variable suffix"},{"location":"Classes/structstatistic__value__t/#variable-adjustment","text":"double adjustment = 0.0;","title":"variable adjustment"},{"location":"Classes/structstatistic__value__t/#variable-m2","text":"double m2 = 0.0; Updated on 2022-04-30 at 21:32:33 +0000","title":"variable m2"},{"location":"Files/","text":"Files file CMakeLists.txt file CMakeLists.txt file CMakeLists.txt file README.md file README.md dir autoware_reference_system dir autoware_reference_system/include dir autoware_reference_system/include/autoware_reference_system dir autoware_reference_system/include/autoware_reference_system/system dir autoware_reference_system/include/autoware_reference_system/system/timing file autoware_reference_system/include/autoware_reference_system/system/timing/benchmark.hpp file autoware_reference_system/include/autoware_reference_system/system/timing/default.hpp file autoware_reference_system/include/autoware_reference_system/autoware_system_builder.hpp file autoware_reference_system/include/autoware_reference_system/priorities.hpp dir autoware_reference_system/scripts file autoware_reference_system/scripts/benchmark.py dir autoware_reference_system/src dir autoware_reference_system/src/ros2 dir autoware_reference_system/src/ros2/executor file autoware_reference_system/src/ros2/executor/autoware_default_cbg.cpp file autoware_reference_system/src/ros2/executor/autoware_default_multithreaded.cpp file autoware_reference_system/src/ros2/executor/autoware_default_prioritized.cpp file autoware_reference_system/src/ros2/executor/autoware_default_singlethreaded.cpp file autoware_reference_system/src/ros2/executor/autoware_default_staticsinglethreaded.cpp file autoware_reference_system/src/number_cruncher_benchmark.cpp file autoware_reference_system/src/priorities.cpp dir autoware_reference_system/test file autoware_reference_system/test/conftest.py file autoware_reference_system/test/test_autoware_reference_system.cpp file autoware_reference_system/test/test_platform.py file autoware_reference_system/test/test_requirements.py dir reference_interfaces dir reference_interfaces/msg file reference_interfaces/msg/Message4kb.idl file reference_interfaces/msg/TransmissionStats.idl dir reference_system dir reference_system/include dir reference_system/include/reference_system file reference_system/include/reference_system/msg_types.hpp file reference_system/include/reference_system/number_cruncher.hpp dir reference_system/include/reference_system/nodes dir reference_system/include/reference_system/nodes/rclcpp file reference_system/include/reference_system/nodes/rclcpp/command.hpp file reference_system/include/reference_system/nodes/rclcpp/cyclic.hpp file reference_system/include/reference_system/nodes/rclcpp/fusion.hpp file reference_system/include/reference_system/nodes/rclcpp/intersection.hpp file reference_system/include/reference_system/nodes/rclcpp/sensor.hpp file reference_system/include/reference_system/nodes/rclcpp/transform.hpp file reference_system/include/reference_system/nodes/settings.hpp dir reference_system/include/reference_system/system dir reference_system/include/reference_system/system/type file reference_system/include/reference_system/system/type/rclcpp_system.hpp file reference_system/include/reference_system/sample_management.hpp dir reference_system/reference_system_py file reference_system/reference_system_py/ init .py file reference_system/reference_system_py/benchmark.py file reference_system/reference_system_py/callback_duration.py file reference_system/reference_system_py/constants.py file reference_system/reference_system_py/dropped_messages.py file reference_system/reference_system_py/memory_usage.py file reference_system/reference_system_py/plot_utils.py file reference_system/reference_system_py/std_latency.py file reference_system/reference_system_py/trace_utils.py dir reference_system/test file reference_system/test/gtest_main.cpp file reference_system/test/test_fixtures.hpp file reference_system/test/test_number_cruncher.cpp file reference_system/test/test_reference_system_rclcpp.cpp file reference_system/test/test_sample_management.cpp file reference_system/setup.py Updated on 2022-04-30 at 21:32:33 +0000","title":"Files"},{"location":"Files/#files","text":"file CMakeLists.txt file CMakeLists.txt file CMakeLists.txt file README.md file README.md dir autoware_reference_system dir autoware_reference_system/include dir autoware_reference_system/include/autoware_reference_system dir autoware_reference_system/include/autoware_reference_system/system dir autoware_reference_system/include/autoware_reference_system/system/timing file autoware_reference_system/include/autoware_reference_system/system/timing/benchmark.hpp file autoware_reference_system/include/autoware_reference_system/system/timing/default.hpp file autoware_reference_system/include/autoware_reference_system/autoware_system_builder.hpp file autoware_reference_system/include/autoware_reference_system/priorities.hpp dir autoware_reference_system/scripts file autoware_reference_system/scripts/benchmark.py dir autoware_reference_system/src dir autoware_reference_system/src/ros2 dir autoware_reference_system/src/ros2/executor file autoware_reference_system/src/ros2/executor/autoware_default_cbg.cpp file autoware_reference_system/src/ros2/executor/autoware_default_multithreaded.cpp file autoware_reference_system/src/ros2/executor/autoware_default_prioritized.cpp file autoware_reference_system/src/ros2/executor/autoware_default_singlethreaded.cpp file autoware_reference_system/src/ros2/executor/autoware_default_staticsinglethreaded.cpp file autoware_reference_system/src/number_cruncher_benchmark.cpp file autoware_reference_system/src/priorities.cpp dir autoware_reference_system/test file autoware_reference_system/test/conftest.py file autoware_reference_system/test/test_autoware_reference_system.cpp file autoware_reference_system/test/test_platform.py file autoware_reference_system/test/test_requirements.py dir reference_interfaces dir reference_interfaces/msg file reference_interfaces/msg/Message4kb.idl file reference_interfaces/msg/TransmissionStats.idl dir reference_system dir reference_system/include dir reference_system/include/reference_system file reference_system/include/reference_system/msg_types.hpp file reference_system/include/reference_system/number_cruncher.hpp dir reference_system/include/reference_system/nodes dir reference_system/include/reference_system/nodes/rclcpp file reference_system/include/reference_system/nodes/rclcpp/command.hpp file reference_system/include/reference_system/nodes/rclcpp/cyclic.hpp file reference_system/include/reference_system/nodes/rclcpp/fusion.hpp file reference_system/include/reference_system/nodes/rclcpp/intersection.hpp file reference_system/include/reference_system/nodes/rclcpp/sensor.hpp file reference_system/include/reference_system/nodes/rclcpp/transform.hpp file reference_system/include/reference_system/nodes/settings.hpp dir reference_system/include/reference_system/system dir reference_system/include/reference_system/system/type file reference_system/include/reference_system/system/type/rclcpp_system.hpp file reference_system/include/reference_system/sample_management.hpp dir reference_system/reference_system_py file reference_system/reference_system_py/ init .py file reference_system/reference_system_py/benchmark.py file reference_system/reference_system_py/callback_duration.py file reference_system/reference_system_py/constants.py file reference_system/reference_system_py/dropped_messages.py file reference_system/reference_system_py/memory_usage.py file reference_system/reference_system_py/plot_utils.py file reference_system/reference_system_py/std_latency.py file reference_system/reference_system_py/trace_utils.py dir reference_system/test file reference_system/test/gtest_main.cpp file reference_system/test/test_fixtures.hpp file reference_system/test/test_number_cruncher.cpp file reference_system/test/test_reference_system_rclcpp.cpp file reference_system/test/test_sample_management.cpp file reference_system/setup.py Updated on 2022-04-30 at 21:32:33 +0000","title":"Files"},{"location":"Files/Message4kb_8idl/","text":"reference_interfaces/msg/Message4kb.idl Namespaces Name reference_interfaces reference_interfaces::msg reference_interfaces::msg::Message4kb_Constants Classes Name struct reference_interfaces::msg::Message4kb Source code #include \"reference_interfaces/msg/TransmissionStats.idl\" module reference_interfaces { module msg { module Message4kb_Constants { const uint64 STATS_CAPACITY = 63; }; struct Message4kb { uint64 size; // 8 reference_interfaces::msg::TransmissionStats stats[63]; // + 4032 = 63 * 64 int64 data[7]; // + 56 = 7 * 8 //----------------- // 4096 }; }; }; Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_interfaces/msg/Message4kb.idl"},{"location":"Files/Message4kb_8idl/#reference_interfacesmsgmessage4kbidl","text":"","title":"reference_interfaces/msg/Message4kb.idl"},{"location":"Files/Message4kb_8idl/#namespaces","text":"Name reference_interfaces reference_interfaces::msg reference_interfaces::msg::Message4kb_Constants","title":"Namespaces"},{"location":"Files/Message4kb_8idl/#classes","text":"Name struct reference_interfaces::msg::Message4kb","title":"Classes"},{"location":"Files/Message4kb_8idl/#source-code","text":"#include \"reference_interfaces/msg/TransmissionStats.idl\" module reference_interfaces { module msg { module Message4kb_Constants { const uint64 STATS_CAPACITY = 63; }; struct Message4kb { uint64 size; // 8 reference_interfaces::msg::TransmissionStats stats[63]; // + 4032 = 63 * 64 int64 data[7]; // + 56 = 7 * 8 //----------------- // 4096 }; }; }; Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/TransmissionStats_8idl/","text":"reference_interfaces/msg/TransmissionStats.idl Namespaces Name reference_interfaces reference_interfaces::msg reference_interfaces::msg::TransmissionStats_Constants Classes Name struct reference_interfaces::msg::TransmissionStats Source code module reference_interfaces { module msg { module TransmissionStats_Constants { const uint64 NODE_NAME_LENGTH = 48; }; struct TransmissionStats { // 64 bytes uint64 timestamp; uint32 sequence_number; uint32 dropped_samples; char node_name[48]; }; }; }; Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_interfaces/msg/TransmissionStats.idl"},{"location":"Files/TransmissionStats_8idl/#reference_interfacesmsgtransmissionstatsidl","text":"","title":"reference_interfaces/msg/TransmissionStats.idl"},{"location":"Files/TransmissionStats_8idl/#namespaces","text":"Name reference_interfaces reference_interfaces::msg reference_interfaces::msg::TransmissionStats_Constants","title":"Namespaces"},{"location":"Files/TransmissionStats_8idl/#classes","text":"Name struct reference_interfaces::msg::TransmissionStats","title":"Classes"},{"location":"Files/TransmissionStats_8idl/#source-code","text":"module reference_interfaces { module msg { module TransmissionStats_Constants { const uint64 NODE_NAME_LENGTH = 48; }; struct TransmissionStats { // 64 bytes uint64 timestamp; uint32 sequence_number; uint32 dropped_samples; char node_name[48]; }; }; }; Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/____init_____8py/","text":"reference_system/reference_system_py/ init .py Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/reference_system_py/__init__.py"},{"location":"Files/____init_____8py/#reference_systemreference_system_pyinitpy","text":"Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/reference_system_py/init.py"},{"location":"Files/autoware__default__cbg_8cpp/","text":"autoware_reference_system/src/ros2/executor/autoware_default_cbg.cpp Functions Name void set_rt_properties (int prio, const std::unordered_set< size_t > & affinity) int main (int argc, char ** argv) Functions Documentation function set_rt_properties void set_rt_properties( int prio, const std::unordered_set< size_t > & affinity ) function main int main( int argc, char ** argv ) Source code // Copyright 2021 Robert Bosch GmbH // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <memory> #include <string> #include <vector> #include <unordered_set> #include <unordered_map> #include <set> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/system/type/rclcpp_system.hpp\" #include \"autoware_reference_system/autoware_system_builder.hpp\" #include \"autoware_reference_system/system/timing/benchmark.hpp\" #include \"autoware_reference_system/system/timing/default.hpp\" #include \"autoware_reference_system/priorities.hpp\" void set_rt_properties(int prio, const std::unordered_set<size_t> & affinity) { struct sched_param sched_param = { 0 }; sched_param.sched_priority = prio; sched_setscheduler(0, SCHED_RR, &sched_param); cpu_set_t cpuset; CPU_ZERO(&cpuset); for (const auto cpu : affinity) { CPU_SET(cpu, &cpuset); } sched_setaffinity(0, sizeof(cpuset), &cpuset); } int main(int argc, char ** argv) { rclcpp::init(argc, argv); using TimeConfig = nodes::timing::Default; // uncomment for benchmarking // using TimeConfig = nodes::timing::BenchmarkCPUUsage; // set_benchmark_mode(true); auto nodes_vec = create_autoware_nodes<RclcppSystem, TimeConfig>(); using NodeMap = std::unordered_map<std::string, std::shared_ptr<RclcppSystem::NodeBaseType>>; NodeMap nodes; for (const auto & node : nodes_vec) { nodes.emplace(node->get_name(), node); } rclcpp::executors::SingleThreadedExecutor front_exe, rear_exe, fusion_exe, planner_exe, other_exe; std::set<std::string> front_nodes = {\"FrontLidarDriver\", \"PointsTransformerFront\"}; std::set<std::string> rear_nodes = {\"RearLidarDriver\", \"PointsTransformerRear\"}; std::set<std::string> fusion_nodes = {\"PointCloudFusion\", \"RayGroundFilter\", // \"EuclideanClusterDetector\" is a special case and // prioritized on the callback-group level. \"ObjectCollisionEstimator\"}; std::set<std::string> planner_nodes = {\"BehaviorPlanner\"}; std::set<std::string> other_nodes = {\"PointCloudMap\", \"Visualizer\", \"Lanelet2Map\", \"EuclideanClusterSettings\", \"PointCloudMapLoader\", \"MPCController\", \"VehicleInterface\", \"VehicleDBWSystem\", \"NDTLocalizer\", \"Lanelet2GlobalPlanner\", \"Lanelet2MapLoader\", \"ParkingPlanner\", \"LanePlanner\", \"IntersectionOutput\", \"VoxelGridDownsampler\"}; for (const auto & node : front_nodes) { front_exe.add_node(nodes.at(node)); } for (const auto & node : rear_nodes) { rear_exe.add_node(nodes.at(node)); } for (const auto & node : planner_nodes) { planner_exe.add_node(nodes.at(node)); } for (const auto & node : fusion_nodes) { fusion_exe.add_node(nodes.at(node)); } auto euclidean_node = std::dynamic_pointer_cast<RclcppSystem::Intersection>( nodes.at(\"EuclideanClusterDetector\")); assert(euclidean_node); fusion_exe.add_callback_group( euclidean_node->get_callback_group_of_subscription(\"/RayGroundFilter\"), euclidean_node->get_node_base_interface()); other_exe.add_node(nodes.at(\"EuclideanClusterDetector\")); for (const auto & node : other_nodes) { other_exe.add_node(nodes.at(node)); } std::thread front_thread {[&]() { set_rt_properties(hotpath_prio, HOTPATH_AFFINITY); front_exe.spin(); }}; std::thread rear_thread {[&]() { set_rt_properties(hotpath_prio, HOTPATH_AFFINITY); rear_exe.spin(); }}; std::thread fusion_thread {[&]() { set_rt_properties(hotpath_prio, HOTPATH_AFFINITY); fusion_exe.spin(); }}; std::thread planner_thread {[&]() { set_rt_properties(planner_prio, PLANNER_AFFINITY); planner_exe.spin(); }}; std::thread other_thread {[&]() { other_exe.spin(); }}; front_thread.join(); rear_thread.join(); fusion_thread.join(); planner_thread.join(); rclcpp::shutdown(); } Updated on 2022-04-30 at 21:32:33 +0000","title":"autoware_reference_system/src/ros2/executor/autoware_default_cbg.cpp"},{"location":"Files/autoware__default__cbg_8cpp/#autoware_reference_systemsrcros2executorautoware_default_cbgcpp","text":"","title":"autoware_reference_system/src/ros2/executor/autoware_default_cbg.cpp"},{"location":"Files/autoware__default__cbg_8cpp/#functions","text":"Name void set_rt_properties (int prio, const std::unordered_set< size_t > & affinity) int main (int argc, char ** argv)","title":"Functions"},{"location":"Files/autoware__default__cbg_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/autoware__default__cbg_8cpp/#function-set_rt_properties","text":"void set_rt_properties( int prio, const std::unordered_set< size_t > & affinity )","title":"function set_rt_properties"},{"location":"Files/autoware__default__cbg_8cpp/#function-main","text":"int main( int argc, char ** argv )","title":"function main"},{"location":"Files/autoware__default__cbg_8cpp/#source-code","text":"// Copyright 2021 Robert Bosch GmbH // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <memory> #include <string> #include <vector> #include <unordered_set> #include <unordered_map> #include <set> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/system/type/rclcpp_system.hpp\" #include \"autoware_reference_system/autoware_system_builder.hpp\" #include \"autoware_reference_system/system/timing/benchmark.hpp\" #include \"autoware_reference_system/system/timing/default.hpp\" #include \"autoware_reference_system/priorities.hpp\" void set_rt_properties(int prio, const std::unordered_set<size_t> & affinity) { struct sched_param sched_param = { 0 }; sched_param.sched_priority = prio; sched_setscheduler(0, SCHED_RR, &sched_param); cpu_set_t cpuset; CPU_ZERO(&cpuset); for (const auto cpu : affinity) { CPU_SET(cpu, &cpuset); } sched_setaffinity(0, sizeof(cpuset), &cpuset); } int main(int argc, char ** argv) { rclcpp::init(argc, argv); using TimeConfig = nodes::timing::Default; // uncomment for benchmarking // using TimeConfig = nodes::timing::BenchmarkCPUUsage; // set_benchmark_mode(true); auto nodes_vec = create_autoware_nodes<RclcppSystem, TimeConfig>(); using NodeMap = std::unordered_map<std::string, std::shared_ptr<RclcppSystem::NodeBaseType>>; NodeMap nodes; for (const auto & node : nodes_vec) { nodes.emplace(node->get_name(), node); } rclcpp::executors::SingleThreadedExecutor front_exe, rear_exe, fusion_exe, planner_exe, other_exe; std::set<std::string> front_nodes = {\"FrontLidarDriver\", \"PointsTransformerFront\"}; std::set<std::string> rear_nodes = {\"RearLidarDriver\", \"PointsTransformerRear\"}; std::set<std::string> fusion_nodes = {\"PointCloudFusion\", \"RayGroundFilter\", // \"EuclideanClusterDetector\" is a special case and // prioritized on the callback-group level. \"ObjectCollisionEstimator\"}; std::set<std::string> planner_nodes = {\"BehaviorPlanner\"}; std::set<std::string> other_nodes = {\"PointCloudMap\", \"Visualizer\", \"Lanelet2Map\", \"EuclideanClusterSettings\", \"PointCloudMapLoader\", \"MPCController\", \"VehicleInterface\", \"VehicleDBWSystem\", \"NDTLocalizer\", \"Lanelet2GlobalPlanner\", \"Lanelet2MapLoader\", \"ParkingPlanner\", \"LanePlanner\", \"IntersectionOutput\", \"VoxelGridDownsampler\"}; for (const auto & node : front_nodes) { front_exe.add_node(nodes.at(node)); } for (const auto & node : rear_nodes) { rear_exe.add_node(nodes.at(node)); } for (const auto & node : planner_nodes) { planner_exe.add_node(nodes.at(node)); } for (const auto & node : fusion_nodes) { fusion_exe.add_node(nodes.at(node)); } auto euclidean_node = std::dynamic_pointer_cast<RclcppSystem::Intersection>( nodes.at(\"EuclideanClusterDetector\")); assert(euclidean_node); fusion_exe.add_callback_group( euclidean_node->get_callback_group_of_subscription(\"/RayGroundFilter\"), euclidean_node->get_node_base_interface()); other_exe.add_node(nodes.at(\"EuclideanClusterDetector\")); for (const auto & node : other_nodes) { other_exe.add_node(nodes.at(node)); } std::thread front_thread {[&]() { set_rt_properties(hotpath_prio, HOTPATH_AFFINITY); front_exe.spin(); }}; std::thread rear_thread {[&]() { set_rt_properties(hotpath_prio, HOTPATH_AFFINITY); rear_exe.spin(); }}; std::thread fusion_thread {[&]() { set_rt_properties(hotpath_prio, HOTPATH_AFFINITY); fusion_exe.spin(); }}; std::thread planner_thread {[&]() { set_rt_properties(planner_prio, PLANNER_AFFINITY); planner_exe.spin(); }}; std::thread other_thread {[&]() { other_exe.spin(); }}; front_thread.join(); rear_thread.join(); fusion_thread.join(); planner_thread.join(); rclcpp::shutdown(); } Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/autoware__default__multithreaded_8cpp/","text":"autoware_reference_system/src/ros2/executor/autoware_default_multithreaded.cpp Functions Name int main (int argc, char * argv[]) Functions Documentation function main int main( int argc, char * argv[] ) Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <memory> #include <vector> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/system/type/rclcpp_system.hpp\" #include \"autoware_reference_system/autoware_system_builder.hpp\" #include \"autoware_reference_system/system/timing/benchmark.hpp\" #include \"autoware_reference_system/system/timing/default.hpp\" int main(int argc, char * argv[]) { rclcpp::init(argc, argv); std::vector<std::shared_ptr<RclcppSystem::NodeBaseType>> nodes; if (argc == 2 && strncmp(argv[1], \"benchmark\", 9) == 0) { nodes = create_autoware_nodes<RclcppSystem, nodes::timing::BenchmarkCPUUsage>(); } else if (argc == 2 && strncmp(argv[1], \"quietbenchmark\", 14) == 0) { set_benchmark_mode(true); nodes = create_autoware_nodes<RclcppSystem, nodes::timing::BenchmarkCPUUsage>(); } else { nodes = create_autoware_nodes<RclcppSystem, nodes::timing::Default>(); } rclcpp::executors::MultiThreadedExecutor executor; for (auto & node : nodes) { executor.add_node(node); } executor.spin(); nodes.clear(); rclcpp::shutdown(); return 0; } Updated on 2022-04-30 at 21:32:33 +0000","title":"autoware_reference_system/src/ros2/executor/autoware_default_multithreaded.cpp"},{"location":"Files/autoware__default__multithreaded_8cpp/#autoware_reference_systemsrcros2executorautoware_default_multithreadedcpp","text":"","title":"autoware_reference_system/src/ros2/executor/autoware_default_multithreaded.cpp"},{"location":"Files/autoware__default__multithreaded_8cpp/#functions","text":"Name int main (int argc, char * argv[])","title":"Functions"},{"location":"Files/autoware__default__multithreaded_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/autoware__default__multithreaded_8cpp/#function-main","text":"int main( int argc, char * argv[] )","title":"function main"},{"location":"Files/autoware__default__multithreaded_8cpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <memory> #include <vector> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/system/type/rclcpp_system.hpp\" #include \"autoware_reference_system/autoware_system_builder.hpp\" #include \"autoware_reference_system/system/timing/benchmark.hpp\" #include \"autoware_reference_system/system/timing/default.hpp\" int main(int argc, char * argv[]) { rclcpp::init(argc, argv); std::vector<std::shared_ptr<RclcppSystem::NodeBaseType>> nodes; if (argc == 2 && strncmp(argv[1], \"benchmark\", 9) == 0) { nodes = create_autoware_nodes<RclcppSystem, nodes::timing::BenchmarkCPUUsage>(); } else if (argc == 2 && strncmp(argv[1], \"quietbenchmark\", 14) == 0) { set_benchmark_mode(true); nodes = create_autoware_nodes<RclcppSystem, nodes::timing::BenchmarkCPUUsage>(); } else { nodes = create_autoware_nodes<RclcppSystem, nodes::timing::Default>(); } rclcpp::executors::MultiThreadedExecutor executor; for (auto & node : nodes) { executor.add_node(node); } executor.spin(); nodes.clear(); rclcpp::shutdown(); return 0; } Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/autoware__default__prioritized_8cpp/","text":"autoware_reference_system/src/ros2/executor/autoware_default_prioritized.cpp Functions Name void set_rt_properties (int prio, const std::unordered_set< size_t > & affinity) int main (int argc, char ** argv) Functions Documentation function set_rt_properties void set_rt_properties( int prio, const std::unordered_set< size_t > & affinity ) function main int main( int argc, char ** argv ) Source code // Copyright 2021 Robert Bosch GmbH // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <memory> #include <string> #include <vector> #include <unordered_set> #include <unordered_map> #include <set> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/system/type/rclcpp_system.hpp\" #include \"autoware_reference_system/autoware_system_builder.hpp\" #include \"autoware_reference_system/system/timing/benchmark.hpp\" #include \"autoware_reference_system/system/timing/default.hpp\" #include \"autoware_reference_system/priorities.hpp\" void set_rt_properties(int prio, const std::unordered_set<size_t> & affinity) { struct sched_param sched_param = { 0 }; sched_param.sched_priority = prio; sched_setscheduler(0, SCHED_RR, &sched_param); cpu_set_t cpuset; CPU_ZERO(&cpuset); for (const auto cpu : affinity) { CPU_SET(cpu, &cpuset); } sched_setaffinity(0, sizeof(cpuset), &cpuset); } int main(int argc, char ** argv) { rclcpp::init(argc, argv); using TimeConfig = nodes::timing::Default; // uncomment for benchmarking // using TimeConfig = nodes::timing::BenchmarkCPUUsage; // set_benchmark_mode(true); auto nodes_vec = create_autoware_nodes<RclcppSystem, TimeConfig>(); using NodeMap = std::unordered_map<std::string, std::shared_ptr<RclcppSystem::NodeBaseType>>; NodeMap nodes; for (const auto & node : nodes_vec) { nodes.emplace(node->get_name(), node); std::cout << node->get_name() << \"\\n\"; } rclcpp::executors::SingleThreadedExecutor front_exe, rear_exe, fusion_exe, planner_exe, other_exe; std::set<std::string> front_nodes = {\"FrontLidarDriver\", \"PointsTransformerFront\"}; std::set<std::string> rear_nodes = {\"RearLidarDriver\", \"PointsTransformerRear\"}; std::set<std::string> fusion_nodes = {\"PointCloudFusion\", \"RayGroundFilter\", \"EuclideanClusterDetector\", \"ObjectCollisionEstimator\"}; std::set<std::string> planner_nodes = {\"BehaviorPlanner\"}; std::set<std::string> other_nodes = {\"PointCloudMap\", \"Visualizer\", \"Lanelet2Map\", \"EuclideanClusterSettings\", \"PointCloudMapLoader\", \"MPCController\", \"VehicleInterface\", \"VehicleDBWSystem\", \"NDTLocalizer\", \"Lanelet2GlobalPlanner\", \"Lanelet2MapLoader\", \"ParkingPlanner\", \"LanePlanner\", \"IntersectionOutput\", \"VoxelGridDownsampler\"}; for (const auto & node : front_nodes) { front_exe.add_node(nodes.at(node)); } for (const auto & node : rear_nodes) { rear_exe.add_node(nodes.at(node)); } for (const auto & node : fusion_nodes) { std::cout << node << \"\\n\"; fusion_exe.add_node(nodes.at(node)); } for (const auto & node : planner_nodes) { planner_exe.add_node(nodes.at(node)); } for (const auto & node : other_nodes) { other_exe.add_node(nodes.at(node)); } std::thread front_thread {[&]() { set_rt_properties(hotpath_prio, HOTPATH_AFFINITY); front_exe.spin(); }}; std::thread rear_thread {[&]() { set_rt_properties(hotpath_prio, HOTPATH_AFFINITY); rear_exe.spin(); }}; std::thread fusion_thread {[&]() { set_rt_properties(hotpath_prio, HOTPATH_AFFINITY); fusion_exe.spin(); }}; std::thread planner_thread {[&]() { set_rt_properties(planner_prio, PLANNER_AFFINITY); planner_exe.spin(); }}; std::thread other_thread {[&]() { other_exe.spin(); }}; front_thread.join(); rear_thread.join(); fusion_thread.join(); planner_thread.join(); rclcpp::shutdown(); } Updated on 2022-04-30 at 21:32:33 +0000","title":"autoware_reference_system/src/ros2/executor/autoware_default_prioritized.cpp"},{"location":"Files/autoware__default__prioritized_8cpp/#autoware_reference_systemsrcros2executorautoware_default_prioritizedcpp","text":"","title":"autoware_reference_system/src/ros2/executor/autoware_default_prioritized.cpp"},{"location":"Files/autoware__default__prioritized_8cpp/#functions","text":"Name void set_rt_properties (int prio, const std::unordered_set< size_t > & affinity) int main (int argc, char ** argv)","title":"Functions"},{"location":"Files/autoware__default__prioritized_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/autoware__default__prioritized_8cpp/#function-set_rt_properties","text":"void set_rt_properties( int prio, const std::unordered_set< size_t > & affinity )","title":"function set_rt_properties"},{"location":"Files/autoware__default__prioritized_8cpp/#function-main","text":"int main( int argc, char ** argv )","title":"function main"},{"location":"Files/autoware__default__prioritized_8cpp/#source-code","text":"// Copyright 2021 Robert Bosch GmbH // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <memory> #include <string> #include <vector> #include <unordered_set> #include <unordered_map> #include <set> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/system/type/rclcpp_system.hpp\" #include \"autoware_reference_system/autoware_system_builder.hpp\" #include \"autoware_reference_system/system/timing/benchmark.hpp\" #include \"autoware_reference_system/system/timing/default.hpp\" #include \"autoware_reference_system/priorities.hpp\" void set_rt_properties(int prio, const std::unordered_set<size_t> & affinity) { struct sched_param sched_param = { 0 }; sched_param.sched_priority = prio; sched_setscheduler(0, SCHED_RR, &sched_param); cpu_set_t cpuset; CPU_ZERO(&cpuset); for (const auto cpu : affinity) { CPU_SET(cpu, &cpuset); } sched_setaffinity(0, sizeof(cpuset), &cpuset); } int main(int argc, char ** argv) { rclcpp::init(argc, argv); using TimeConfig = nodes::timing::Default; // uncomment for benchmarking // using TimeConfig = nodes::timing::BenchmarkCPUUsage; // set_benchmark_mode(true); auto nodes_vec = create_autoware_nodes<RclcppSystem, TimeConfig>(); using NodeMap = std::unordered_map<std::string, std::shared_ptr<RclcppSystem::NodeBaseType>>; NodeMap nodes; for (const auto & node : nodes_vec) { nodes.emplace(node->get_name(), node); std::cout << node->get_name() << \"\\n\"; } rclcpp::executors::SingleThreadedExecutor front_exe, rear_exe, fusion_exe, planner_exe, other_exe; std::set<std::string> front_nodes = {\"FrontLidarDriver\", \"PointsTransformerFront\"}; std::set<std::string> rear_nodes = {\"RearLidarDriver\", \"PointsTransformerRear\"}; std::set<std::string> fusion_nodes = {\"PointCloudFusion\", \"RayGroundFilter\", \"EuclideanClusterDetector\", \"ObjectCollisionEstimator\"}; std::set<std::string> planner_nodes = {\"BehaviorPlanner\"}; std::set<std::string> other_nodes = {\"PointCloudMap\", \"Visualizer\", \"Lanelet2Map\", \"EuclideanClusterSettings\", \"PointCloudMapLoader\", \"MPCController\", \"VehicleInterface\", \"VehicleDBWSystem\", \"NDTLocalizer\", \"Lanelet2GlobalPlanner\", \"Lanelet2MapLoader\", \"ParkingPlanner\", \"LanePlanner\", \"IntersectionOutput\", \"VoxelGridDownsampler\"}; for (const auto & node : front_nodes) { front_exe.add_node(nodes.at(node)); } for (const auto & node : rear_nodes) { rear_exe.add_node(nodes.at(node)); } for (const auto & node : fusion_nodes) { std::cout << node << \"\\n\"; fusion_exe.add_node(nodes.at(node)); } for (const auto & node : planner_nodes) { planner_exe.add_node(nodes.at(node)); } for (const auto & node : other_nodes) { other_exe.add_node(nodes.at(node)); } std::thread front_thread {[&]() { set_rt_properties(hotpath_prio, HOTPATH_AFFINITY); front_exe.spin(); }}; std::thread rear_thread {[&]() { set_rt_properties(hotpath_prio, HOTPATH_AFFINITY); rear_exe.spin(); }}; std::thread fusion_thread {[&]() { set_rt_properties(hotpath_prio, HOTPATH_AFFINITY); fusion_exe.spin(); }}; std::thread planner_thread {[&]() { set_rt_properties(planner_prio, PLANNER_AFFINITY); planner_exe.spin(); }}; std::thread other_thread {[&]() { other_exe.spin(); }}; front_thread.join(); rear_thread.join(); fusion_thread.join(); planner_thread.join(); rclcpp::shutdown(); } Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/autoware__default__singlethreaded_8cpp/","text":"autoware_reference_system/src/ros2/executor/autoware_default_singlethreaded.cpp Functions Name int main (int argc, char * argv[]) Functions Documentation function main int main( int argc, char * argv[] ) Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/system/type/rclcpp_system.hpp\" #include \"autoware_reference_system/autoware_system_builder.hpp\" #include \"autoware_reference_system/system/timing/benchmark.hpp\" #include \"autoware_reference_system/system/timing/default.hpp\" int main(int argc, char * argv[]) { rclcpp::init(argc, argv); using TimeConfig = nodes::timing::Default; // uncomment for benchmarking // using TimeConfig = nodes::timing::BenchmarkCPUUsage; // set_benchmark_mode(true); auto nodes = create_autoware_nodes<RclcppSystem, TimeConfig>(); rclcpp::executors::SingleThreadedExecutor executor; for (auto & node : nodes) { executor.add_node(node); } executor.spin(); nodes.clear(); rclcpp::shutdown(); return 0; } Updated on 2022-04-30 at 21:32:33 +0000","title":"autoware_reference_system/src/ros2/executor/autoware_default_singlethreaded.cpp"},{"location":"Files/autoware__default__singlethreaded_8cpp/#autoware_reference_systemsrcros2executorautoware_default_singlethreadedcpp","text":"","title":"autoware_reference_system/src/ros2/executor/autoware_default_singlethreaded.cpp"},{"location":"Files/autoware__default__singlethreaded_8cpp/#functions","text":"Name int main (int argc, char * argv[])","title":"Functions"},{"location":"Files/autoware__default__singlethreaded_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/autoware__default__singlethreaded_8cpp/#function-main","text":"int main( int argc, char * argv[] )","title":"function main"},{"location":"Files/autoware__default__singlethreaded_8cpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/system/type/rclcpp_system.hpp\" #include \"autoware_reference_system/autoware_system_builder.hpp\" #include \"autoware_reference_system/system/timing/benchmark.hpp\" #include \"autoware_reference_system/system/timing/default.hpp\" int main(int argc, char * argv[]) { rclcpp::init(argc, argv); using TimeConfig = nodes::timing::Default; // uncomment for benchmarking // using TimeConfig = nodes::timing::BenchmarkCPUUsage; // set_benchmark_mode(true); auto nodes = create_autoware_nodes<RclcppSystem, TimeConfig>(); rclcpp::executors::SingleThreadedExecutor executor; for (auto & node : nodes) { executor.add_node(node); } executor.spin(); nodes.clear(); rclcpp::shutdown(); return 0; } Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/autoware__default__staticsinglethreaded_8cpp/","text":"autoware_reference_system/src/ros2/executor/autoware_default_staticsinglethreaded.cpp Functions Name int main (int argc, char * argv[]) Functions Documentation function main int main( int argc, char * argv[] ) Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/system/type/rclcpp_system.hpp\" #include \"autoware_reference_system/autoware_system_builder.hpp\" #include \"autoware_reference_system/system/timing/benchmark.hpp\" #include \"autoware_reference_system/system/timing/default.hpp\" int main(int argc, char * argv[]) { rclcpp::init(argc, argv); using TimeConfig = nodes::timing::Default; // uncomment for benchmarking // using TimeConfig = nodes::timing::BenchmarkCPUUsage; // set_benchmark_mode(true); auto nodes = create_autoware_nodes<RclcppSystem, TimeConfig>(); rclcpp::executors::StaticSingleThreadedExecutor executor; for (auto & node : nodes) { executor.add_node(node); } executor.spin(); nodes.clear(); rclcpp::shutdown(); return 0; } Updated on 2022-04-30 at 21:32:33 +0000","title":"autoware_reference_system/src/ros2/executor/autoware_default_staticsinglethreaded.cpp"},{"location":"Files/autoware__default__staticsinglethreaded_8cpp/#autoware_reference_systemsrcros2executorautoware_default_staticsinglethreadedcpp","text":"","title":"autoware_reference_system/src/ros2/executor/autoware_default_staticsinglethreaded.cpp"},{"location":"Files/autoware__default__staticsinglethreaded_8cpp/#functions","text":"Name int main (int argc, char * argv[])","title":"Functions"},{"location":"Files/autoware__default__staticsinglethreaded_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/autoware__default__staticsinglethreaded_8cpp/#function-main","text":"int main( int argc, char * argv[] )","title":"function main"},{"location":"Files/autoware__default__staticsinglethreaded_8cpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/system/type/rclcpp_system.hpp\" #include \"autoware_reference_system/autoware_system_builder.hpp\" #include \"autoware_reference_system/system/timing/benchmark.hpp\" #include \"autoware_reference_system/system/timing/default.hpp\" int main(int argc, char * argv[]) { rclcpp::init(argc, argv); using TimeConfig = nodes::timing::Default; // uncomment for benchmarking // using TimeConfig = nodes::timing::BenchmarkCPUUsage; // set_benchmark_mode(true); auto nodes = create_autoware_nodes<RclcppSystem, TimeConfig>(); rclcpp::executors::StaticSingleThreadedExecutor executor; for (auto & node : nodes) { executor.add_node(node); } executor.spin(); nodes.clear(); rclcpp::shutdown(); return 0; } Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/","text":"CMakeLists.txt Functions Name cmake_minimum_required (VERSION 3. 5) IN_LIST AVAILABLE_FRAMEWORKS message (FATAL_ERROR \"Unsupported framework: ${FRAMEWORK}\" ) Functions Documentation function cmake_minimum_required cmake_minimum_required( VERSION 3. 5 ) function message IN_LIST AVAILABLE_FRAMEWORKS message( FATAL_ERROR \"Unsupported framework: ${FRAMEWORK}\" ) Source code cmake_minimum_required(VERSION 3.5) project(autoware_reference_system) option(RUN_BENCHMARK \"Run the full benchmark tests\" OFF) # default to off for CI purposes option(SKIP_TRACING \"Skip the ros2_tracing (LTTng) tests\" ON) # default to off until ros-realtime/reference_system#35 is closed option(TEST_PLATFORM \"Test if running on a supported platform\" OFF) # default to off for development purposes option(ALL_RMWS \"Run tests for all available RMWs\" OFF) # default to off so only one RMW is tested by default set(FRAMEWORK ros CACHE STRING \"The framework to build for. Currently supported is ROS 2 (\\\"ros\\\").\") set(AVAILABLE_FRAMEWORKS ros) if(NOT ${FRAMEWORK} IN_LIST AVAILABLE_FRAMEWORKS) message(FATAL_ERROR \"Unsupported framework: ${FRAMEWORK}\") endif() if(NOT CMAKE_CXX_STANDARD) set(CMAKE_CXX_STANDARD 17) endif() if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\") add_compile_options(-Wall -Wextra -Wpedantic) endif() find_package(ament_cmake_auto REQUIRED) ament_auto_find_build_dependencies() # Number Cruncher Benchmark ament_auto_add_executable(number_cruncher_benchmark src/number_cruncher_benchmark.cpp) set(BENCHMARK_EXECUTABLES \"\") macro(add_benchmark_executable target src) ament_auto_add_executable(${target} ${src} src/priorities.cpp) list(APPEND BENCHMARK_EXECUTABLES ${target}) endmacro() if(${FRAMEWORK} STREQUAL ros) # Single Threaded Executor add_benchmark_executable(autoware_default_singlethreaded src/ros2/executor/autoware_default_singlethreaded.cpp) # Multi Threaded Executor add_benchmark_executable(autoware_default_multithreaded src/ros2/executor/autoware_default_multithreaded.cpp) # Static Single Threaded Executor add_benchmark_executable(autoware_default_staticsinglethreaded src/ros2/executor/autoware_default_staticsinglethreaded.cpp) # Prioritized Executor add_benchmark_executable(autoware_default_prioritized src/ros2/executor/autoware_default_prioritized.cpp) # API `add_callback_group` not available in Foxy if(NOT $ENV{ROS_DISTRO} MATCHES \"foxy\") # Multiple executors on callback-group-level with suitable prioritization of critical path. add_benchmark_executable(autoware_default_cbg src/ros2/executor/autoware_default_cbg.cpp) endif() endif() # Add new executors to test here #add_benchmark_executable(autoware_default_custom # src/ros2/executor/autoware_default_custom.cpp #) if(${BUILD_TESTING}) find_package(ament_lint_auto REQUIRED) ament_lint_auto_find_test_dependencies() if(${TEST_PLATFORM}) # check current platform ament_add_pytest_test(platform_test test/test_platform.py TIMEOUT 5 ) endif() if(${RUN_BENCHMARK}) # Test all executables by default. # Modify this variable to test only a subset of executables set(TEST_TARGETS ${BENCHMARK_EXECUTABLES}) # Add more run times here (time to run traces for) set(RUN_TIMES 5 # 10 # 30 # 60 # 120 ) # Add more trace types here # The CPU trace type is disabled since it produces too many events # see https://github.com/ros-realtime/reference-system/pull/33#issuecomment-928264240 set(TRACE_TYPES callback # uses ros2_tracing, LTTng memory # uses psrecord std # parses the log files that include the prints from std::cout # cpu # built into memory tests using psrecord ) # remove ros2_tracing trace_types if SKIP_TRACING is ON if(${SKIP_TRACING}) message(STATUS \"SKIP_TRACING is ON\") message(STATUS \"Removing callback trace tests\") list(REMOVE_ITEM TRACE_TYPES \"callback\") endif() find_package(ros_testing REQUIRED) # get available rmw implementations find_package(rmw_implementation_cmake REQUIRED) get_available_rmw_implementations(rmws_available) # only use default RMW by default if(${ALL_RMWS} MATCHES OFF) list(REVERSE rmws_available) foreach(rmw ${rmws_available}) list(LENGTH rmws_available COUNT) if(NOT COUNT MATCHES 1) # message(\"Removing ${rmw} from tests\") list(REMOVE_AT rmws_available COUNT) endif() endforeach() endif() # include cmake functions to use later on include(${CMAKE_CURRENT_SOURCE_DIR}/cmake/test_requirements.cmake) # check each executable matches the system requirements foreach(exe ${TEST_TARGETS}) test_requirements(${exe} 3) endforeach() list(JOIN rmws_available \",\" RMWS_COMMA_LIST) list(JOIN TEST_TARGETS \",\" EXES_COMMA_LIST) list(JOIN TRACE_TYPES \",\" TRACE_TYPES_COMMA_LIST) list(JOIN RUN_TIMES \",\" RUN_TIMES_COMMA_LIST) # generate traces for each executable set(TEST_NAME benchmark) include(FindPython3) find_package(Python3 REQUIRED COMPONENTS Interpreter) add_test( NAME ${TEST_NAME} COMMAND ${Python3_EXECUTABLE} ${CMAKE_INSTALL_PREFIX}/share/${PROJECT_NAME}/scripts/benchmark.py --trace_types ${TRACE_TYPES_COMMA_LIST} --rmws ${RMWS_COMMA_LIST} ${RUN_TIMES_COMMA_LIST} ${EXES_COMMA_LIST}) endif() endif() ament_auto_package( INSTALL_TO_SHARE test scripts ) Updated on 2022-04-30 at 21:32:33 +0000","title":"CMakeLists.txt"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#cmakeliststxt","text":"","title":"CMakeLists.txt"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#functions","text":"Name cmake_minimum_required (VERSION 3. 5) IN_LIST AVAILABLE_FRAMEWORKS message (FATAL_ERROR \"Unsupported framework: ${FRAMEWORK}\" )","title":"Functions"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#function-cmake_minimum_required","text":"cmake_minimum_required( VERSION 3. 5 )","title":"function cmake_minimum_required"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#function-message","text":"IN_LIST AVAILABLE_FRAMEWORKS message( FATAL_ERROR \"Unsupported framework: ${FRAMEWORK}\" )","title":"function message"},{"location":"Files/autoware__reference__system_2CMakeLists_8txt/#source-code","text":"cmake_minimum_required(VERSION 3.5) project(autoware_reference_system) option(RUN_BENCHMARK \"Run the full benchmark tests\" OFF) # default to off for CI purposes option(SKIP_TRACING \"Skip the ros2_tracing (LTTng) tests\" ON) # default to off until ros-realtime/reference_system#35 is closed option(TEST_PLATFORM \"Test if running on a supported platform\" OFF) # default to off for development purposes option(ALL_RMWS \"Run tests for all available RMWs\" OFF) # default to off so only one RMW is tested by default set(FRAMEWORK ros CACHE STRING \"The framework to build for. Currently supported is ROS 2 (\\\"ros\\\").\") set(AVAILABLE_FRAMEWORKS ros) if(NOT ${FRAMEWORK} IN_LIST AVAILABLE_FRAMEWORKS) message(FATAL_ERROR \"Unsupported framework: ${FRAMEWORK}\") endif() if(NOT CMAKE_CXX_STANDARD) set(CMAKE_CXX_STANDARD 17) endif() if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\") add_compile_options(-Wall -Wextra -Wpedantic) endif() find_package(ament_cmake_auto REQUIRED) ament_auto_find_build_dependencies() # Number Cruncher Benchmark ament_auto_add_executable(number_cruncher_benchmark src/number_cruncher_benchmark.cpp) set(BENCHMARK_EXECUTABLES \"\") macro(add_benchmark_executable target src) ament_auto_add_executable(${target} ${src} src/priorities.cpp) list(APPEND BENCHMARK_EXECUTABLES ${target}) endmacro() if(${FRAMEWORK} STREQUAL ros) # Single Threaded Executor add_benchmark_executable(autoware_default_singlethreaded src/ros2/executor/autoware_default_singlethreaded.cpp) # Multi Threaded Executor add_benchmark_executable(autoware_default_multithreaded src/ros2/executor/autoware_default_multithreaded.cpp) # Static Single Threaded Executor add_benchmark_executable(autoware_default_staticsinglethreaded src/ros2/executor/autoware_default_staticsinglethreaded.cpp) # Prioritized Executor add_benchmark_executable(autoware_default_prioritized src/ros2/executor/autoware_default_prioritized.cpp) # API `add_callback_group` not available in Foxy if(NOT $ENV{ROS_DISTRO} MATCHES \"foxy\") # Multiple executors on callback-group-level with suitable prioritization of critical path. add_benchmark_executable(autoware_default_cbg src/ros2/executor/autoware_default_cbg.cpp) endif() endif() # Add new executors to test here #add_benchmark_executable(autoware_default_custom # src/ros2/executor/autoware_default_custom.cpp #) if(${BUILD_TESTING}) find_package(ament_lint_auto REQUIRED) ament_lint_auto_find_test_dependencies() if(${TEST_PLATFORM}) # check current platform ament_add_pytest_test(platform_test test/test_platform.py TIMEOUT 5 ) endif() if(${RUN_BENCHMARK}) # Test all executables by default. # Modify this variable to test only a subset of executables set(TEST_TARGETS ${BENCHMARK_EXECUTABLES}) # Add more run times here (time to run traces for) set(RUN_TIMES 5 # 10 # 30 # 60 # 120 ) # Add more trace types here # The CPU trace type is disabled since it produces too many events # see https://github.com/ros-realtime/reference-system/pull/33#issuecomment-928264240 set(TRACE_TYPES callback # uses ros2_tracing, LTTng memory # uses psrecord std # parses the log files that include the prints from std::cout # cpu # built into memory tests using psrecord ) # remove ros2_tracing trace_types if SKIP_TRACING is ON if(${SKIP_TRACING}) message(STATUS \"SKIP_TRACING is ON\") message(STATUS \"Removing callback trace tests\") list(REMOVE_ITEM TRACE_TYPES \"callback\") endif() find_package(ros_testing REQUIRED) # get available rmw implementations find_package(rmw_implementation_cmake REQUIRED) get_available_rmw_implementations(rmws_available) # only use default RMW by default if(${ALL_RMWS} MATCHES OFF) list(REVERSE rmws_available) foreach(rmw ${rmws_available}) list(LENGTH rmws_available COUNT) if(NOT COUNT MATCHES 1) # message(\"Removing ${rmw} from tests\") list(REMOVE_AT rmws_available COUNT) endif() endforeach() endif() # include cmake functions to use later on include(${CMAKE_CURRENT_SOURCE_DIR}/cmake/test_requirements.cmake) # check each executable matches the system requirements foreach(exe ${TEST_TARGETS}) test_requirements(${exe} 3) endforeach() list(JOIN rmws_available \",\" RMWS_COMMA_LIST) list(JOIN TEST_TARGETS \",\" EXES_COMMA_LIST) list(JOIN TRACE_TYPES \",\" TRACE_TYPES_COMMA_LIST) list(JOIN RUN_TIMES \",\" RUN_TIMES_COMMA_LIST) # generate traces for each executable set(TEST_NAME benchmark) include(FindPython3) find_package(Python3 REQUIRED COMPONENTS Interpreter) add_test( NAME ${TEST_NAME} COMMAND ${Python3_EXECUTABLE} ${CMAKE_INSTALL_PREFIX}/share/${PROJECT_NAME}/scripts/benchmark.py --trace_types ${TRACE_TYPES_COMMA_LIST} --rmws ${RMWS_COMMA_LIST} ${RUN_TIMES_COMMA_LIST} ${EXES_COMMA_LIST}) endif() endif() ament_auto_package( INSTALL_TO_SHARE test scripts ) Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/autoware__reference__system_2README_8md/","text":"README.md Source code # Profiling executors using the Autoware reference system ## Introduction This tutorial incorporates [the open-sourced `autoware_reference_system`]( https://github.com/ros-realtime/reference-system) and can be used to fairly and repeatably test the performance of the various executors available within the greater ROS 2 community. The example simulates a real world scenario, [Autoware.Auto]( https://www.autoware.org/autoware-auto) and its LiDAR data pipeline, that can be used to evaluate the performance of the executor. To this end, the example comes with built-in performance measurements that make it easy to compare the performance between executor implementations in a repeatable way. ![The Autoware reference system](autoware-reference-system.png) ## Quick Start Some tools are provided in order to automate and standardize the report generation process for this `autoware_reference_system`. First, install and build the dependencies ```console (ade) $ python3 -m pip install psrecord bokeh # optional dependency: networkx (ade) $ cd workspace (ade) $ colcon build --packages-up-to autoware_reference_system The easiest way to run the benchmarks is through the ctest interface. Rebuild the package with the RUN_BENCHMARK option and run colcon test : (ade) $ colcon build --packages-select autoware_reference_system \\ --cmake-force-configure --cmake-args -DRUN_BENCHMARK=ON (ade) $ colcon test --packages-select autoware_reference_system After the tests have run, reports can be found as .html files in $ROS_HOME/benchmark_autoware_reference_system/<timestamp> ( $ROS_HOME defaults to ~/.ros ). The symlink $ROS_HOME/benchmark_autoware_reference_system/latest always points to the latest results. Detailed reports to individual test runs can be found in subdirectories of the form <duration>/<middleware>/<executable> . More details on all the supported CMake arguments can be found in the supported CMake argument section below. By default the tests uses the default ROS 2 middleware set for the system. To run the tests for all available RMWs, add the -DALL_RMWS=ON CMake argument to the colcon build step. The test duration can be configured through the RUN_TIMES variable in CMakelists.txt . A separate set of tests is created for each chosen runtime. Test Results and Reports Reports are automatically generated depending on which tests are run. The main test directory ( $ROS_HOME/benchmark_autoware_reference_system/latest by default) contains the summary reports , which aggregate metrics across all tested configurations. Below this main test directory, each tested configuration has a subdirectory of the form <duration>/<middleware>/<executable name> . This directory contains the raw trace data and additional per-test reports in .html format. Tweaking the benchmark setup To get more fine-grained control over the benchmarking process invoke the benchmark script directly. To get a summary of the available options, call (ade) $ $(ros2 pkg prefix --share autoware_reference_system)/scripts/benchmark.py --help As an example, to run all benchmarks starting with autoware_ and the autoware_default_multithreaded benchmark for 15 seconds run (ade) $ $(ros2 pkg prefix --share autoware_reference_system)/scripts/benchmark.py \\ 15 'autoware_*' The --logdir option can be used to store the measurement results and reports in a custom directory, without adding a timestamp. Note that this may overwrite existing measurement results in the same directory. Key Performance Indicators (KPIs) The performance measurement evaluates the executor using the following metrics. In general, the lowest value within each KPI is considered to be the better performance. CPU utilization In general a lower CPU utilization is better since it enables you to choose a smaller CPU or have more functionality on a larger CPU for other things. Memory utilization In general a lower memory utilization is better since it enables you to choose a smaller memory or have more space for other things Number of dropped sensor samples in transform nodes The nodes in the reference system always use the most recent sensor data (i.e., use a history depth of 1) This is a common strategy in real-world settings, as old sensor data is much less valuable than new sensor data For example an image from 30 seconds ago is much less helpful while driving down the road than an image from 0.1 second ago Fusion nodes drop messages during normal operation if the inputs publish with different frequencies In transform nodes, however, dropped messages indicate that the transform node cannot keep up with its input Number of front LiDAR samples that did not trigger an update in the Object Collision Estimator The Front and Rear LiDARs have the same publishing frequency This means Object Collision Estimator should run for every LiDAR sample Count number of executions of Object Collision Estimator and Front LiDAR and report any difference Worst-case Latency between Front LiDAR and the Object Collision Estimator For worst-case latency we want to identify obstacles in time (i.e. early enough that we can still emergency-brake). Average Latency between Front LiDAR and Object Collision Estimator For average latency we want to identify obstacles as soon as possible so we can account for the obstacle in our planning. The Behavior Planner should be as cyclical as possible The desired behavior of the Behavior Planner is to be as cyclical as possible, meaning it should be executed as close to its set frequency of 100ms as possible Measure the jitter and drift over time of the timer callback Message Types A single message type is used for the entire reference system when generating results in order to simplify the setup as well as make it more repeatable and extensible. This means only one message type from the list below is used during any given experimental run for every node in the reference system. Message4kB reference message with a fixed size of 4 kilobytes (kB) Other messages with different fixed sizes could be added here in the future. When reporting results it is important to specify the message type used during the experiment, as the message size impacts the metrics. Autoware Reference System Built from a handful of building-block node types , each one of these nodes are meant to simulate a real-world node from the Autoware.Auto project LiDAR data pipeline. Under each node type are the requirements used for this specific reference system, autoware_reference_system . Future reference systems could have slightly different requirements and still use the same building-block node types. For simplicity, every node except for the command nodes only publishes one topic, and this topic has the same name as the node that publishes it. However, each topic can be subscribed to by multiple different nodes. Also for simplicity, every node that does processing (aka number crunching) by default is configured to do that processing for the same amount of time: roughly 10 milliseconds. This processing time varies drastically depending on what platform you are on since each node does a fixed amount of actual work, not a fixed amount of time. See the Configuring Processing Time section for more details. Message Type all nodes use the same message type during any single test run default message type: Message4kB to be implemented: Message64kB Message256kB Message512kB Message1024kB Message5120kB Sensor Nodes all sensor node have a publishing rate (cycle time) of 100 milliseconds all sensor nodes publish the same message type total of 5 sensor nodes : Front LiDAR Driver Rear LiDAR Driver Point Cloud Map Visualizer Lanelet2Map Transform Nodes all transform nodes have one subscriber and one publisher all transform nodes start processing after a message is received publishes message after processing is complete total of 10 transform nodes: Front Points Transformer Rear Points Transformer Voxel Grid Downsampler Point Cloud Map Loader Ray Ground Filter Object Collision Estimator MPC Controller Parking Planner Lane Planner Fusion Nodes all fusion nodes have two subscribers and one publisher for this reference system all fusion nodes start processing after a message is received from all subscriptions all fusion nodes have a max input time difference between the first input received and last input received before publishing of 9999 seconds publishes message after processing is complete total of 5 fusion nodes: Point Cloud Fusion NDT Localizer Vehicle Interface Lanelet2 Global Planner Lanelet 2 Map Loader Cyclic Nodes for this reference system there is only 1 cyclic node this cyclic node has 6 subscribers and one publisher this cyclic node starts processing after a message is received from any single subscription publishes message after processing is complete Command Nodes all command nodes have 1 subscriber and zero publishers all command nodes prints out the final latency statistics after a message is received on the specified topic total of 2 command nodes: VehicleDBWSystem IntersectionOutput Intersection Nodes for this reference system there is only EuclideanClusterDetector this intersection node has 2 subscribers and 2 publishers publishes message after processing is complete on the correspoding publisher Configure Processing Time Many nodes in the reference system are actually performing some pseudo-work by finding prime numbers up until some maximum value. Depending on the platform, this maximum value will need to be changed so that these nodes do not take an absurd amount of time. This maximum value should be chosen on a platform-by-platform basis so that the total run time of this work takes some desired length of time. In order to make finding this maximum value a bit easier across many different platforms a simple number_cruncher_benchmark is provided that will loop over various maximum values and spit out how long each one takes to run. After running this executable on your platform you should have a good idea what maximum value you should use in your timing configuration so that each node does some measurable work for some desired amount of time. Here is an example output of the number_cruncher_benchmark run on a typical development platform (Intel 9i7): ros2 run autoware_reference_system number_cruncher_benchmark maximum_number run time 64 0.001609ms 128 0.002896ms 256 0.006614ms 512 0.035036ms 1024 0.050957ms 2048 0.092732ms 4096 0.22837ms 8192 0.566779ms 16384 1.48837ms 32768 3.64588ms 65536 9.6687ms 131072 24.1154ms 262144 62.3475ms 524288 162.762ms 1048576 429.882ms 2097152 1149.79ms Run the above command on your system, select your desired run_time and place the corresponding maximum_number in the timing configuration file for the desired nodes. Supported CMake Arguments RUN_BENCHMARK Tell CMake to build the benchmark tests that will check the reference system against its requirements before running a sweep of tests to generate trace files and reports Without the RUN_BENCHMARK variable set to ON only the standard linter tests will be run TEST_PLATFORM Test CMake to build the tests to check if the tests are being run from a supported platform or not This flag can be omitted if you would like to run the tests on a development system before running them on a supported platform The platform tests themselves can and should be improved going forward and are only some simple checks today (architecture, number of CPUs, PREEMPT_RT flag, etc.) Set this to ON to check if the current platform is supported SKIP_TRACING Set to ON to skip the ros2_tracing tests, aka the callback tests This can greatly reduce the length of time the colcon test command takes to run ALL_RMWS Set this to ON if you'd like to run tests on all available RMWs as well Otherwise use only default RMW (first one listed by CMake function get_available_rmw_implementations ) Defaults to OFF Generating Node Graph Image To generate the image shown above you can take advantage of a program called graphviz that has a command line interface (CLI) command dot . First, check out the provided .dot file to get an idea of how the dot syntax works (feel free to modify it for your use case or future reference systems ). To generate the .dot file into an .svg image, run the following command: dot -Tsvg autoware_reference_system.dot Note: you can change the generated image type to any of the supported type parameters if you would like a different filetype. Available benchmarks The package comes with a set of benchmark executables. Many of these benchmarks distinguish hotpath nodes from other nodes; these are the nodes involved in the latency KPI, starting with the front/rear LiDAR and ending in the ObjectCollisionEstimator. Within the hotpath nodes, the benchmarks further distinguish between front/rear LiDAR nodes (the LidarDriver and PointsTransformer in front/rear, respectively) and the fusion chain nodes (everything from PointCloudFusion to ObjectCollisionEstimator). Some benchmarks use real-time priorities and affinities. In this case, hotpath nodes run at priority 1 on cores 1-3; the planner nodes runs at priority 30 on core 0; and all other nodes run without real-time priority on all cores. ROS 2 benchmarks autoware_default_singlethreaded : All nodes are assigned to the same single-threaded ROS executor autoware_default_multithreaded : All nodes are assigned to the same multi-threaded ROS executor autoware_default_staticsinglethreaded : Like autoware_default_singlethreaded , but using the StaticSingleThreadedExecutor . autoware_default_prioritized : Separate executors for front LiDAR nodes, rear LiDAR nodes fusion chain nodes, behavior planner, and everything else. Uses real-time priorities. autoware_default_cbg : Like autoware_default_prioritized , but uses the callback-group executor to remove the non-hotpath subscription in EuclideanClusterDetector from the executor for fusion chain nodes. ``` Updated on 2022-04-30 at 21:32:33 +0000","title":"README.md"},{"location":"Files/autoware__reference__system_2README_8md/#readmemd","text":"","title":"README.md"},{"location":"Files/autoware__reference__system_2README_8md/#source-code","text":"# Profiling executors using the Autoware reference system ## Introduction This tutorial incorporates [the open-sourced `autoware_reference_system`]( https://github.com/ros-realtime/reference-system) and can be used to fairly and repeatably test the performance of the various executors available within the greater ROS 2 community. The example simulates a real world scenario, [Autoware.Auto]( https://www.autoware.org/autoware-auto) and its LiDAR data pipeline, that can be used to evaluate the performance of the executor. To this end, the example comes with built-in performance measurements that make it easy to compare the performance between executor implementations in a repeatable way. ![The Autoware reference system](autoware-reference-system.png) ## Quick Start Some tools are provided in order to automate and standardize the report generation process for this `autoware_reference_system`. First, install and build the dependencies ```console (ade) $ python3 -m pip install psrecord bokeh # optional dependency: networkx (ade) $ cd workspace (ade) $ colcon build --packages-up-to autoware_reference_system The easiest way to run the benchmarks is through the ctest interface. Rebuild the package with the RUN_BENCHMARK option and run colcon test : (ade) $ colcon build --packages-select autoware_reference_system \\ --cmake-force-configure --cmake-args -DRUN_BENCHMARK=ON (ade) $ colcon test --packages-select autoware_reference_system After the tests have run, reports can be found as .html files in $ROS_HOME/benchmark_autoware_reference_system/<timestamp> ( $ROS_HOME defaults to ~/.ros ). The symlink $ROS_HOME/benchmark_autoware_reference_system/latest always points to the latest results. Detailed reports to individual test runs can be found in subdirectories of the form <duration>/<middleware>/<executable> . More details on all the supported CMake arguments can be found in the supported CMake argument section below. By default the tests uses the default ROS 2 middleware set for the system. To run the tests for all available RMWs, add the -DALL_RMWS=ON CMake argument to the colcon build step. The test duration can be configured through the RUN_TIMES variable in CMakelists.txt . A separate set of tests is created for each chosen runtime.","title":"Source code"},{"location":"Files/autoware__reference__system_2README_8md/#test-results-and-reports","text":"Reports are automatically generated depending on which tests are run. The main test directory ( $ROS_HOME/benchmark_autoware_reference_system/latest by default) contains the summary reports , which aggregate metrics across all tested configurations. Below this main test directory, each tested configuration has a subdirectory of the form <duration>/<middleware>/<executable name> . This directory contains the raw trace data and additional per-test reports in .html format.","title":"Test Results and Reports"},{"location":"Files/autoware__reference__system_2README_8md/#tweaking-the-benchmark-setup","text":"To get more fine-grained control over the benchmarking process invoke the benchmark script directly. To get a summary of the available options, call (ade) $ $(ros2 pkg prefix --share autoware_reference_system)/scripts/benchmark.py --help As an example, to run all benchmarks starting with autoware_ and the autoware_default_multithreaded benchmark for 15 seconds run (ade) $ $(ros2 pkg prefix --share autoware_reference_system)/scripts/benchmark.py \\ 15 'autoware_*' The --logdir option can be used to store the measurement results and reports in a custom directory, without adding a timestamp. Note that this may overwrite existing measurement results in the same directory.","title":"Tweaking the benchmark setup"},{"location":"Files/autoware__reference__system_2README_8md/#key-performance-indicators-kpis","text":"The performance measurement evaluates the executor using the following metrics. In general, the lowest value within each KPI is considered to be the better performance. CPU utilization In general a lower CPU utilization is better since it enables you to choose a smaller CPU or have more functionality on a larger CPU for other things. Memory utilization In general a lower memory utilization is better since it enables you to choose a smaller memory or have more space for other things Number of dropped sensor samples in transform nodes The nodes in the reference system always use the most recent sensor data (i.e., use a history depth of 1) This is a common strategy in real-world settings, as old sensor data is much less valuable than new sensor data For example an image from 30 seconds ago is much less helpful while driving down the road than an image from 0.1 second ago Fusion nodes drop messages during normal operation if the inputs publish with different frequencies In transform nodes, however, dropped messages indicate that the transform node cannot keep up with its input Number of front LiDAR samples that did not trigger an update in the Object Collision Estimator The Front and Rear LiDARs have the same publishing frequency This means Object Collision Estimator should run for every LiDAR sample Count number of executions of Object Collision Estimator and Front LiDAR and report any difference Worst-case Latency between Front LiDAR and the Object Collision Estimator For worst-case latency we want to identify obstacles in time (i.e. early enough that we can still emergency-brake). Average Latency between Front LiDAR and Object Collision Estimator For average latency we want to identify obstacles as soon as possible so we can account for the obstacle in our planning. The Behavior Planner should be as cyclical as possible The desired behavior of the Behavior Planner is to be as cyclical as possible, meaning it should be executed as close to its set frequency of 100ms as possible Measure the jitter and drift over time of the timer callback","title":"Key Performance Indicators (KPIs)"},{"location":"Files/autoware__reference__system_2README_8md/#message-types","text":"A single message type is used for the entire reference system when generating results in order to simplify the setup as well as make it more repeatable and extensible. This means only one message type from the list below is used during any given experimental run for every node in the reference system. Message4kB reference message with a fixed size of 4 kilobytes (kB) Other messages with different fixed sizes could be added here in the future. When reporting results it is important to specify the message type used during the experiment, as the message size impacts the metrics.","title":"Message Types"},{"location":"Files/autoware__reference__system_2README_8md/#autoware-reference-system","text":"Built from a handful of building-block node types , each one of these nodes are meant to simulate a real-world node from the Autoware.Auto project LiDAR data pipeline. Under each node type are the requirements used for this specific reference system, autoware_reference_system . Future reference systems could have slightly different requirements and still use the same building-block node types. For simplicity, every node except for the command nodes only publishes one topic, and this topic has the same name as the node that publishes it. However, each topic can be subscribed to by multiple different nodes. Also for simplicity, every node that does processing (aka number crunching) by default is configured to do that processing for the same amount of time: roughly 10 milliseconds. This processing time varies drastically depending on what platform you are on since each node does a fixed amount of actual work, not a fixed amount of time. See the Configuring Processing Time section for more details. Message Type all nodes use the same message type during any single test run default message type: Message4kB to be implemented: Message64kB Message256kB Message512kB Message1024kB Message5120kB Sensor Nodes all sensor node have a publishing rate (cycle time) of 100 milliseconds all sensor nodes publish the same message type total of 5 sensor nodes : Front LiDAR Driver Rear LiDAR Driver Point Cloud Map Visualizer Lanelet2Map Transform Nodes all transform nodes have one subscriber and one publisher all transform nodes start processing after a message is received publishes message after processing is complete total of 10 transform nodes: Front Points Transformer Rear Points Transformer Voxel Grid Downsampler Point Cloud Map Loader Ray Ground Filter Object Collision Estimator MPC Controller Parking Planner Lane Planner Fusion Nodes all fusion nodes have two subscribers and one publisher for this reference system all fusion nodes start processing after a message is received from all subscriptions all fusion nodes have a max input time difference between the first input received and last input received before publishing of 9999 seconds publishes message after processing is complete total of 5 fusion nodes: Point Cloud Fusion NDT Localizer Vehicle Interface Lanelet2 Global Planner Lanelet 2 Map Loader Cyclic Nodes for this reference system there is only 1 cyclic node this cyclic node has 6 subscribers and one publisher this cyclic node starts processing after a message is received from any single subscription publishes message after processing is complete Command Nodes all command nodes have 1 subscriber and zero publishers all command nodes prints out the final latency statistics after a message is received on the specified topic total of 2 command nodes: VehicleDBWSystem IntersectionOutput Intersection Nodes for this reference system there is only EuclideanClusterDetector this intersection node has 2 subscribers and 2 publishers publishes message after processing is complete on the correspoding publisher","title":"Autoware Reference System"},{"location":"Files/autoware__reference__system_2README_8md/#configure-processing-time","text":"Many nodes in the reference system are actually performing some pseudo-work by finding prime numbers up until some maximum value. Depending on the platform, this maximum value will need to be changed so that these nodes do not take an absurd amount of time. This maximum value should be chosen on a platform-by-platform basis so that the total run time of this work takes some desired length of time. In order to make finding this maximum value a bit easier across many different platforms a simple number_cruncher_benchmark is provided that will loop over various maximum values and spit out how long each one takes to run. After running this executable on your platform you should have a good idea what maximum value you should use in your timing configuration so that each node does some measurable work for some desired amount of time. Here is an example output of the number_cruncher_benchmark run on a typical development platform (Intel 9i7): ros2 run autoware_reference_system number_cruncher_benchmark maximum_number run time 64 0.001609ms 128 0.002896ms 256 0.006614ms 512 0.035036ms 1024 0.050957ms 2048 0.092732ms 4096 0.22837ms 8192 0.566779ms 16384 1.48837ms 32768 3.64588ms 65536 9.6687ms 131072 24.1154ms 262144 62.3475ms 524288 162.762ms 1048576 429.882ms 2097152 1149.79ms Run the above command on your system, select your desired run_time and place the corresponding maximum_number in the timing configuration file for the desired nodes.","title":"Configure Processing Time"},{"location":"Files/autoware__reference__system_2README_8md/#supported-cmake-arguments","text":"RUN_BENCHMARK Tell CMake to build the benchmark tests that will check the reference system against its requirements before running a sweep of tests to generate trace files and reports Without the RUN_BENCHMARK variable set to ON only the standard linter tests will be run TEST_PLATFORM Test CMake to build the tests to check if the tests are being run from a supported platform or not This flag can be omitted if you would like to run the tests on a development system before running them on a supported platform The platform tests themselves can and should be improved going forward and are only some simple checks today (architecture, number of CPUs, PREEMPT_RT flag, etc.) Set this to ON to check if the current platform is supported SKIP_TRACING Set to ON to skip the ros2_tracing tests, aka the callback tests This can greatly reduce the length of time the colcon test command takes to run ALL_RMWS Set this to ON if you'd like to run tests on all available RMWs as well Otherwise use only default RMW (first one listed by CMake function get_available_rmw_implementations ) Defaults to OFF","title":"Supported CMake Arguments"},{"location":"Files/autoware__reference__system_2README_8md/#generating-node-graph-image","text":"To generate the image shown above you can take advantage of a program called graphviz that has a command line interface (CLI) command dot . First, check out the provided .dot file to get an idea of how the dot syntax works (feel free to modify it for your use case or future reference systems ). To generate the .dot file into an .svg image, run the following command: dot -Tsvg autoware_reference_system.dot Note: you can change the generated image type to any of the supported type parameters if you would like a different filetype.","title":"Generating Node Graph Image"},{"location":"Files/autoware__reference__system_2README_8md/#available-benchmarks","text":"The package comes with a set of benchmark executables. Many of these benchmarks distinguish hotpath nodes from other nodes; these are the nodes involved in the latency KPI, starting with the front/rear LiDAR and ending in the ObjectCollisionEstimator. Within the hotpath nodes, the benchmarks further distinguish between front/rear LiDAR nodes (the LidarDriver and PointsTransformer in front/rear, respectively) and the fusion chain nodes (everything from PointCloudFusion to ObjectCollisionEstimator). Some benchmarks use real-time priorities and affinities. In this case, hotpath nodes run at priority 1 on cores 1-3; the planner nodes runs at priority 30 on core 0; and all other nodes run without real-time priority on all cores.","title":"Available benchmarks"},{"location":"Files/autoware__reference__system_2README_8md/#ros-2-benchmarks","text":"autoware_default_singlethreaded : All nodes are assigned to the same single-threaded ROS executor autoware_default_multithreaded : All nodes are assigned to the same multi-threaded ROS executor autoware_default_staticsinglethreaded : Like autoware_default_singlethreaded , but using the StaticSingleThreadedExecutor . autoware_default_prioritized : Separate executors for front LiDAR nodes, rear LiDAR nodes fusion chain nodes, behavior planner, and everything else. Uses real-time priorities. autoware_default_cbg : Like autoware_default_prioritized , but uses the callback-group executor to remove the non-hotpath subscription in EuclideanClusterDetector from the executor for fusion chain nodes. ``` Updated on 2022-04-30 at 21:32:33 +0000","title":"ROS 2 benchmarks"},{"location":"Files/autoware__reference__system_2scripts_2benchmark_8py/","text":"autoware_reference_system/scripts/benchmark.py Namespaces Name benchmark Source code #!/usr/bin/env python3 # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import argparse import itertools # Generates traces for specified executables and RMWs from reference_system_py.benchmark import available_executables from reference_system_py.benchmark import generate_report, generate_summary_report, generate_trace from reference_system_py.benchmark import ROS_HOME, setup_benchmark_directory if __name__ == '__main__': parser = argparse.ArgumentParser(description='Benchmark an executor implementation.') parser.add_argument('runtimes', help='comma-separated list of runtimes (in seconds)') parser.add_argument('executables', help='comma-separated list of target executables') parser.add_argument('--trace_types', help='comma-separated list of trace types (default: memory,std)', default='memory,std') parser.add_argument('--rmws', default='rmw_cyclonedds_cpp', help='comma-separated list of rmw implementations') parser.add_argument('--logdir', default=None, help=('The directory where traces and results are placed (default: ' + f'{ROS_HOME}/benchmark_<pkg>/<timestamp>)')) parser.add_argument('--plot_only', default=False, help='Only plot existing data, do not run new experiments.', action='store_true') cmdline_args = parser.parse_args() common_args = {'pkg': 'autoware_reference_system', 'directory': cmdline_args.logdir} if common_args['directory'] is None: create_dir = (not cmdline_args.plot_only) common_args['directory'] = str(setup_benchmark_directory(pkg=common_args['pkg'], create=create_dir)) runtimes = [int(runtime) for runtime in cmdline_args.runtimes.split(',')] exe_patterns, rmws, trace_types = (lst.split(',') for lst in [cmdline_args.executables, cmdline_args.rmws, cmdline_args.trace_types]) exes = [exe for pattern in exe_patterns for exe in available_executables(pattern=pattern, pkg=common_args['pkg'])] for runtime, exe, rmw, trace_type in itertools.product(runtimes, exes, rmws, trace_types): if not cmdline_args.plot_only: generate_trace(trace_type, exe, rmw=rmw, runtime_sec=runtime, **common_args) generate_report(trace_type, exe, rmw=rmw, runtime_sec=runtime, **common_args) for trace_type, runtime in itertools.product(trace_types, runtimes): generate_summary_report(trace_type=trace_type, runtime_sec=runtime, **common_args) Updated on 2022-04-30 at 21:32:33 +0000","title":"autoware_reference_system/scripts/benchmark.py"},{"location":"Files/autoware__reference__system_2scripts_2benchmark_8py/#autoware_reference_systemscriptsbenchmarkpy","text":"","title":"autoware_reference_system/scripts/benchmark.py"},{"location":"Files/autoware__reference__system_2scripts_2benchmark_8py/#namespaces","text":"Name benchmark","title":"Namespaces"},{"location":"Files/autoware__reference__system_2scripts_2benchmark_8py/#source-code","text":"#!/usr/bin/env python3 # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import argparse import itertools # Generates traces for specified executables and RMWs from reference_system_py.benchmark import available_executables from reference_system_py.benchmark import generate_report, generate_summary_report, generate_trace from reference_system_py.benchmark import ROS_HOME, setup_benchmark_directory if __name__ == '__main__': parser = argparse.ArgumentParser(description='Benchmark an executor implementation.') parser.add_argument('runtimes', help='comma-separated list of runtimes (in seconds)') parser.add_argument('executables', help='comma-separated list of target executables') parser.add_argument('--trace_types', help='comma-separated list of trace types (default: memory,std)', default='memory,std') parser.add_argument('--rmws', default='rmw_cyclonedds_cpp', help='comma-separated list of rmw implementations') parser.add_argument('--logdir', default=None, help=('The directory where traces and results are placed (default: ' + f'{ROS_HOME}/benchmark_<pkg>/<timestamp>)')) parser.add_argument('--plot_only', default=False, help='Only plot existing data, do not run new experiments.', action='store_true') cmdline_args = parser.parse_args() common_args = {'pkg': 'autoware_reference_system', 'directory': cmdline_args.logdir} if common_args['directory'] is None: create_dir = (not cmdline_args.plot_only) common_args['directory'] = str(setup_benchmark_directory(pkg=common_args['pkg'], create=create_dir)) runtimes = [int(runtime) for runtime in cmdline_args.runtimes.split(',')] exe_patterns, rmws, trace_types = (lst.split(',') for lst in [cmdline_args.executables, cmdline_args.rmws, cmdline_args.trace_types]) exes = [exe for pattern in exe_patterns for exe in available_executables(pattern=pattern, pkg=common_args['pkg'])] for runtime, exe, rmw, trace_type in itertools.product(runtimes, exes, rmws, trace_types): if not cmdline_args.plot_only: generate_trace(trace_type, exe, rmw=rmw, runtime_sec=runtime, **common_args) generate_report(trace_type, exe, rmw=rmw, runtime_sec=runtime, **common_args) for trace_type, runtime in itertools.product(trace_types, runtimes): generate_summary_report(trace_type=trace_type, runtime_sec=runtime, **common_args) Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/autoware__system__builder_8hpp/","text":"autoware_reference_system/include/autoware_reference_system/autoware_system_builder.hpp Namespaces Name std::chrono_literals Functions Name template <typename SystemType ,typename TimingConfig > auto create_autoware_nodes () template <typename NodeType > std::shared_ptr< NodeType > get_node (const std::string & name, const std::vector< std::shared_ptr< NodeType > > & v) Functions Documentation function create_autoware_nodes template <typename SystemType , typename TimingConfig > auto create_autoware_nodes() function get_node template <typename NodeType > std::shared_ptr< NodeType > get_node( const std::string & name, const std::vector< std::shared_ptr< NodeType > > & v ) Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef AUTOWARE_REFERENCE_SYSTEM__AUTOWARE_SYSTEM_BUILDER_HPP_ #define AUTOWARE_REFERENCE_SYSTEM__AUTOWARE_SYSTEM_BUILDER_HPP_ #include <chrono> #include <memory> #include <vector> #include <string> #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/sample_management.hpp\" using namespace std::chrono_literals; // NOLINT template<typename SystemType, typename TimingConfig> auto create_autoware_nodes() ->std::vector<std::shared_ptr<typename SystemType::NodeBaseType>> { std::vector<std::shared_ptr<typename SystemType::NodeBaseType>> nodes; SampleManagementSettings::get().set_hot_path( {\"FrontLidarDriver\", \"RearLidarDriver\", \"PointsTransformerFront\", \"PointsTransformerRear\", \"PointCloudFusion\", \"RayGroundFilter\", \"EuclideanClusterDetector\", \"ObjectCollisionEstimator\"}, {\"FrontLidarDriver\", \"RearLidarDriver\"}, \"ObjectCollisionEstimator\"); // ignore the warning about designated initializers - they make the code much // more readable #pragma GCC diagnostic push #pragma GCC diagnostic ignored \"-Wpedantic\" // setup communication graph // sensor nodes nodes.emplace_back( std::make_shared<typename SystemType::Sensor>( nodes::SensorSettings{.node_name = \"FrontLidarDriver\", .topic_name = \"FrontLidarDriver\", .cycle_time = TimingConfig::FRONT_LIDAR_DRIVER})); nodes.emplace_back( std::make_shared<typename SystemType::Sensor>( nodes::SensorSettings{.node_name = \"RearLidarDriver\", .topic_name = \"RearLidarDriver\", .cycle_time = TimingConfig::REAR_LIDAR_DRIVER})); nodes.emplace_back( std::make_shared<typename SystemType::Sensor>( nodes::SensorSettings{.node_name = \"PointCloudMap\", .topic_name = \"PointCloudMap\", .cycle_time = TimingConfig::POINT_CLOUD_MAP})); nodes.emplace_back( std::make_shared<typename SystemType::Sensor>( nodes::SensorSettings{.node_name = \"Visualizer\", .topic_name = \"Visualizer\", .cycle_time = TimingConfig::VISUALIZER})); nodes.emplace_back( std::make_shared<typename SystemType::Sensor>( nodes::SensorSettings{.node_name = \"Lanelet2Map\", .topic_name = \"Lanelet2Map\", .cycle_time = TimingConfig::LANELET2MAP})); nodes.emplace_back( std::make_shared<typename SystemType::Sensor>( nodes::SensorSettings{ .node_name = \"EuclideanClusterSettings\", .topic_name = \"EuclideanClusterSettings\", .cycle_time = TimingConfig::EUCLIDEAN_CLUSTER_SETTINGS})); // transform nodes nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"PointsTransformerFront\", .input_topic = \"FrontLidarDriver\", .output_topic = \"PointsTransformerFront\", .number_crunch_limit = TimingConfig::POINTS_TRANSFORMER_FRONT})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"PointsTransformerRear\", .input_topic = \"RearLidarDriver\", .output_topic = \"PointsTransformerRear\", .number_crunch_limit = TimingConfig::POINTS_TRANSFORMER_REAR})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"VoxelGridDownsampler\", .input_topic = \"PointCloudFusion\", .output_topic = \"VoxelGridDownsampler\", .number_crunch_limit = TimingConfig::VOXEL_GRID_DOWNSAMPLER})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"PointCloudMapLoader\", .input_topic = \"PointCloudMap\", .output_topic = \"PointCloudMapLoader\", .number_crunch_limit = TimingConfig::POINT_CLOUD_MAP_LOADER})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"RayGroundFilter\", .input_topic = \"PointCloudFusion\", .output_topic = \"RayGroundFilter\", .number_crunch_limit = TimingConfig::RAY_GROUND_FILTER})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"ObjectCollisionEstimator\", .input_topic = \"EuclideanClusterDetector\", .output_topic = \"ObjectCollisionEstimator\", .number_crunch_limit = TimingConfig::OBJECT_COLLISION_ESTIMATOR})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"MPCController\", .input_topic = \"BehaviorPlanner\", .output_topic = \"MPCController\", .number_crunch_limit = TimingConfig::MPC_CONTROLLER})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"ParkingPlanner\", .input_topic = \"Lanelet2MapLoader\", .output_topic = \"ParkingPlanner\", .number_crunch_limit = TimingConfig::PARKING_PLANNER})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"LanePlanner\", .input_topic = \"Lanelet2MapLoader\", .output_topic = \"LanePlanner\", .number_crunch_limit = TimingConfig::LANE_PLANNER})); // fusion nodes nodes.emplace_back( std::make_shared<typename SystemType::Fusion>( nodes::FusionSettings{ .node_name = \"PointCloudFusion\", .input_0 = \"PointsTransformerFront\", .input_1 = \"PointsTransformerRear\", .output_topic = \"PointCloudFusion\", .number_crunch_limit = TimingConfig::POINT_CLOUD_FUSION})); nodes.emplace_back( std::make_shared<typename SystemType::Fusion>( nodes::FusionSettings{ .node_name = \"NDTLocalizer\", .input_0 = \"VoxelGridDownsampler\", .input_1 = \"PointCloudMapLoader\", .output_topic = \"NDTLocalizer\", .number_crunch_limit = TimingConfig::NDT_LOCALIZER})); nodes.emplace_back( std::make_shared<typename SystemType::Fusion>( nodes::FusionSettings{ .node_name = \"VehicleInterface\", .input_0 = \"MPCController\", .input_1 = \"BehaviorPlanner\", .output_topic = \"VehicleInterface\", .number_crunch_limit = TimingConfig::VEHICLE_INTERFACE})); nodes.emplace_back( std::make_shared<typename SystemType::Fusion>( nodes::FusionSettings{ .node_name = \"Lanelet2GlobalPlanner\", .input_0 = \"Visualizer\", .input_1 = \"NDTLocalizer\", .output_topic = \"Lanelet2GlobalPlanner\", .number_crunch_limit = TimingConfig::LANELET_2_GLOBAL_PLANNER})); nodes.emplace_back( std::make_shared<typename SystemType::Fusion>( nodes::FusionSettings{ .node_name = \"Lanelet2MapLoader\", .input_0 = \"Lanelet2Map\", .input_1 = \"Lanelet2GlobalPlanner\", .output_topic = \"Lanelet2MapLoader\", .number_crunch_limit = TimingConfig::LANELET_2_MAP_LOADER})); // cyclic node nodes.emplace_back( std::make_shared<typename SystemType::Cyclic>( nodes::CyclicSettings{ .node_name = \"BehaviorPlanner\", .inputs = {\"ObjectCollisionEstimator\", \"NDTLocalizer\", \"Lanelet2GlobalPlanner\", \"Lanelet2MapLoader\", \"ParkingPlanner\", \"LanePlanner\"}, .output_topic = \"BehaviorPlanner\", .number_crunch_limit = TimingConfig::BEHAVIOR_PLANNER, .cycle_time = TimingConfig::BEHAVIOR_PLANNER_CYCLE})); // intersection node nodes.emplace_back( std::make_shared<typename SystemType::Intersection>( nodes::IntersectionSettings{ .node_name = \"EuclideanClusterDetector\", .connections = { {.input_topic = \"RayGroundFilter\", .output_topic = \"EuclideanClusterDetector\", .number_crunch_limit = TimingConfig::EUCLIDEAN_CLUSTER_DETECTOR}, {.input_topic = \"EuclideanClusterSettings\", .output_topic = \"EuclideanIntersection\", .number_crunch_limit = TimingConfig::EUCLIDEAN_INTERSECTION}}})); // command node nodes.emplace_back( std::make_shared<typename SystemType::Command>( nodes::CommandSettings{ .node_name = \"VehicleDBWSystem\", .input_topic = \"VehicleInterface\"})); nodes.emplace_back( std::make_shared<typename SystemType::Command>( nodes::CommandSettings{.node_name = \"IntersectionOutput\", .input_topic = \"EuclideanIntersection\"})); #pragma GCC diagnostic pop return nodes; } template<typename NodeType> std::shared_ptr<NodeType> get_node( const std::string & name, const std::vector<std::shared_ptr<NodeType>> & v) { for (const auto & n : v) { if (n->get_name() == std::string(name)) { return n; } } return std::shared_ptr<NodeType>(); } #endif // AUTOWARE_REFERENCE_SYSTEM__AUTOWARE_SYSTEM_BUILDER_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"autoware_reference_system/include/autoware_reference_system/autoware_system_builder.hpp"},{"location":"Files/autoware__system__builder_8hpp/#autoware_reference_systemincludeautoware_reference_systemautoware_system_builderhpp","text":"","title":"autoware_reference_system/include/autoware_reference_system/autoware_system_builder.hpp"},{"location":"Files/autoware__system__builder_8hpp/#namespaces","text":"Name std::chrono_literals","title":"Namespaces"},{"location":"Files/autoware__system__builder_8hpp/#functions","text":"Name template <typename SystemType ,typename TimingConfig > auto create_autoware_nodes () template <typename NodeType > std::shared_ptr< NodeType > get_node (const std::string & name, const std::vector< std::shared_ptr< NodeType > > & v)","title":"Functions"},{"location":"Files/autoware__system__builder_8hpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/autoware__system__builder_8hpp/#function-create_autoware_nodes","text":"template <typename SystemType , typename TimingConfig > auto create_autoware_nodes()","title":"function create_autoware_nodes"},{"location":"Files/autoware__system__builder_8hpp/#function-get_node","text":"template <typename NodeType > std::shared_ptr< NodeType > get_node( const std::string & name, const std::vector< std::shared_ptr< NodeType > > & v )","title":"function get_node"},{"location":"Files/autoware__system__builder_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef AUTOWARE_REFERENCE_SYSTEM__AUTOWARE_SYSTEM_BUILDER_HPP_ #define AUTOWARE_REFERENCE_SYSTEM__AUTOWARE_SYSTEM_BUILDER_HPP_ #include <chrono> #include <memory> #include <vector> #include <string> #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/sample_management.hpp\" using namespace std::chrono_literals; // NOLINT template<typename SystemType, typename TimingConfig> auto create_autoware_nodes() ->std::vector<std::shared_ptr<typename SystemType::NodeBaseType>> { std::vector<std::shared_ptr<typename SystemType::NodeBaseType>> nodes; SampleManagementSettings::get().set_hot_path( {\"FrontLidarDriver\", \"RearLidarDriver\", \"PointsTransformerFront\", \"PointsTransformerRear\", \"PointCloudFusion\", \"RayGroundFilter\", \"EuclideanClusterDetector\", \"ObjectCollisionEstimator\"}, {\"FrontLidarDriver\", \"RearLidarDriver\"}, \"ObjectCollisionEstimator\"); // ignore the warning about designated initializers - they make the code much // more readable #pragma GCC diagnostic push #pragma GCC diagnostic ignored \"-Wpedantic\" // setup communication graph // sensor nodes nodes.emplace_back( std::make_shared<typename SystemType::Sensor>( nodes::SensorSettings{.node_name = \"FrontLidarDriver\", .topic_name = \"FrontLidarDriver\", .cycle_time = TimingConfig::FRONT_LIDAR_DRIVER})); nodes.emplace_back( std::make_shared<typename SystemType::Sensor>( nodes::SensorSettings{.node_name = \"RearLidarDriver\", .topic_name = \"RearLidarDriver\", .cycle_time = TimingConfig::REAR_LIDAR_DRIVER})); nodes.emplace_back( std::make_shared<typename SystemType::Sensor>( nodes::SensorSettings{.node_name = \"PointCloudMap\", .topic_name = \"PointCloudMap\", .cycle_time = TimingConfig::POINT_CLOUD_MAP})); nodes.emplace_back( std::make_shared<typename SystemType::Sensor>( nodes::SensorSettings{.node_name = \"Visualizer\", .topic_name = \"Visualizer\", .cycle_time = TimingConfig::VISUALIZER})); nodes.emplace_back( std::make_shared<typename SystemType::Sensor>( nodes::SensorSettings{.node_name = \"Lanelet2Map\", .topic_name = \"Lanelet2Map\", .cycle_time = TimingConfig::LANELET2MAP})); nodes.emplace_back( std::make_shared<typename SystemType::Sensor>( nodes::SensorSettings{ .node_name = \"EuclideanClusterSettings\", .topic_name = \"EuclideanClusterSettings\", .cycle_time = TimingConfig::EUCLIDEAN_CLUSTER_SETTINGS})); // transform nodes nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"PointsTransformerFront\", .input_topic = \"FrontLidarDriver\", .output_topic = \"PointsTransformerFront\", .number_crunch_limit = TimingConfig::POINTS_TRANSFORMER_FRONT})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"PointsTransformerRear\", .input_topic = \"RearLidarDriver\", .output_topic = \"PointsTransformerRear\", .number_crunch_limit = TimingConfig::POINTS_TRANSFORMER_REAR})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"VoxelGridDownsampler\", .input_topic = \"PointCloudFusion\", .output_topic = \"VoxelGridDownsampler\", .number_crunch_limit = TimingConfig::VOXEL_GRID_DOWNSAMPLER})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"PointCloudMapLoader\", .input_topic = \"PointCloudMap\", .output_topic = \"PointCloudMapLoader\", .number_crunch_limit = TimingConfig::POINT_CLOUD_MAP_LOADER})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"RayGroundFilter\", .input_topic = \"PointCloudFusion\", .output_topic = \"RayGroundFilter\", .number_crunch_limit = TimingConfig::RAY_GROUND_FILTER})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"ObjectCollisionEstimator\", .input_topic = \"EuclideanClusterDetector\", .output_topic = \"ObjectCollisionEstimator\", .number_crunch_limit = TimingConfig::OBJECT_COLLISION_ESTIMATOR})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"MPCController\", .input_topic = \"BehaviorPlanner\", .output_topic = \"MPCController\", .number_crunch_limit = TimingConfig::MPC_CONTROLLER})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"ParkingPlanner\", .input_topic = \"Lanelet2MapLoader\", .output_topic = \"ParkingPlanner\", .number_crunch_limit = TimingConfig::PARKING_PLANNER})); nodes.emplace_back( std::make_shared<typename SystemType::Transform>( nodes::TransformSettings{ .node_name = \"LanePlanner\", .input_topic = \"Lanelet2MapLoader\", .output_topic = \"LanePlanner\", .number_crunch_limit = TimingConfig::LANE_PLANNER})); // fusion nodes nodes.emplace_back( std::make_shared<typename SystemType::Fusion>( nodes::FusionSettings{ .node_name = \"PointCloudFusion\", .input_0 = \"PointsTransformerFront\", .input_1 = \"PointsTransformerRear\", .output_topic = \"PointCloudFusion\", .number_crunch_limit = TimingConfig::POINT_CLOUD_FUSION})); nodes.emplace_back( std::make_shared<typename SystemType::Fusion>( nodes::FusionSettings{ .node_name = \"NDTLocalizer\", .input_0 = \"VoxelGridDownsampler\", .input_1 = \"PointCloudMapLoader\", .output_topic = \"NDTLocalizer\", .number_crunch_limit = TimingConfig::NDT_LOCALIZER})); nodes.emplace_back( std::make_shared<typename SystemType::Fusion>( nodes::FusionSettings{ .node_name = \"VehicleInterface\", .input_0 = \"MPCController\", .input_1 = \"BehaviorPlanner\", .output_topic = \"VehicleInterface\", .number_crunch_limit = TimingConfig::VEHICLE_INTERFACE})); nodes.emplace_back( std::make_shared<typename SystemType::Fusion>( nodes::FusionSettings{ .node_name = \"Lanelet2GlobalPlanner\", .input_0 = \"Visualizer\", .input_1 = \"NDTLocalizer\", .output_topic = \"Lanelet2GlobalPlanner\", .number_crunch_limit = TimingConfig::LANELET_2_GLOBAL_PLANNER})); nodes.emplace_back( std::make_shared<typename SystemType::Fusion>( nodes::FusionSettings{ .node_name = \"Lanelet2MapLoader\", .input_0 = \"Lanelet2Map\", .input_1 = \"Lanelet2GlobalPlanner\", .output_topic = \"Lanelet2MapLoader\", .number_crunch_limit = TimingConfig::LANELET_2_MAP_LOADER})); // cyclic node nodes.emplace_back( std::make_shared<typename SystemType::Cyclic>( nodes::CyclicSettings{ .node_name = \"BehaviorPlanner\", .inputs = {\"ObjectCollisionEstimator\", \"NDTLocalizer\", \"Lanelet2GlobalPlanner\", \"Lanelet2MapLoader\", \"ParkingPlanner\", \"LanePlanner\"}, .output_topic = \"BehaviorPlanner\", .number_crunch_limit = TimingConfig::BEHAVIOR_PLANNER, .cycle_time = TimingConfig::BEHAVIOR_PLANNER_CYCLE})); // intersection node nodes.emplace_back( std::make_shared<typename SystemType::Intersection>( nodes::IntersectionSettings{ .node_name = \"EuclideanClusterDetector\", .connections = { {.input_topic = \"RayGroundFilter\", .output_topic = \"EuclideanClusterDetector\", .number_crunch_limit = TimingConfig::EUCLIDEAN_CLUSTER_DETECTOR}, {.input_topic = \"EuclideanClusterSettings\", .output_topic = \"EuclideanIntersection\", .number_crunch_limit = TimingConfig::EUCLIDEAN_INTERSECTION}}})); // command node nodes.emplace_back( std::make_shared<typename SystemType::Command>( nodes::CommandSettings{ .node_name = \"VehicleDBWSystem\", .input_topic = \"VehicleInterface\"})); nodes.emplace_back( std::make_shared<typename SystemType::Command>( nodes::CommandSettings{.node_name = \"IntersectionOutput\", .input_topic = \"EuclideanIntersection\"})); #pragma GCC diagnostic pop return nodes; } template<typename NodeType> std::shared_ptr<NodeType> get_node( const std::string & name, const std::vector<std::shared_ptr<NodeType>> & v) { for (const auto & n : v) { if (n->get_name() == std::string(name)) { return n; } } return std::shared_ptr<NodeType>(); } #endif // AUTOWARE_REFERENCE_SYSTEM__AUTOWARE_SYSTEM_BUILDER_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/benchmark_8hpp/","text":"autoware_reference_system/include/autoware_reference_system/system/timing/benchmark.hpp Namespaces Name nodes nodes::timing Classes Name struct nodes::timing::BenchmarkThroughput struct nodes::timing::BenchmarkCPUUsage Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef AUTOWARE_REFERENCE_SYSTEM__SYSTEM__TIMING__BENCHMARK_HPP_ #define AUTOWARE_REFERENCE_SYSTEM__SYSTEM__TIMING__BENCHMARK_HPP_ #include <chrono> #include \"default.hpp\" namespace nodes { namespace timing { struct BenchmarkThroughput { using time_t = std::chrono::nanoseconds; using milliseconds = std::chrono::milliseconds; using seconds = std::chrono::seconds; // sensors static constexpr time_t FRONT_LIDAR_DRIVER = milliseconds(0); static constexpr time_t REAR_LIDAR_DRIVER = milliseconds(0); static constexpr time_t POINT_CLOUD_MAP = milliseconds(0); static constexpr time_t VISUALIZER = milliseconds(0); static constexpr time_t LANELET2MAP = milliseconds(0); static constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS = milliseconds(0); // the following values are used as the number_cruncher_limit // to search for primes up to starting at 3 // for your platform, run the `number_cruncher_benchmark` executable // to figure out what values to place here corresponding to the run_time // you would like to run each node for // processing static constexpr uint64_t POINTS_TRANSFORMER_FRONT = 0; static constexpr uint64_t POINTS_TRANSFORMER_REAR = 0; static constexpr uint64_t VOXEL_GRID_DOWNSAMPLER = 0; static constexpr uint64_t POINT_CLOUD_MAP_LOADER = 0; static constexpr uint64_t RAY_GROUND_FILTER = 0; static constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR = 0; static constexpr uint64_t EUCLIDEAN_INTERSECTION = 0; static constexpr uint64_t OBJECT_COLLISION_ESTIMATOR = 0; static constexpr uint64_t MPC_CONTROLLER = 0; static constexpr uint64_t PARKING_PLANNER = 0; static constexpr uint64_t LANE_PLANNER = 0; // fusion static constexpr uint64_t POINT_CLOUD_FUSION = 0; static constexpr uint64_t NDT_LOCALIZER = 0; static constexpr uint64_t VEHICLE_INTERFACE = 0; static constexpr uint64_t LANELET_2_GLOBAL_PLANNER = 0; static constexpr uint64_t LANELET_2_MAP_LOADER = 0; // cyclic static constexpr uint64_t BEHAVIOR_PLANNER = 0; static constexpr time_t BEHAVIOR_PLANNER_CYCLE = milliseconds(0); }; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::FRONT_LIDAR_DRIVER; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::REAR_LIDAR_DRIVER; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::POINT_CLOUD_MAP; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::VISUALIZER; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::LANELET2MAP; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::EUCLIDEAN_CLUSTER_SETTINGS; constexpr uint64_t BenchmarkThroughput::POINTS_TRANSFORMER_FRONT; constexpr uint64_t BenchmarkThroughput::POINTS_TRANSFORMER_REAR; constexpr uint64_t BenchmarkThroughput::VOXEL_GRID_DOWNSAMPLER; constexpr uint64_t BenchmarkThroughput::POINT_CLOUD_MAP_LOADER; constexpr uint64_t BenchmarkThroughput::RAY_GROUND_FILTER; constexpr uint64_t BenchmarkThroughput::EUCLIDEAN_CLUSTER_DETECTOR; constexpr uint64_t BenchmarkThroughput::EUCLIDEAN_INTERSECTION; constexpr uint64_t BenchmarkThroughput::OBJECT_COLLISION_ESTIMATOR; constexpr uint64_t BenchmarkThroughput::MPC_CONTROLLER; constexpr uint64_t BenchmarkThroughput::PARKING_PLANNER; constexpr uint64_t BenchmarkThroughput::LANE_PLANNER; constexpr uint64_t BenchmarkThroughput::POINT_CLOUD_FUSION; constexpr uint64_t BenchmarkThroughput::NDT_LOCALIZER; constexpr uint64_t BenchmarkThroughput::VEHICLE_INTERFACE; constexpr uint64_t BenchmarkThroughput::LANELET_2_GLOBAL_PLANNER; constexpr uint64_t BenchmarkThroughput::LANELET_2_MAP_LOADER; constexpr uint64_t BenchmarkThroughput::BEHAVIOR_PLANNER; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::BEHAVIOR_PLANNER_CYCLE; struct BenchmarkCPUUsage { using time_t = std::chrono::nanoseconds; using milliseconds = std::chrono::milliseconds; using seconds = std::chrono::seconds; // sensors static constexpr time_t FRONT_LIDAR_DRIVER = Default::FRONT_LIDAR_DRIVER; static constexpr time_t REAR_LIDAR_DRIVER = Default::REAR_LIDAR_DRIVER; static constexpr time_t POINT_CLOUD_MAP = Default::POINT_CLOUD_MAP; static constexpr time_t VISUALIZER = Default::VISUALIZER; static constexpr time_t LANELET2MAP = Default::LANELET2MAP; static constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS = Default::EUCLIDEAN_CLUSTER_SETTINGS; // the following values are used as the number_cruncher_limit // to search for primes up to starting at 3 // for your platform, run the `number_cruncher_benchmark` executable // to figure out what values to place here corresponding to the run_time // you would like to run each node for // processing static constexpr uint64_t POINTS_TRANSFORMER_FRONT = 0; static constexpr uint64_t POINTS_TRANSFORMER_REAR = 0; static constexpr uint64_t VOXEL_GRID_DOWNSAMPLER = 0; static constexpr uint64_t POINT_CLOUD_MAP_LOADER = 0; static constexpr uint64_t RAY_GROUND_FILTER = 0; static constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR = 0; static constexpr uint64_t EUCLIDEAN_INTERSECTION = 0; static constexpr uint64_t OBJECT_COLLISION_ESTIMATOR = 0; static constexpr uint64_t MPC_CONTROLLER = 0; static constexpr uint64_t PARKING_PLANNER = 0; static constexpr uint64_t LANE_PLANNER = 0; // fusion static constexpr uint64_t POINT_CLOUD_FUSION = 0; static constexpr uint64_t NDT_LOCALIZER = 0; static constexpr uint64_t VEHICLE_INTERFACE = 0; static constexpr uint64_t LANELET_2_GLOBAL_PLANNER = 0; static constexpr uint64_t LANELET_2_MAP_LOADER = 0; // cyclic static constexpr uint64_t BEHAVIOR_PLANNER = 0; static constexpr time_t BEHAVIOR_PLANNER_CYCLE = Default::BEHAVIOR_PLANNER_CYCLE; }; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::FRONT_LIDAR_DRIVER; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::REAR_LIDAR_DRIVER; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::POINT_CLOUD_MAP; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::VISUALIZER; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::LANELET2MAP; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::EUCLIDEAN_CLUSTER_SETTINGS; constexpr uint64_t BenchmarkCPUUsage::POINTS_TRANSFORMER_FRONT; constexpr uint64_t BenchmarkCPUUsage::POINTS_TRANSFORMER_REAR; constexpr uint64_t BenchmarkCPUUsage::VOXEL_GRID_DOWNSAMPLER; constexpr uint64_t BenchmarkCPUUsage::POINT_CLOUD_MAP_LOADER; constexpr uint64_t BenchmarkCPUUsage::RAY_GROUND_FILTER; constexpr uint64_t BenchmarkCPUUsage::EUCLIDEAN_CLUSTER_DETECTOR; constexpr uint64_t BenchmarkCPUUsage::EUCLIDEAN_INTERSECTION; constexpr uint64_t BenchmarkCPUUsage::OBJECT_COLLISION_ESTIMATOR; constexpr uint64_t BenchmarkCPUUsage::MPC_CONTROLLER; constexpr uint64_t BenchmarkCPUUsage::PARKING_PLANNER; constexpr uint64_t BenchmarkCPUUsage::LANE_PLANNER; constexpr uint64_t BenchmarkCPUUsage::POINT_CLOUD_FUSION; constexpr uint64_t BenchmarkCPUUsage::NDT_LOCALIZER; constexpr uint64_t BenchmarkCPUUsage::VEHICLE_INTERFACE; constexpr uint64_t BenchmarkCPUUsage::LANELET_2_GLOBAL_PLANNER; constexpr uint64_t BenchmarkCPUUsage::LANELET_2_MAP_LOADER; constexpr uint64_t BenchmarkCPUUsage::BEHAVIOR_PLANNER; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::BEHAVIOR_PLANNER_CYCLE; } // namespace timing } // namespace nodes #endif // AUTOWARE_REFERENCE_SYSTEM__SYSTEM__TIMING__BENCHMARK_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"autoware_reference_system/include/autoware_reference_system/system/timing/benchmark.hpp"},{"location":"Files/benchmark_8hpp/#autoware_reference_systemincludeautoware_reference_systemsystemtimingbenchmarkhpp","text":"","title":"autoware_reference_system/include/autoware_reference_system/system/timing/benchmark.hpp"},{"location":"Files/benchmark_8hpp/#namespaces","text":"Name nodes nodes::timing","title":"Namespaces"},{"location":"Files/benchmark_8hpp/#classes","text":"Name struct nodes::timing::BenchmarkThroughput struct nodes::timing::BenchmarkCPUUsage","title":"Classes"},{"location":"Files/benchmark_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef AUTOWARE_REFERENCE_SYSTEM__SYSTEM__TIMING__BENCHMARK_HPP_ #define AUTOWARE_REFERENCE_SYSTEM__SYSTEM__TIMING__BENCHMARK_HPP_ #include <chrono> #include \"default.hpp\" namespace nodes { namespace timing { struct BenchmarkThroughput { using time_t = std::chrono::nanoseconds; using milliseconds = std::chrono::milliseconds; using seconds = std::chrono::seconds; // sensors static constexpr time_t FRONT_LIDAR_DRIVER = milliseconds(0); static constexpr time_t REAR_LIDAR_DRIVER = milliseconds(0); static constexpr time_t POINT_CLOUD_MAP = milliseconds(0); static constexpr time_t VISUALIZER = milliseconds(0); static constexpr time_t LANELET2MAP = milliseconds(0); static constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS = milliseconds(0); // the following values are used as the number_cruncher_limit // to search for primes up to starting at 3 // for your platform, run the `number_cruncher_benchmark` executable // to figure out what values to place here corresponding to the run_time // you would like to run each node for // processing static constexpr uint64_t POINTS_TRANSFORMER_FRONT = 0; static constexpr uint64_t POINTS_TRANSFORMER_REAR = 0; static constexpr uint64_t VOXEL_GRID_DOWNSAMPLER = 0; static constexpr uint64_t POINT_CLOUD_MAP_LOADER = 0; static constexpr uint64_t RAY_GROUND_FILTER = 0; static constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR = 0; static constexpr uint64_t EUCLIDEAN_INTERSECTION = 0; static constexpr uint64_t OBJECT_COLLISION_ESTIMATOR = 0; static constexpr uint64_t MPC_CONTROLLER = 0; static constexpr uint64_t PARKING_PLANNER = 0; static constexpr uint64_t LANE_PLANNER = 0; // fusion static constexpr uint64_t POINT_CLOUD_FUSION = 0; static constexpr uint64_t NDT_LOCALIZER = 0; static constexpr uint64_t VEHICLE_INTERFACE = 0; static constexpr uint64_t LANELET_2_GLOBAL_PLANNER = 0; static constexpr uint64_t LANELET_2_MAP_LOADER = 0; // cyclic static constexpr uint64_t BEHAVIOR_PLANNER = 0; static constexpr time_t BEHAVIOR_PLANNER_CYCLE = milliseconds(0); }; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::FRONT_LIDAR_DRIVER; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::REAR_LIDAR_DRIVER; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::POINT_CLOUD_MAP; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::VISUALIZER; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::LANELET2MAP; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::EUCLIDEAN_CLUSTER_SETTINGS; constexpr uint64_t BenchmarkThroughput::POINTS_TRANSFORMER_FRONT; constexpr uint64_t BenchmarkThroughput::POINTS_TRANSFORMER_REAR; constexpr uint64_t BenchmarkThroughput::VOXEL_GRID_DOWNSAMPLER; constexpr uint64_t BenchmarkThroughput::POINT_CLOUD_MAP_LOADER; constexpr uint64_t BenchmarkThroughput::RAY_GROUND_FILTER; constexpr uint64_t BenchmarkThroughput::EUCLIDEAN_CLUSTER_DETECTOR; constexpr uint64_t BenchmarkThroughput::EUCLIDEAN_INTERSECTION; constexpr uint64_t BenchmarkThroughput::OBJECT_COLLISION_ESTIMATOR; constexpr uint64_t BenchmarkThroughput::MPC_CONTROLLER; constexpr uint64_t BenchmarkThroughput::PARKING_PLANNER; constexpr uint64_t BenchmarkThroughput::LANE_PLANNER; constexpr uint64_t BenchmarkThroughput::POINT_CLOUD_FUSION; constexpr uint64_t BenchmarkThroughput::NDT_LOCALIZER; constexpr uint64_t BenchmarkThroughput::VEHICLE_INTERFACE; constexpr uint64_t BenchmarkThroughput::LANELET_2_GLOBAL_PLANNER; constexpr uint64_t BenchmarkThroughput::LANELET_2_MAP_LOADER; constexpr uint64_t BenchmarkThroughput::BEHAVIOR_PLANNER; constexpr BenchmarkThroughput::time_t BenchmarkThroughput::BEHAVIOR_PLANNER_CYCLE; struct BenchmarkCPUUsage { using time_t = std::chrono::nanoseconds; using milliseconds = std::chrono::milliseconds; using seconds = std::chrono::seconds; // sensors static constexpr time_t FRONT_LIDAR_DRIVER = Default::FRONT_LIDAR_DRIVER; static constexpr time_t REAR_LIDAR_DRIVER = Default::REAR_LIDAR_DRIVER; static constexpr time_t POINT_CLOUD_MAP = Default::POINT_CLOUD_MAP; static constexpr time_t VISUALIZER = Default::VISUALIZER; static constexpr time_t LANELET2MAP = Default::LANELET2MAP; static constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS = Default::EUCLIDEAN_CLUSTER_SETTINGS; // the following values are used as the number_cruncher_limit // to search for primes up to starting at 3 // for your platform, run the `number_cruncher_benchmark` executable // to figure out what values to place here corresponding to the run_time // you would like to run each node for // processing static constexpr uint64_t POINTS_TRANSFORMER_FRONT = 0; static constexpr uint64_t POINTS_TRANSFORMER_REAR = 0; static constexpr uint64_t VOXEL_GRID_DOWNSAMPLER = 0; static constexpr uint64_t POINT_CLOUD_MAP_LOADER = 0; static constexpr uint64_t RAY_GROUND_FILTER = 0; static constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR = 0; static constexpr uint64_t EUCLIDEAN_INTERSECTION = 0; static constexpr uint64_t OBJECT_COLLISION_ESTIMATOR = 0; static constexpr uint64_t MPC_CONTROLLER = 0; static constexpr uint64_t PARKING_PLANNER = 0; static constexpr uint64_t LANE_PLANNER = 0; // fusion static constexpr uint64_t POINT_CLOUD_FUSION = 0; static constexpr uint64_t NDT_LOCALIZER = 0; static constexpr uint64_t VEHICLE_INTERFACE = 0; static constexpr uint64_t LANELET_2_GLOBAL_PLANNER = 0; static constexpr uint64_t LANELET_2_MAP_LOADER = 0; // cyclic static constexpr uint64_t BEHAVIOR_PLANNER = 0; static constexpr time_t BEHAVIOR_PLANNER_CYCLE = Default::BEHAVIOR_PLANNER_CYCLE; }; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::FRONT_LIDAR_DRIVER; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::REAR_LIDAR_DRIVER; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::POINT_CLOUD_MAP; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::VISUALIZER; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::LANELET2MAP; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::EUCLIDEAN_CLUSTER_SETTINGS; constexpr uint64_t BenchmarkCPUUsage::POINTS_TRANSFORMER_FRONT; constexpr uint64_t BenchmarkCPUUsage::POINTS_TRANSFORMER_REAR; constexpr uint64_t BenchmarkCPUUsage::VOXEL_GRID_DOWNSAMPLER; constexpr uint64_t BenchmarkCPUUsage::POINT_CLOUD_MAP_LOADER; constexpr uint64_t BenchmarkCPUUsage::RAY_GROUND_FILTER; constexpr uint64_t BenchmarkCPUUsage::EUCLIDEAN_CLUSTER_DETECTOR; constexpr uint64_t BenchmarkCPUUsage::EUCLIDEAN_INTERSECTION; constexpr uint64_t BenchmarkCPUUsage::OBJECT_COLLISION_ESTIMATOR; constexpr uint64_t BenchmarkCPUUsage::MPC_CONTROLLER; constexpr uint64_t BenchmarkCPUUsage::PARKING_PLANNER; constexpr uint64_t BenchmarkCPUUsage::LANE_PLANNER; constexpr uint64_t BenchmarkCPUUsage::POINT_CLOUD_FUSION; constexpr uint64_t BenchmarkCPUUsage::NDT_LOCALIZER; constexpr uint64_t BenchmarkCPUUsage::VEHICLE_INTERFACE; constexpr uint64_t BenchmarkCPUUsage::LANELET_2_GLOBAL_PLANNER; constexpr uint64_t BenchmarkCPUUsage::LANELET_2_MAP_LOADER; constexpr uint64_t BenchmarkCPUUsage::BEHAVIOR_PLANNER; constexpr BenchmarkCPUUsage::time_t BenchmarkCPUUsage::BEHAVIOR_PLANNER_CYCLE; } // namespace timing } // namespace nodes #endif // AUTOWARE_REFERENCE_SYSTEM__SYSTEM__TIMING__BENCHMARK_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/callback__duration_8py/","text":"reference_system/reference_system_py/callback_duration.py Namespaces Name reference_system_py reference_system_py::callback_duration Source code # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import random from bokeh.models import ColumnDataSource from bokeh.models import DatetimeTickFormatter from bokeh.models import Legend from bokeh.models.tools import HoverTool from bokeh.plotting import figure import numpy as np import pandas as pd def summary(data_model, size): callback_symbols = data_model.get_callback_symbols() colours = [] # Adds random colours for each callback colour_i = 0 earliest_date = None fname = '' for obj, symbol in callback_symbols.items(): duration_df = data_model.get_callback_durations(obj) thedate = duration_df.loc[:, 'timestamp'].iloc[0] if earliest_date is None or thedate <= earliest_date: earliest_date = thedate starttime = earliest_date.strftime('%Y-%m-%d %H:%M') duration = figure( title='Callback Durations Summary', x_axis_label=f'start ({starttime})', y_axis_label='duration (ms)', plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) legend_it = [] for obj, symbol in callback_symbols.items(): # Filter out internal subscriptions and get node information owner_info = data_model.get_callback_owner_info(obj) if not owner_info or '/parameter_events' in owner_info: continue if(len(colours) <= colour_i): colours.append('#%06X' % random.randint(0, 256**3-1)) duration_df = data_model.get_callback_durations(obj) source = ColumnDataSource(duration_df) duration.title.align = 'center' substr = 'node: ' index = str.find(owner_info, substr) if index >= 0: index += len(substr) fname = 'node_' + owner_info[index:(str.find(owner_info, ','))] substr = 'topic: /' index = str.find(owner_info, substr) if index >= 0: index += len(substr) fname += '_topic_' + owner_info[index:] c = duration.line( x='timestamp', y='duration', line_width=2, source=source, line_color=colours[colour_i], alpha=0.8, muted_color=colours[colour_i], muted_alpha=0.2, name=fname ) legend_it.append((fname, [c])) colour_i += 1 # duration.legend.label_text_font_size = '11px' duration.xaxis[0].formatter = DatetimeTickFormatter(seconds=['%Ss']) legend = Legend( items=legend_it, label_text_font_size='8pt', label_standoff=1, padding=1, spacing=1 ) legend.click_policy = 'hide' duration.add_layout(legend, 'right') # add hover tool hover = HoverTool() hover.tooltips = [ ('Callback', '$name'), ('Duration', '@duration{0.000}' + 's'), ('Timestamp', '@timestamp{%S.%3Ns}') ] hover.formatters = { '@timestamp': 'datetime' } duration.add_tools(hover) return duration # show(duration) # export_png(duration, filename=path + 'callback_duration_summary.png') def individual(data_model, size): # returns a list of individual plots for each callback symbol callback_symbols = data_model.get_callback_symbols() colours = [] # Adds random colours for each callback colour_i = 0 fname = '' figs = [] for obj, symbol in callback_symbols.items(): owner_info = data_model.get_callback_owner_info(obj) if owner_info is None: owner_info = '[unknown]' # Filter out internal subscriptions if '/parameter_events' in owner_info: continue substr = 'node: ' index = str.find(owner_info, substr) if index >= 0: index += len(substr) fname = 'node_' + owner_info[index:(str.find(owner_info, ','))] substr = 'topic: /' index = str.find(owner_info, substr) if index >= 0: index += len(substr) fname += '_topic_' + owner_info[index:] # Duration duration_df = data_model.get_callback_durations(obj) starttime = duration_df.loc[:, 'timestamp'].iloc[0].strftime('%Y-%m-%d %H:%M') source = ColumnDataSource(duration_df) duration = figure( title='Callback Duration Over time', x_axis_label=f'start ({starttime})', y_axis_label='duration (ms)', plot_width=int(size * 1.2), plot_height=size, margin=(10, 10, 10, 175) # Top, R, Bottom, L ) duration.title.align = 'center' if(len(colours) <= colour_i): colours.append('#%06X' % random.randint(0, 256**3-1)) duration.line( x='timestamp', y='duration', legend_label=fname, line_width=2, source=source, line_color=colours[colour_i] ) # duration.legend_label.text_font_size = '11px' duration.xaxis[0].formatter = DatetimeTickFormatter(seconds=['%Ss']) # add hover tool hover = HoverTool() hover.tooltips = [ ('Duration', '@duration{0.000}' + 's'), ('Timestamp', '@timestamp{%S.%3Ns}') ] hover.formatters = { '@timestamp': 'datetime' } duration.add_tools(hover) # Histogram # (convert to milliseconds) dur_hist, edges = np.histogram(duration_df['duration'] * 1000 / np.timedelta64(1, 's')) duration_hist = pd.DataFrame({ 'duration': dur_hist, 'left': edges[:-1], 'right': edges[1:], }) hist = figure( title='Frequency of Callback Duration', x_axis_label='duration (ms)', y_axis_label='frequency', plot_width=int(size * 1.2), plot_height=size, margin=(10, 10, 10, 25) # Top, R, Bottom, L ) hist.title.align = 'center' hist.quad( bottom=0, top=duration_hist['duration'], left=duration_hist['left'], right=duration_hist['right'], fill_color=colours[colour_i], line_color=colours[colour_i], legend_label=fname ) colour_i += 1 figs.append([duration, hist]) return figs Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/reference_system_py/callback_duration.py"},{"location":"Files/callback__duration_8py/#reference_systemreference_system_pycallback_durationpy","text":"","title":"reference_system/reference_system_py/callback_duration.py"},{"location":"Files/callback__duration_8py/#namespaces","text":"Name reference_system_py reference_system_py::callback_duration","title":"Namespaces"},{"location":"Files/callback__duration_8py/#source-code","text":"# Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import random from bokeh.models import ColumnDataSource from bokeh.models import DatetimeTickFormatter from bokeh.models import Legend from bokeh.models.tools import HoverTool from bokeh.plotting import figure import numpy as np import pandas as pd def summary(data_model, size): callback_symbols = data_model.get_callback_symbols() colours = [] # Adds random colours for each callback colour_i = 0 earliest_date = None fname = '' for obj, symbol in callback_symbols.items(): duration_df = data_model.get_callback_durations(obj) thedate = duration_df.loc[:, 'timestamp'].iloc[0] if earliest_date is None or thedate <= earliest_date: earliest_date = thedate starttime = earliest_date.strftime('%Y-%m-%d %H:%M') duration = figure( title='Callback Durations Summary', x_axis_label=f'start ({starttime})', y_axis_label='duration (ms)', plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) legend_it = [] for obj, symbol in callback_symbols.items(): # Filter out internal subscriptions and get node information owner_info = data_model.get_callback_owner_info(obj) if not owner_info or '/parameter_events' in owner_info: continue if(len(colours) <= colour_i): colours.append('#%06X' % random.randint(0, 256**3-1)) duration_df = data_model.get_callback_durations(obj) source = ColumnDataSource(duration_df) duration.title.align = 'center' substr = 'node: ' index = str.find(owner_info, substr) if index >= 0: index += len(substr) fname = 'node_' + owner_info[index:(str.find(owner_info, ','))] substr = 'topic: /' index = str.find(owner_info, substr) if index >= 0: index += len(substr) fname += '_topic_' + owner_info[index:] c = duration.line( x='timestamp', y='duration', line_width=2, source=source, line_color=colours[colour_i], alpha=0.8, muted_color=colours[colour_i], muted_alpha=0.2, name=fname ) legend_it.append((fname, [c])) colour_i += 1 # duration.legend.label_text_font_size = '11px' duration.xaxis[0].formatter = DatetimeTickFormatter(seconds=['%Ss']) legend = Legend( items=legend_it, label_text_font_size='8pt', label_standoff=1, padding=1, spacing=1 ) legend.click_policy = 'hide' duration.add_layout(legend, 'right') # add hover tool hover = HoverTool() hover.tooltips = [ ('Callback', '$name'), ('Duration', '@duration{0.000}' + 's'), ('Timestamp', '@timestamp{%S.%3Ns}') ] hover.formatters = { '@timestamp': 'datetime' } duration.add_tools(hover) return duration # show(duration) # export_png(duration, filename=path + 'callback_duration_summary.png') def individual(data_model, size): # returns a list of individual plots for each callback symbol callback_symbols = data_model.get_callback_symbols() colours = [] # Adds random colours for each callback colour_i = 0 fname = '' figs = [] for obj, symbol in callback_symbols.items(): owner_info = data_model.get_callback_owner_info(obj) if owner_info is None: owner_info = '[unknown]' # Filter out internal subscriptions if '/parameter_events' in owner_info: continue substr = 'node: ' index = str.find(owner_info, substr) if index >= 0: index += len(substr) fname = 'node_' + owner_info[index:(str.find(owner_info, ','))] substr = 'topic: /' index = str.find(owner_info, substr) if index >= 0: index += len(substr) fname += '_topic_' + owner_info[index:] # Duration duration_df = data_model.get_callback_durations(obj) starttime = duration_df.loc[:, 'timestamp'].iloc[0].strftime('%Y-%m-%d %H:%M') source = ColumnDataSource(duration_df) duration = figure( title='Callback Duration Over time', x_axis_label=f'start ({starttime})', y_axis_label='duration (ms)', plot_width=int(size * 1.2), plot_height=size, margin=(10, 10, 10, 175) # Top, R, Bottom, L ) duration.title.align = 'center' if(len(colours) <= colour_i): colours.append('#%06X' % random.randint(0, 256**3-1)) duration.line( x='timestamp', y='duration', legend_label=fname, line_width=2, source=source, line_color=colours[colour_i] ) # duration.legend_label.text_font_size = '11px' duration.xaxis[0].formatter = DatetimeTickFormatter(seconds=['%Ss']) # add hover tool hover = HoverTool() hover.tooltips = [ ('Duration', '@duration{0.000}' + 's'), ('Timestamp', '@timestamp{%S.%3Ns}') ] hover.formatters = { '@timestamp': 'datetime' } duration.add_tools(hover) # Histogram # (convert to milliseconds) dur_hist, edges = np.histogram(duration_df['duration'] * 1000 / np.timedelta64(1, 's')) duration_hist = pd.DataFrame({ 'duration': dur_hist, 'left': edges[:-1], 'right': edges[1:], }) hist = figure( title='Frequency of Callback Duration', x_axis_label='duration (ms)', y_axis_label='frequency', plot_width=int(size * 1.2), plot_height=size, margin=(10, 10, 10, 25) # Top, R, Bottom, L ) hist.title.align = 'center' hist.quad( bottom=0, top=duration_hist['duration'], left=duration_hist['left'], right=duration_hist['right'], fill_color=colours[colour_i], line_color=colours[colour_i], legend_label=fname ) colour_i += 1 figs.append([duration, hist]) return figs Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/command_8hpp/","text":"reference_system/include/reference_system/nodes/rclcpp/command.hpp Namespaces Name nodes nodes::rclcpp_system Classes Name class nodes::rclcpp_system::Command Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__RCLCPP__COMMAND_HPP_ #define REFERENCE_SYSTEM__NODES__RCLCPP__COMMAND_HPP_ #include <chrono> #include <string> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/msg_types.hpp\" #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/sample_management.hpp\" namespace nodes { namespace rclcpp_system { class Command : public rclcpp::Node { public: explicit Command(const CommandSettings & settings) : Node(settings.node_name) { subscription_ = this->create_subscription<message_t>( settings.input_topic, 10, [this](const message_t::SharedPtr msg) {input_callback(msg);}); } private: void input_callback(const message_t::SharedPtr input_message) { uint32_t missed_samples = get_missed_samples_and_update_seq_nr(input_message, sequence_number_); print_sample_path(this->get_name(), missed_samples, input_message); } private: rclcpp::Subscription<message_t>::SharedPtr subscription_; uint32_t sequence_number_ = 0; }; } // namespace rclcpp_system } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__RCLCPP__COMMAND_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/include/reference_system/nodes/rclcpp/command.hpp"},{"location":"Files/command_8hpp/#reference_systemincludereference_systemnodesrclcppcommandhpp","text":"","title":"reference_system/include/reference_system/nodes/rclcpp/command.hpp"},{"location":"Files/command_8hpp/#namespaces","text":"Name nodes nodes::rclcpp_system","title":"Namespaces"},{"location":"Files/command_8hpp/#classes","text":"Name class nodes::rclcpp_system::Command","title":"Classes"},{"location":"Files/command_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__RCLCPP__COMMAND_HPP_ #define REFERENCE_SYSTEM__NODES__RCLCPP__COMMAND_HPP_ #include <chrono> #include <string> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/msg_types.hpp\" #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/sample_management.hpp\" namespace nodes { namespace rclcpp_system { class Command : public rclcpp::Node { public: explicit Command(const CommandSettings & settings) : Node(settings.node_name) { subscription_ = this->create_subscription<message_t>( settings.input_topic, 10, [this](const message_t::SharedPtr msg) {input_callback(msg);}); } private: void input_callback(const message_t::SharedPtr input_message) { uint32_t missed_samples = get_missed_samples_and_update_seq_nr(input_message, sequence_number_); print_sample_path(this->get_name(), missed_samples, input_message); } private: rclcpp::Subscription<message_t>::SharedPtr subscription_; uint32_t sequence_number_ = 0; }; } // namespace rclcpp_system } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__RCLCPP__COMMAND_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/conftest_8py/","text":"autoware_reference_system/test/conftest.py Namespaces Name conftest Source code # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. def pytest_configure(config): \"\"\"Document pytest.mark.TEST_ID to avoid pytest warning.\"\"\" config.addinivalue_line('markers', 'TEST_ID: Append a test ID to a test case') def pytest_collection_modifyitems(items): for item in items: for marker in item.iter_markers(name='TEST_ID'): test_id = marker.args[0] item.user_properties.append(('TEST_ID', test_id)) Updated on 2022-04-30 at 21:32:33 +0000","title":"autoware_reference_system/test/conftest.py"},{"location":"Files/conftest_8py/#autoware_reference_systemtestconftestpy","text":"","title":"autoware_reference_system/test/conftest.py"},{"location":"Files/conftest_8py/#namespaces","text":"Name conftest","title":"Namespaces"},{"location":"Files/conftest_8py/#source-code","text":"# Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. def pytest_configure(config): \"\"\"Document pytest.mark.TEST_ID to avoid pytest warning.\"\"\" config.addinivalue_line('markers', 'TEST_ID: Append a test ID to a test case') def pytest_collection_modifyitems(items): for item in items: for marker in item.iter_markers(name='TEST_ID'): test_id = marker.args[0] item.user_properties.append(('TEST_ID', test_id)) Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/constants_8py/","text":"reference_system/reference_system_py/constants.py Namespaces Name reference_system_py reference_system_py::constants Source code # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. TRACE_CALLBACK = 'tracing' TRACE_MEMORY = 'memory' TRACE_STD = 'log' # TODO(flynneva): support path as just the `tracing` directory and loop over # all subdirectories that have tracing data in them TRACE_DIRECTORY = 'tracing' SIZE_SUMMARY = 800 SIZE_SUBPLOT = 500 SIZE_TABLE_ROW = 50 SIZE_TABLE_WIDTH = 1250 SIZE_TITLE = '22px' SIZE_AXIS_LABEL = '20px' SIZE_CATEGORY_LABEL = '15px' SIZE_MAJOR_LABEL = '14px' Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/reference_system_py/constants.py"},{"location":"Files/constants_8py/#reference_systemreference_system_pyconstantspy","text":"","title":"reference_system/reference_system_py/constants.py"},{"location":"Files/constants_8py/#namespaces","text":"Name reference_system_py reference_system_py::constants","title":"Namespaces"},{"location":"Files/constants_8py/#source-code","text":"# Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. TRACE_CALLBACK = 'tracing' TRACE_MEMORY = 'memory' TRACE_STD = 'log' # TODO(flynneva): support path as just the `tracing` directory and loop over # all subdirectories that have tracing data in them TRACE_DIRECTORY = 'tracing' SIZE_SUMMARY = 800 SIZE_SUBPLOT = 500 SIZE_TABLE_ROW = 50 SIZE_TABLE_WIDTH = 1250 SIZE_TITLE = '22px' SIZE_AXIS_LABEL = '20px' SIZE_CATEGORY_LABEL = '15px' SIZE_MAJOR_LABEL = '14px' Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/cyclic_8hpp/","text":"reference_system/include/reference_system/nodes/rclcpp/cyclic.hpp Namespaces Name nodes nodes::rclcpp_system Classes Name class nodes::rclcpp_system::Cyclic Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__RCLCPP__CYCLIC_HPP_ #define REFERENCE_SYSTEM__NODES__RCLCPP__CYCLIC_HPP_ #include <chrono> #include <string> #include <utility> #include <vector> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/msg_types.hpp\" #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/number_cruncher.hpp\" #include \"reference_system/sample_management.hpp\" namespace nodes { namespace rclcpp_system { class Cyclic : public rclcpp::Node { public: explicit Cyclic(const CyclicSettings & settings) : Node(settings.node_name), number_crunch_limit_(settings.number_crunch_limit) { uint64_t input_number = 0U; for (const auto & input_topic : settings.inputs) { subscriptions_.emplace_back( subscription_t{ this->create_subscription<message_t>( input_topic, 1, [this, input_number](const message_t::SharedPtr msg) { input_callback(input_number, msg); }), 0, message_t::SharedPtr()}); ++input_number; } publisher_ = this->create_publisher<message_t>(settings.output_topic, 1); timer_ = this->create_wall_timer( settings.cycle_time, [this] {timer_callback();}); } private: void input_callback( const uint64_t input_number, const message_t::SharedPtr input_message) { subscriptions_[input_number].cache = input_message; } void timer_callback() { uint64_t timestamp = now_as_int(); auto number_cruncher_result = number_cruncher(number_crunch_limit_); auto output_message = publisher_->borrow_loaned_message(); output_message.get().size = 0; uint32_t missed_samples = 0; for (auto & s : subscriptions_) { if (!s.cache) { continue; } missed_samples += get_missed_samples_and_update_seq_nr(s.cache, s.sequence_number); merge_history_into_sample(output_message.get(), s.cache); s.cache.reset(); } set_sample( this->get_name(), sequence_number_++, missed_samples, timestamp, output_message.get()); output_message.get().data[0] = number_cruncher_result; publisher_->publish(std::move(output_message)); } private: rclcpp::Publisher<message_t>::SharedPtr publisher_; rclcpp::TimerBase::SharedPtr timer_; struct subscription_t { rclcpp::Subscription<message_t>::SharedPtr subscription; uint32_t sequence_number = 0; message_t::SharedPtr cache; }; std::vector<subscription_t> subscriptions_; uint64_t number_crunch_limit_; uint32_t sequence_number_ = 0; }; } // namespace rclcpp_system } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__RCLCPP__CYCLIC_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/include/reference_system/nodes/rclcpp/cyclic.hpp"},{"location":"Files/cyclic_8hpp/#reference_systemincludereference_systemnodesrclcppcyclichpp","text":"","title":"reference_system/include/reference_system/nodes/rclcpp/cyclic.hpp"},{"location":"Files/cyclic_8hpp/#namespaces","text":"Name nodes nodes::rclcpp_system","title":"Namespaces"},{"location":"Files/cyclic_8hpp/#classes","text":"Name class nodes::rclcpp_system::Cyclic","title":"Classes"},{"location":"Files/cyclic_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__RCLCPP__CYCLIC_HPP_ #define REFERENCE_SYSTEM__NODES__RCLCPP__CYCLIC_HPP_ #include <chrono> #include <string> #include <utility> #include <vector> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/msg_types.hpp\" #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/number_cruncher.hpp\" #include \"reference_system/sample_management.hpp\" namespace nodes { namespace rclcpp_system { class Cyclic : public rclcpp::Node { public: explicit Cyclic(const CyclicSettings & settings) : Node(settings.node_name), number_crunch_limit_(settings.number_crunch_limit) { uint64_t input_number = 0U; for (const auto & input_topic : settings.inputs) { subscriptions_.emplace_back( subscription_t{ this->create_subscription<message_t>( input_topic, 1, [this, input_number](const message_t::SharedPtr msg) { input_callback(input_number, msg); }), 0, message_t::SharedPtr()}); ++input_number; } publisher_ = this->create_publisher<message_t>(settings.output_topic, 1); timer_ = this->create_wall_timer( settings.cycle_time, [this] {timer_callback();}); } private: void input_callback( const uint64_t input_number, const message_t::SharedPtr input_message) { subscriptions_[input_number].cache = input_message; } void timer_callback() { uint64_t timestamp = now_as_int(); auto number_cruncher_result = number_cruncher(number_crunch_limit_); auto output_message = publisher_->borrow_loaned_message(); output_message.get().size = 0; uint32_t missed_samples = 0; for (auto & s : subscriptions_) { if (!s.cache) { continue; } missed_samples += get_missed_samples_and_update_seq_nr(s.cache, s.sequence_number); merge_history_into_sample(output_message.get(), s.cache); s.cache.reset(); } set_sample( this->get_name(), sequence_number_++, missed_samples, timestamp, output_message.get()); output_message.get().data[0] = number_cruncher_result; publisher_->publish(std::move(output_message)); } private: rclcpp::Publisher<message_t>::SharedPtr publisher_; rclcpp::TimerBase::SharedPtr timer_; struct subscription_t { rclcpp::Subscription<message_t>::SharedPtr subscription; uint32_t sequence_number = 0; message_t::SharedPtr cache; }; std::vector<subscription_t> subscriptions_; uint64_t number_crunch_limit_; uint32_t sequence_number_ = 0; }; } // namespace rclcpp_system } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__RCLCPP__CYCLIC_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/default_8hpp/","text":"autoware_reference_system/include/autoware_reference_system/system/timing/default.hpp Namespaces Name nodes nodes::timing Classes Name struct nodes::timing::Default Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef AUTOWARE_REFERENCE_SYSTEM__SYSTEM__TIMING__DEFAULT_HPP_ #define AUTOWARE_REFERENCE_SYSTEM__SYSTEM__TIMING__DEFAULT_HPP_ #include <chrono> namespace nodes { namespace timing { struct Default { using time_t = std::chrono::nanoseconds; using milliseconds = std::chrono::milliseconds; // sensors static constexpr time_t FRONT_LIDAR_DRIVER = milliseconds(100); static constexpr time_t REAR_LIDAR_DRIVER = milliseconds(100); static constexpr time_t POINT_CLOUD_MAP = milliseconds(120); static constexpr time_t VISUALIZER = milliseconds(60); static constexpr time_t LANELET2MAP = milliseconds(100); static constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS = milliseconds(25); // the following values are used as the number_cruncher_limit // to search for primes up to starting at 3 // for your platform, run the `number_cruncher_benchmark` executable // to figure out what values to place here corresponding to the run_time // you would like to run each node for // processing static constexpr uint64_t POINTS_TRANSFORMER_FRONT = 4096; static constexpr uint64_t POINTS_TRANSFORMER_REAR = 4096; static constexpr uint64_t VOXEL_GRID_DOWNSAMPLER = 4096; static constexpr uint64_t POINT_CLOUD_MAP_LOADER = 4096; static constexpr uint64_t RAY_GROUND_FILTER = 4096; static constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR = 4096; static constexpr uint64_t EUCLIDEAN_INTERSECTION = 4096; static constexpr uint64_t OBJECT_COLLISION_ESTIMATOR = 4096; static constexpr uint64_t MPC_CONTROLLER = 4096; static constexpr uint64_t PARKING_PLANNER = 4096; static constexpr uint64_t LANE_PLANNER = 4096; // fusion static constexpr uint64_t POINT_CLOUD_FUSION = 4096; static constexpr uint64_t NDT_LOCALIZER = 4096; static constexpr uint64_t VEHICLE_INTERFACE = 4096; static constexpr uint64_t LANELET_2_GLOBAL_PLANNER = 4096; static constexpr uint64_t LANELET_2_MAP_LOADER = 4096; // cyclic static constexpr uint64_t BEHAVIOR_PLANNER = 4096; static constexpr time_t BEHAVIOR_PLANNER_CYCLE = milliseconds(100); }; constexpr Default::time_t Default::FRONT_LIDAR_DRIVER; constexpr Default::time_t Default::REAR_LIDAR_DRIVER; constexpr Default::time_t Default::POINT_CLOUD_MAP; constexpr Default::time_t Default::VISUALIZER; constexpr Default::time_t Default::LANELET2MAP; constexpr Default::time_t Default::EUCLIDEAN_CLUSTER_SETTINGS; constexpr uint64_t Default::POINTS_TRANSFORMER_FRONT; constexpr uint64_t Default::POINTS_TRANSFORMER_REAR; constexpr uint64_t Default::VOXEL_GRID_DOWNSAMPLER; constexpr uint64_t Default::POINT_CLOUD_MAP_LOADER; constexpr uint64_t Default::RAY_GROUND_FILTER; constexpr uint64_t Default::EUCLIDEAN_CLUSTER_DETECTOR; constexpr uint64_t Default::EUCLIDEAN_INTERSECTION; constexpr uint64_t Default::OBJECT_COLLISION_ESTIMATOR; constexpr uint64_t Default::MPC_CONTROLLER; constexpr uint64_t Default::PARKING_PLANNER; constexpr uint64_t Default::LANE_PLANNER; constexpr uint64_t Default::POINT_CLOUD_FUSION; constexpr uint64_t Default::NDT_LOCALIZER; constexpr uint64_t Default::VEHICLE_INTERFACE; constexpr uint64_t Default::LANELET_2_GLOBAL_PLANNER; constexpr uint64_t Default::LANELET_2_MAP_LOADER; constexpr uint64_t Default::BEHAVIOR_PLANNER; constexpr Default::time_t Default::BEHAVIOR_PLANNER_CYCLE; } // namespace timing } // namespace nodes #endif // AUTOWARE_REFERENCE_SYSTEM__SYSTEM__TIMING__DEFAULT_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"autoware_reference_system/include/autoware_reference_system/system/timing/default.hpp"},{"location":"Files/default_8hpp/#autoware_reference_systemincludeautoware_reference_systemsystemtimingdefaulthpp","text":"","title":"autoware_reference_system/include/autoware_reference_system/system/timing/default.hpp"},{"location":"Files/default_8hpp/#namespaces","text":"Name nodes nodes::timing","title":"Namespaces"},{"location":"Files/default_8hpp/#classes","text":"Name struct nodes::timing::Default","title":"Classes"},{"location":"Files/default_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef AUTOWARE_REFERENCE_SYSTEM__SYSTEM__TIMING__DEFAULT_HPP_ #define AUTOWARE_REFERENCE_SYSTEM__SYSTEM__TIMING__DEFAULT_HPP_ #include <chrono> namespace nodes { namespace timing { struct Default { using time_t = std::chrono::nanoseconds; using milliseconds = std::chrono::milliseconds; // sensors static constexpr time_t FRONT_LIDAR_DRIVER = milliseconds(100); static constexpr time_t REAR_LIDAR_DRIVER = milliseconds(100); static constexpr time_t POINT_CLOUD_MAP = milliseconds(120); static constexpr time_t VISUALIZER = milliseconds(60); static constexpr time_t LANELET2MAP = milliseconds(100); static constexpr time_t EUCLIDEAN_CLUSTER_SETTINGS = milliseconds(25); // the following values are used as the number_cruncher_limit // to search for primes up to starting at 3 // for your platform, run the `number_cruncher_benchmark` executable // to figure out what values to place here corresponding to the run_time // you would like to run each node for // processing static constexpr uint64_t POINTS_TRANSFORMER_FRONT = 4096; static constexpr uint64_t POINTS_TRANSFORMER_REAR = 4096; static constexpr uint64_t VOXEL_GRID_DOWNSAMPLER = 4096; static constexpr uint64_t POINT_CLOUD_MAP_LOADER = 4096; static constexpr uint64_t RAY_GROUND_FILTER = 4096; static constexpr uint64_t EUCLIDEAN_CLUSTER_DETECTOR = 4096; static constexpr uint64_t EUCLIDEAN_INTERSECTION = 4096; static constexpr uint64_t OBJECT_COLLISION_ESTIMATOR = 4096; static constexpr uint64_t MPC_CONTROLLER = 4096; static constexpr uint64_t PARKING_PLANNER = 4096; static constexpr uint64_t LANE_PLANNER = 4096; // fusion static constexpr uint64_t POINT_CLOUD_FUSION = 4096; static constexpr uint64_t NDT_LOCALIZER = 4096; static constexpr uint64_t VEHICLE_INTERFACE = 4096; static constexpr uint64_t LANELET_2_GLOBAL_PLANNER = 4096; static constexpr uint64_t LANELET_2_MAP_LOADER = 4096; // cyclic static constexpr uint64_t BEHAVIOR_PLANNER = 4096; static constexpr time_t BEHAVIOR_PLANNER_CYCLE = milliseconds(100); }; constexpr Default::time_t Default::FRONT_LIDAR_DRIVER; constexpr Default::time_t Default::REAR_LIDAR_DRIVER; constexpr Default::time_t Default::POINT_CLOUD_MAP; constexpr Default::time_t Default::VISUALIZER; constexpr Default::time_t Default::LANELET2MAP; constexpr Default::time_t Default::EUCLIDEAN_CLUSTER_SETTINGS; constexpr uint64_t Default::POINTS_TRANSFORMER_FRONT; constexpr uint64_t Default::POINTS_TRANSFORMER_REAR; constexpr uint64_t Default::VOXEL_GRID_DOWNSAMPLER; constexpr uint64_t Default::POINT_CLOUD_MAP_LOADER; constexpr uint64_t Default::RAY_GROUND_FILTER; constexpr uint64_t Default::EUCLIDEAN_CLUSTER_DETECTOR; constexpr uint64_t Default::EUCLIDEAN_INTERSECTION; constexpr uint64_t Default::OBJECT_COLLISION_ESTIMATOR; constexpr uint64_t Default::MPC_CONTROLLER; constexpr uint64_t Default::PARKING_PLANNER; constexpr uint64_t Default::LANE_PLANNER; constexpr uint64_t Default::POINT_CLOUD_FUSION; constexpr uint64_t Default::NDT_LOCALIZER; constexpr uint64_t Default::VEHICLE_INTERFACE; constexpr uint64_t Default::LANELET_2_GLOBAL_PLANNER; constexpr uint64_t Default::LANELET_2_MAP_LOADER; constexpr uint64_t Default::BEHAVIOR_PLANNER; constexpr Default::time_t Default::BEHAVIOR_PLANNER_CYCLE; } // namespace timing } // namespace nodes #endif // AUTOWARE_REFERENCE_SYSTEM__SYSTEM__TIMING__DEFAULT_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/dir_0346bc0d6d902878a4b20af926e2b688/","text":"autoware_reference_system/include/autoware_reference_system/system Directories Name autoware_reference_system/include/autoware_reference_system/system/timing Updated on 2022-04-30 at 21:32:33 +0000","title":"autoware_reference_system/include/autoware_reference_system/system"},{"location":"Files/dir_0346bc0d6d902878a4b20af926e2b688/#autoware_reference_systemincludeautoware_reference_systemsystem","text":"","title":"autoware_reference_system/include/autoware_reference_system/system"},{"location":"Files/dir_0346bc0d6d902878a4b20af926e2b688/#directories","text":"Name autoware_reference_system/include/autoware_reference_system/system/timing Updated on 2022-04-30 at 21:32:33 +0000","title":"Directories"},{"location":"Files/dir_09addd1cc25865acff9e93b8c10e91f0/","text":"autoware_reference_system/src Directories Name autoware_reference_system/src/ros2 Files Name autoware_reference_system/src/number_cruncher_benchmark.cpp autoware_reference_system/src/priorities.cpp Updated on 2022-04-30 at 21:32:33 +0000","title":"autoware_reference_system/src"},{"location":"Files/dir_09addd1cc25865acff9e93b8c10e91f0/#autoware_reference_systemsrc","text":"","title":"autoware_reference_system/src"},{"location":"Files/dir_09addd1cc25865acff9e93b8c10e91f0/#directories","text":"Name autoware_reference_system/src/ros2","title":"Directories"},{"location":"Files/dir_09addd1cc25865acff9e93b8c10e91f0/#files","text":"Name autoware_reference_system/src/number_cruncher_benchmark.cpp autoware_reference_system/src/priorities.cpp Updated on 2022-04-30 at 21:32:33 +0000","title":"Files"},{"location":"Files/dir_127c7cc0ffcbc3e61877c07b26af2fa0/","text":"reference_system Directories Name reference_system/include reference_system/reference_system_py reference_system/test Files Name reference_system/setup.py Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system"},{"location":"Files/dir_127c7cc0ffcbc3e61877c07b26af2fa0/#reference_system","text":"","title":"reference_system"},{"location":"Files/dir_127c7cc0ffcbc3e61877c07b26af2fa0/#directories","text":"Name reference_system/include reference_system/reference_system_py reference_system/test","title":"Directories"},{"location":"Files/dir_127c7cc0ffcbc3e61877c07b26af2fa0/#files","text":"Name reference_system/setup.py Updated on 2022-04-30 at 21:32:33 +0000","title":"Files"},{"location":"Files/dir_246fa732e08bce0b2fe7c308221868df/","text":"reference_system/include/reference_system/system/type Files Name reference_system/include/reference_system/system/type/rclcpp_system.hpp Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/include/reference_system/system/type"},{"location":"Files/dir_246fa732e08bce0b2fe7c308221868df/#reference_systemincludereference_systemsystemtype","text":"","title":"reference_system/include/reference_system/system/type"},{"location":"Files/dir_246fa732e08bce0b2fe7c308221868df/#files","text":"Name reference_system/include/reference_system/system/type/rclcpp_system.hpp Updated on 2022-04-30 at 21:32:33 +0000","title":"Files"},{"location":"Files/dir_42b63979f223277f39dc3319aa9a7a65/","text":"autoware_reference_system/include/autoware_reference_system Directories Name autoware_reference_system/include/autoware_reference_system/system Files Name autoware_reference_system/include/autoware_reference_system/autoware_system_builder.hpp autoware_reference_system/include/autoware_reference_system/priorities.hpp Updated on 2022-04-30 at 21:32:33 +0000","title":"autoware_reference_system/include/autoware_reference_system"},{"location":"Files/dir_42b63979f223277f39dc3319aa9a7a65/#autoware_reference_systemincludeautoware_reference_system","text":"","title":"autoware_reference_system/include/autoware_reference_system"},{"location":"Files/dir_42b63979f223277f39dc3319aa9a7a65/#directories","text":"Name autoware_reference_system/include/autoware_reference_system/system","title":"Directories"},{"location":"Files/dir_42b63979f223277f39dc3319aa9a7a65/#files","text":"Name autoware_reference_system/include/autoware_reference_system/autoware_system_builder.hpp autoware_reference_system/include/autoware_reference_system/priorities.hpp Updated on 2022-04-30 at 21:32:33 +0000","title":"Files"},{"location":"Files/dir_433aa5f1c128af3100645ac07e20746d/","text":"autoware_reference_system/src/ros2/executor Files Name autoware_reference_system/src/ros2/executor/autoware_default_cbg.cpp autoware_reference_system/src/ros2/executor/autoware_default_multithreaded.cpp autoware_reference_system/src/ros2/executor/autoware_default_prioritized.cpp autoware_reference_system/src/ros2/executor/autoware_default_singlethreaded.cpp autoware_reference_system/src/ros2/executor/autoware_default_staticsinglethreaded.cpp Updated on 2022-04-30 at 21:32:33 +0000","title":"autoware_reference_system/src/ros2/executor"},{"location":"Files/dir_433aa5f1c128af3100645ac07e20746d/#autoware_reference_systemsrcros2executor","text":"","title":"autoware_reference_system/src/ros2/executor"},{"location":"Files/dir_433aa5f1c128af3100645ac07e20746d/#files","text":"Name autoware_reference_system/src/ros2/executor/autoware_default_cbg.cpp autoware_reference_system/src/ros2/executor/autoware_default_multithreaded.cpp autoware_reference_system/src/ros2/executor/autoware_default_prioritized.cpp autoware_reference_system/src/ros2/executor/autoware_default_singlethreaded.cpp autoware_reference_system/src/ros2/executor/autoware_default_staticsinglethreaded.cpp Updated on 2022-04-30 at 21:32:33 +0000","title":"Files"},{"location":"Files/dir_5d82fd324745b35a7fd627934e1c3db8/","text":"reference_system/reference_system_py Files Name reference_system/reference_system_py/ init .py reference_system/reference_system_py/benchmark.py reference_system/reference_system_py/callback_duration.py reference_system/reference_system_py/constants.py reference_system/reference_system_py/dropped_messages.py reference_system/reference_system_py/memory_usage.py reference_system/reference_system_py/plot_utils.py reference_system/reference_system_py/std_latency.py reference_system/reference_system_py/trace_utils.py Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/reference_system_py"},{"location":"Files/dir_5d82fd324745b35a7fd627934e1c3db8/#reference_systemreference_system_py","text":"","title":"reference_system/reference_system_py"},{"location":"Files/dir_5d82fd324745b35a7fd627934e1c3db8/#files","text":"Name reference_system/reference_system_py/ init .py reference_system/reference_system_py/benchmark.py reference_system/reference_system_py/callback_duration.py reference_system/reference_system_py/constants.py reference_system/reference_system_py/dropped_messages.py reference_system/reference_system_py/memory_usage.py reference_system/reference_system_py/plot_utils.py reference_system/reference_system_py/std_latency.py reference_system/reference_system_py/trace_utils.py Updated on 2022-04-30 at 21:32:33 +0000","title":"Files"},{"location":"Files/dir_5fa14cd5f63f76c2b01ef334fb51ab9e/","text":"autoware_reference_system/include Directories Name autoware_reference_system/include/autoware_reference_system Updated on 2022-04-30 at 21:32:33 +0000","title":"autoware_reference_system/include"},{"location":"Files/dir_5fa14cd5f63f76c2b01ef334fb51ab9e/#autoware_reference_systeminclude","text":"","title":"autoware_reference_system/include"},{"location":"Files/dir_5fa14cd5f63f76c2b01ef334fb51ab9e/#directories","text":"Name autoware_reference_system/include/autoware_reference_system Updated on 2022-04-30 at 21:32:33 +0000","title":"Directories"},{"location":"Files/dir_91b0f55ce06907c9ebdd60f53551d65e/","text":"reference_system/include/reference_system/system Directories Name reference_system/include/reference_system/system/type Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/include/reference_system/system"},{"location":"Files/dir_91b0f55ce06907c9ebdd60f53551d65e/#reference_systemincludereference_systemsystem","text":"","title":"reference_system/include/reference_system/system"},{"location":"Files/dir_91b0f55ce06907c9ebdd60f53551d65e/#directories","text":"Name reference_system/include/reference_system/system/type Updated on 2022-04-30 at 21:32:33 +0000","title":"Directories"},{"location":"Files/dir_97ee88642b4fc0175cf5ceed72dfc69e/","text":"reference_system/include Directories Name reference_system/include/reference_system Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/include"},{"location":"Files/dir_97ee88642b4fc0175cf5ceed72dfc69e/#reference_systeminclude","text":"","title":"reference_system/include"},{"location":"Files/dir_97ee88642b4fc0175cf5ceed72dfc69e/#directories","text":"Name reference_system/include/reference_system Updated on 2022-04-30 at 21:32:33 +0000","title":"Directories"},{"location":"Files/dir_9868580a2d8949ba20aec737ffd74109/","text":"reference_system/include/reference_system Directories Name reference_system/include/reference_system/nodes reference_system/include/reference_system/system Files Name reference_system/include/reference_system/msg_types.hpp reference_system/include/reference_system/number_cruncher.hpp reference_system/include/reference_system/sample_management.hpp Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/include/reference_system"},{"location":"Files/dir_9868580a2d8949ba20aec737ffd74109/#reference_systemincludereference_system","text":"","title":"reference_system/include/reference_system"},{"location":"Files/dir_9868580a2d8949ba20aec737ffd74109/#directories","text":"Name reference_system/include/reference_system/nodes reference_system/include/reference_system/system","title":"Directories"},{"location":"Files/dir_9868580a2d8949ba20aec737ffd74109/#files","text":"Name reference_system/include/reference_system/msg_types.hpp reference_system/include/reference_system/number_cruncher.hpp reference_system/include/reference_system/sample_management.hpp Updated on 2022-04-30 at 21:32:33 +0000","title":"Files"},{"location":"Files/dir_9fb2e5fa41f453476f53652aa901bc10/","text":"autoware_reference_system/src/ros2 Directories Name autoware_reference_system/src/ros2/executor Updated on 2022-04-30 at 21:32:33 +0000","title":"autoware_reference_system/src/ros2"},{"location":"Files/dir_9fb2e5fa41f453476f53652aa901bc10/#autoware_reference_systemsrcros2","text":"","title":"autoware_reference_system/src/ros2"},{"location":"Files/dir_9fb2e5fa41f453476f53652aa901bc10/#directories","text":"Name autoware_reference_system/src/ros2/executor Updated on 2022-04-30 at 21:32:33 +0000","title":"Directories"},{"location":"Files/dir_a9b47c5ee89e1161970d1296c923485c/","text":"reference_system/include/reference_system/nodes/rclcpp Files Name reference_system/include/reference_system/nodes/rclcpp/command.hpp reference_system/include/reference_system/nodes/rclcpp/cyclic.hpp reference_system/include/reference_system/nodes/rclcpp/fusion.hpp reference_system/include/reference_system/nodes/rclcpp/intersection.hpp reference_system/include/reference_system/nodes/rclcpp/sensor.hpp reference_system/include/reference_system/nodes/rclcpp/transform.hpp Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/include/reference_system/nodes/rclcpp"},{"location":"Files/dir_a9b47c5ee89e1161970d1296c923485c/#reference_systemincludereference_systemnodesrclcpp","text":"","title":"reference_system/include/reference_system/nodes/rclcpp"},{"location":"Files/dir_a9b47c5ee89e1161970d1296c923485c/#files","text":"Name reference_system/include/reference_system/nodes/rclcpp/command.hpp reference_system/include/reference_system/nodes/rclcpp/cyclic.hpp reference_system/include/reference_system/nodes/rclcpp/fusion.hpp reference_system/include/reference_system/nodes/rclcpp/intersection.hpp reference_system/include/reference_system/nodes/rclcpp/sensor.hpp reference_system/include/reference_system/nodes/rclcpp/transform.hpp Updated on 2022-04-30 at 21:32:33 +0000","title":"Files"},{"location":"Files/dir_ade77feecc6fc14930bc6f4956def00c/","text":"reference_interfaces Directories Name reference_interfaces/msg Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_interfaces"},{"location":"Files/dir_ade77feecc6fc14930bc6f4956def00c/#reference_interfaces","text":"","title":"reference_interfaces"},{"location":"Files/dir_ade77feecc6fc14930bc6f4956def00c/#directories","text":"Name reference_interfaces/msg Updated on 2022-04-30 at 21:32:33 +0000","title":"Directories"},{"location":"Files/dir_b0fed25fe70402f2c9879f17b24b63ba/","text":"autoware_reference_system Directories Name autoware_reference_system/include autoware_reference_system/scripts autoware_reference_system/src autoware_reference_system/test Updated on 2022-04-30 at 21:32:33 +0000","title":"autoware_reference_system"},{"location":"Files/dir_b0fed25fe70402f2c9879f17b24b63ba/#autoware_reference_system","text":"","title":"autoware_reference_system"},{"location":"Files/dir_b0fed25fe70402f2c9879f17b24b63ba/#directories","text":"Name autoware_reference_system/include autoware_reference_system/scripts autoware_reference_system/src autoware_reference_system/test Updated on 2022-04-30 at 21:32:33 +0000","title":"Directories"},{"location":"Files/dir_b6644976b427258346d4b4ecded5ae41/","text":"autoware_reference_system/scripts Files Name autoware_reference_system/scripts/benchmark.py Updated on 2022-04-30 at 21:32:33 +0000","title":"autoware_reference_system/scripts"},{"location":"Files/dir_b6644976b427258346d4b4ecded5ae41/#autoware_reference_systemscripts","text":"","title":"autoware_reference_system/scripts"},{"location":"Files/dir_b6644976b427258346d4b4ecded5ae41/#files","text":"Name autoware_reference_system/scripts/benchmark.py Updated on 2022-04-30 at 21:32:33 +0000","title":"Files"},{"location":"Files/dir_c179573033c64836cec4bb0cc3550ee6/","text":"autoware_reference_system/test Files Name autoware_reference_system/test/conftest.py autoware_reference_system/test/test_autoware_reference_system.cpp autoware_reference_system/test/test_platform.py autoware_reference_system/test/test_requirements.py Updated on 2022-04-30 at 21:32:33 +0000","title":"autoware_reference_system/test"},{"location":"Files/dir_c179573033c64836cec4bb0cc3550ee6/#autoware_reference_systemtest","text":"","title":"autoware_reference_system/test"},{"location":"Files/dir_c179573033c64836cec4bb0cc3550ee6/#files","text":"Name autoware_reference_system/test/conftest.py autoware_reference_system/test/test_autoware_reference_system.cpp autoware_reference_system/test/test_platform.py autoware_reference_system/test/test_requirements.py Updated on 2022-04-30 at 21:32:33 +0000","title":"Files"},{"location":"Files/dir_c3a592c969eb740d8a64341e6b9a3579/","text":"reference_system/test Files Name reference_system/test/gtest_main.cpp reference_system/test/test_fixtures.hpp reference_system/test/test_number_cruncher.cpp reference_system/test/test_reference_system_rclcpp.cpp reference_system/test/test_sample_management.cpp Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/test"},{"location":"Files/dir_c3a592c969eb740d8a64341e6b9a3579/#reference_systemtest","text":"","title":"reference_system/test"},{"location":"Files/dir_c3a592c969eb740d8a64341e6b9a3579/#files","text":"Name reference_system/test/gtest_main.cpp reference_system/test/test_fixtures.hpp reference_system/test/test_number_cruncher.cpp reference_system/test/test_reference_system_rclcpp.cpp reference_system/test/test_sample_management.cpp Updated on 2022-04-30 at 21:32:33 +0000","title":"Files"},{"location":"Files/dir_e1d1d57603c7889177b30ad98e438429/","text":"reference_system/include/reference_system/nodes Directories Name reference_system/include/reference_system/nodes/rclcpp Files Name reference_system/include/reference_system/nodes/settings.hpp Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/include/reference_system/nodes"},{"location":"Files/dir_e1d1d57603c7889177b30ad98e438429/#reference_systemincludereference_systemnodes","text":"","title":"reference_system/include/reference_system/nodes"},{"location":"Files/dir_e1d1d57603c7889177b30ad98e438429/#directories","text":"Name reference_system/include/reference_system/nodes/rclcpp","title":"Directories"},{"location":"Files/dir_e1d1d57603c7889177b30ad98e438429/#files","text":"Name reference_system/include/reference_system/nodes/settings.hpp Updated on 2022-04-30 at 21:32:33 +0000","title":"Files"},{"location":"Files/dir_e241d6a2048a09ddb4361fd2440aad67/","text":"autoware_reference_system/include/autoware_reference_system/system/timing Files Name autoware_reference_system/include/autoware_reference_system/system/timing/benchmark.hpp autoware_reference_system/include/autoware_reference_system/system/timing/default.hpp Updated on 2022-04-30 at 21:32:33 +0000","title":"autoware_reference_system/include/autoware_reference_system/system/timing"},{"location":"Files/dir_e241d6a2048a09ddb4361fd2440aad67/#autoware_reference_systemincludeautoware_reference_systemsystemtiming","text":"","title":"autoware_reference_system/include/autoware_reference_system/system/timing"},{"location":"Files/dir_e241d6a2048a09ddb4361fd2440aad67/#files","text":"Name autoware_reference_system/include/autoware_reference_system/system/timing/benchmark.hpp autoware_reference_system/include/autoware_reference_system/system/timing/default.hpp Updated on 2022-04-30 at 21:32:33 +0000","title":"Files"},{"location":"Files/dir_f7c5390633b5b32c3d651a98285f1453/","text":"reference_interfaces/msg Files Name reference_interfaces/msg/Message4kb.idl reference_interfaces/msg/TransmissionStats.idl Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_interfaces/msg"},{"location":"Files/dir_f7c5390633b5b32c3d651a98285f1453/#reference_interfacesmsg","text":"","title":"reference_interfaces/msg"},{"location":"Files/dir_f7c5390633b5b32c3d651a98285f1453/#files","text":"Name reference_interfaces/msg/Message4kb.idl reference_interfaces/msg/TransmissionStats.idl Updated on 2022-04-30 at 21:32:33 +0000","title":"Files"},{"location":"Files/dropped__messages_8py/","text":"reference_system/reference_system_py/dropped_messages.py Namespaces Name reference_system_py reference_system_py::dropped_messages Source code # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import random # from bokeh.layouts import layout from bokeh.models import ColumnDataSource from bokeh.models import DatetimeTickFormatter from bokeh.models.ranges import FactorRange from bokeh.models.tools import HoverTool from bokeh.models.widgets.markups import Div from bokeh.models.widgets.tables import DataTable, TableColumn from bokeh.palettes import cividis from bokeh.plotting import figure from bokeh.transform import factor_cmap try: import networkx as nx nx_available = True except ImportError: nx_available = False import numpy as np import pandas as pd def individual(data_model, size): data_dict = parseData(data_model) dropped_df = data_dict['dropped'] latency_df = data_dict['latency'] run_time = data_dict['run_time'] y = list(zip(dropped_df.node, dropped_df.topic)) latency_source = ColumnDataSource(latency_df) dropped_source = ColumnDataSource(dropped_df) dropped_source.data['y'] = y # use this for axis of figure ~0.25 of buffer max_dropped = max(dropped_df['dropped']) + 0.25 # initialize figure dropped_fig = figure( title='Dropped Messages Summary ({:.2f} s) [UNDER DEVELOPMENT]'.format(float(run_time)), y_axis_label='Callback by Node and Topic Name', x_axis_label='Dropped Messages', y_range=FactorRange(*y), x_range=(0, max_dropped), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) # add horizontal bar to figure dropped_fig.hbar( y='y', right='dropped', width=0.1, source=dropped_source, fill_color=factor_cmap( 'y', palette=cividis(dropped_df['topic'].shape[0]), factors=list(dropped_df['topic'].values.tolist()), start=1, end=2) ) dropped_fig.yaxis.major_label_orientation = 'horizontal' dropped_fig.yaxis.subgroup_label_orientation = 'horizontal' dropped_fig.yaxis.group_label_orientation = 'horizontal' # add hover tool hover = HoverTool() hover.tooltips = [ ('Callback (Node and Topic)', '@node @topic'), ('Dropped', '@dropped'), ('Expected', '@expected_count'), ('Received', '@count') ] dropped_fig.add_tools(hover) # add dropped messages table dropped_summary = dropped_df.describe().T.reset_index() columns = [TableColumn(field=col, title=col) for col in dropped_summary] dropped_table_title = Div( text='<b>Dropped Messages Summary Table [UNDER DEVELOPMENT]</b>', width=1000, height=10 ) dropped_table = [ dropped_table_title, DataTable( columns=columns, source=ColumnDataSource(dropped_summary), margin=(10, 10, 10, 10), height=150, width=size)] # add latency plot latency_fig = figure( title='Latency From Front Lidar to Collision Estimator [UNDER DEVELOPMENT]', x_axis_label='Time', y_axis_label='Latency to Object Collision Estimator (ms)', plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) latency_fig.line( x='timestamp', y='latency', source=latency_source, line_width=2 ) latency_fig.xaxis[0].formatter = DatetimeTickFormatter(seconds=['%Ss']) # add latency table latency_summary = latency_df.describe().T.reset_index() columns = [TableColumn(field=col, title=col) for col in latency_summary] latency_table_title = Div( text='<b>Latency Summary Table</b>', width=1000, height=10 ) latency_table = [ latency_table_title, DataTable( columns=columns, source=ColumnDataSource(latency_summary), margin=(10, 10, 10, 10), height=75, width=size)] return [ [dropped_table], [dropped_fig], [latency_table], [latency_fig] ] def parseData(data_model): callback_symbols = data_model.get_callback_symbols() colors = [] # Adds random colors for each callback color_i = 0 earliest_date = None latest_date = None dropped_data = [] front_lidar_data = pd.DataFrame() object_collision_data = pd.DataFrame() for obj, symbol in callback_symbols.items(): callback_df = data_model.get_callback_durations(obj) # get node information and filter out internal subscriptions owner_info = data_model.get_callback_owner_info(obj) if owner_info is not None: if '/parameter_events' in owner_info: continue period = 0.0 if 'period' in owner_info: # assume in milliseconds so convert to seconds period = float(owner_info[ owner_info.find('period: ') + len('period: '):owner_info.rfind(' ')]) / 1000 if 'FrontLidarDriver' in owner_info and 'Timer' in owner_info: front_lidar_data = callback_df if 'ObjectCollisionEstimator' in owner_info: object_collision_data = callback_df # add color to list if needed if(len(colors) <= color_i): colors.append('#%06X' % random.randint(0, 256**3-1)) # get human readable name of callback substr = 'node: ' index = str.find(owner_info, substr) if index >= 0: index += len(substr) node = owner_info[index:(str.find(owner_info, ','))] substr = 'topic: /' index = str.find(owner_info, substr) if index >= 0: index += len(substr) topic = owner_info[index:] else: topic = '' # get first and last timestamp of data thefirstdate = callback_df.loc[:, 'timestamp'].iloc[0] if earliest_date is None: earliest_date = thefirstdate elif earliest_date is not None and thefirstdate <= earliest_date: earliest_date = thefirstdate thelastdate = callback_df.loc[:, 'timestamp'].iloc[len(callback_df)-1] if latest_date is None: latest_date = thelastdate elif latest_date is not None and thelastdate >= latest_date: latest_date = thelastdate # add name of callback and count to list dropped_data.append( [str(node), str(topic), float(len(callback_df)), period, 0.0, 0.0, colors[color_i]]) color_i += 1 front_lidar_data = front_lidar_data.reset_index(drop=True) object_collision_data = object_collision_data.reset_index(drop=True) # ensure dataframes are same length for latency calc, drop extra lidar frames extra = len(front_lidar_data) - len(object_collision_data) if(extra > 0): front_lidar_data.drop(front_lidar_data.tail(extra).index, inplace=True) latency = object_collision_data['timestamp'] - front_lidar_data['timestamp'] dropped_df = pd.DataFrame( dropped_data, columns=['node', 'topic', 'count', 'period', 'dropped', 'expected_count', 'color']) latency_df = pd.DataFrame( {'index': range(0, len(latency)), 'latency': latency, 'timestamp': front_lidar_data['timestamp']}) # sort values by node and topic dropped_df = dropped_df.sort_values(by=['node', 'topic']) # calculate run time approx_run_time = None if earliest_date is not None and latest_date is not None: approx_run_time = getRunTime(earliest_date, latest_date) # calculate estimated count and received count dropped_df = calcTotals(approx_run_time, dropped_df) node_graph = None if(nx_available): # generate node graph node_graph = generateNodeGraph(dropped_df) # count expected and dropped messages dropped_df = countDropped(dropped_df, node_graph) # prepare output data_dict = { 'dropped': dropped_df, 'latency': latency_df, 'node_graph': node_graph, 'start': earliest_date, 'end': latest_date, 'run_time': approx_run_time, } return data_dict def getRunTime(start, end): # calculate run time in seconds for experiment return (end - start).total_seconds() def calcTotals(run_time, dataframe): # calculate expected counts for each period mask = (dataframe['period'] != 0) period_non_zero = dataframe[mask] dataframe.loc[mask, 'expected_count'] = (run_time / period_non_zero['period']).apply(np.floor) return dataframe def generateNodeGraph(dataframe): connections = [] # for every node that has a defined period for node in dataframe.node: # assume node has sub nodes by default sub_node_exists = True # search for sub nodes of current node, assume node name is topic name current_node = node # current top-level node of fork fork_topics = [] sub_topics = [] in_fork = False while sub_node_exists: if(len(fork_topics) != 0 and not in_fork): # fork topic exists current_node = fork_topics.pop(0) in_fork = True if(len(sub_topics) != 0): # sub topics still exist current_node = sub_topics.pop(0) sub_node_df = dataframe.loc[ ((dataframe.topic == current_node) & (dataframe.expected_count == 0))] if not sub_node_df.empty: # node has sub node(s) if(sub_node_df.shape[0] > 1): # node has more than one sub node for fork in sub_node_df.node: if fork not in fork_topics: fork_topics.append(fork) for sub_node in sub_node_df.node: # add to list of tuples connections.append((current_node, sub_node)) if not dataframe.loc[dataframe.topic == sub_node].empty: if sub_node not in sub_topics: sub_topics.append(sub_node) else: # no sub nodes if(in_fork): in_fork = False continue sub_node_exists = False else: # no sub nodes if(in_fork): in_fork = False continue sub_node_exists = False # generate DAG from list of tuples graph = nx.DiGraph() graph.add_edges_from(connections) return graph def countDropped(dataframe, node_graph): mask = (dataframe['expected_count'] != 0) expected_non_zero = dataframe[mask] # for every node that has a defined period for node in expected_non_zero.node: # assume node has sub nodes by default sub_node_exists = True # search for sub nodes of current node, assume node name is topic name current_node = node # current top-level node of fork fork_topics = [] sub_topics = [] in_fork = False # pred = len(node_graph.pred[node]) # if(pred > 0): # TODO(flynneva): figure out a way to trace up the node graph # to determine if a fusion node reduces the total expected # count = expected_non_zero.expected_count.sum() # expected = count - dataframe.loc[( # (dataframe.node == node) & # (dataframe.topic == '')), # 'expected_count'].values[0] # subtract front lidar expected count due to fusion node # TODO(flynneva): figure out a better way to handle fusion nodes # expected -= dataframe.loc[( # (dataframe.node == 'FrontLidarDriver') & # (dataframe.topic == '')), # 'expected_count'].values[0] # else: # calculate dropped for current node expected = dataframe.loc[( (dataframe.node == node) & (dataframe.topic == '')), 'expected_count'].values[0] count = dataframe.loc[( (dataframe.node == current_node) & (dataframe.topic == '')), 'count'].values[0] dataframe.loc[( (dataframe.node == current_node) & (dataframe.topic == '')), 'dropped'] = abs(expected - count) while sub_node_exists: if(len(fork_topics) != 0 and not in_fork): # fork topic exists current_node = fork_topics.pop(0) in_fork = True if(len(sub_topics) != 0): # sub topics still exist current_node = sub_topics.pop(0) sub_node_df = dataframe.loc[ ((dataframe.topic == current_node) & (dataframe.expected_count == 0))] if not sub_node_df.empty: # node has sub node(s) if(sub_node_df.shape[0] > 1): # node has more than one sub node for fork in sub_node_df.node: if fork not in fork_topics: fork_topics.append(fork) for sub_node in sub_node_df.node: dataframe.loc[( (dataframe.node == sub_node) & (dataframe.topic == current_node)), 'expected_count'] = expected count = dataframe.loc[( (dataframe.node == sub_node) & (dataframe.topic == current_node)), 'count'].values[0] dataframe.loc[( (dataframe.node == sub_node) & (dataframe.topic == current_node)), 'dropped'] = abs(expected - count) if not dataframe.loc[dataframe.topic == sub_node].empty: if sub_node not in sub_topics: sub_topics.append(sub_node) else: # no sub nodes if(in_fork): in_fork = False continue sub_node_exists = False else: # no sub nodes if(in_fork): in_fork = False continue sub_node_exists = False return dataframe Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/reference_system_py/dropped_messages.py"},{"location":"Files/dropped__messages_8py/#reference_systemreference_system_pydropped_messagespy","text":"","title":"reference_system/reference_system_py/dropped_messages.py"},{"location":"Files/dropped__messages_8py/#namespaces","text":"Name reference_system_py reference_system_py::dropped_messages","title":"Namespaces"},{"location":"Files/dropped__messages_8py/#source-code","text":"# Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import random # from bokeh.layouts import layout from bokeh.models import ColumnDataSource from bokeh.models import DatetimeTickFormatter from bokeh.models.ranges import FactorRange from bokeh.models.tools import HoverTool from bokeh.models.widgets.markups import Div from bokeh.models.widgets.tables import DataTable, TableColumn from bokeh.palettes import cividis from bokeh.plotting import figure from bokeh.transform import factor_cmap try: import networkx as nx nx_available = True except ImportError: nx_available = False import numpy as np import pandas as pd def individual(data_model, size): data_dict = parseData(data_model) dropped_df = data_dict['dropped'] latency_df = data_dict['latency'] run_time = data_dict['run_time'] y = list(zip(dropped_df.node, dropped_df.topic)) latency_source = ColumnDataSource(latency_df) dropped_source = ColumnDataSource(dropped_df) dropped_source.data['y'] = y # use this for axis of figure ~0.25 of buffer max_dropped = max(dropped_df['dropped']) + 0.25 # initialize figure dropped_fig = figure( title='Dropped Messages Summary ({:.2f} s) [UNDER DEVELOPMENT]'.format(float(run_time)), y_axis_label='Callback by Node and Topic Name', x_axis_label='Dropped Messages', y_range=FactorRange(*y), x_range=(0, max_dropped), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) # add horizontal bar to figure dropped_fig.hbar( y='y', right='dropped', width=0.1, source=dropped_source, fill_color=factor_cmap( 'y', palette=cividis(dropped_df['topic'].shape[0]), factors=list(dropped_df['topic'].values.tolist()), start=1, end=2) ) dropped_fig.yaxis.major_label_orientation = 'horizontal' dropped_fig.yaxis.subgroup_label_orientation = 'horizontal' dropped_fig.yaxis.group_label_orientation = 'horizontal' # add hover tool hover = HoverTool() hover.tooltips = [ ('Callback (Node and Topic)', '@node @topic'), ('Dropped', '@dropped'), ('Expected', '@expected_count'), ('Received', '@count') ] dropped_fig.add_tools(hover) # add dropped messages table dropped_summary = dropped_df.describe().T.reset_index() columns = [TableColumn(field=col, title=col) for col in dropped_summary] dropped_table_title = Div( text='<b>Dropped Messages Summary Table [UNDER DEVELOPMENT]</b>', width=1000, height=10 ) dropped_table = [ dropped_table_title, DataTable( columns=columns, source=ColumnDataSource(dropped_summary), margin=(10, 10, 10, 10), height=150, width=size)] # add latency plot latency_fig = figure( title='Latency From Front Lidar to Collision Estimator [UNDER DEVELOPMENT]', x_axis_label='Time', y_axis_label='Latency to Object Collision Estimator (ms)', plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) latency_fig.line( x='timestamp', y='latency', source=latency_source, line_width=2 ) latency_fig.xaxis[0].formatter = DatetimeTickFormatter(seconds=['%Ss']) # add latency table latency_summary = latency_df.describe().T.reset_index() columns = [TableColumn(field=col, title=col) for col in latency_summary] latency_table_title = Div( text='<b>Latency Summary Table</b>', width=1000, height=10 ) latency_table = [ latency_table_title, DataTable( columns=columns, source=ColumnDataSource(latency_summary), margin=(10, 10, 10, 10), height=75, width=size)] return [ [dropped_table], [dropped_fig], [latency_table], [latency_fig] ] def parseData(data_model): callback_symbols = data_model.get_callback_symbols() colors = [] # Adds random colors for each callback color_i = 0 earliest_date = None latest_date = None dropped_data = [] front_lidar_data = pd.DataFrame() object_collision_data = pd.DataFrame() for obj, symbol in callback_symbols.items(): callback_df = data_model.get_callback_durations(obj) # get node information and filter out internal subscriptions owner_info = data_model.get_callback_owner_info(obj) if owner_info is not None: if '/parameter_events' in owner_info: continue period = 0.0 if 'period' in owner_info: # assume in milliseconds so convert to seconds period = float(owner_info[ owner_info.find('period: ') + len('period: '):owner_info.rfind(' ')]) / 1000 if 'FrontLidarDriver' in owner_info and 'Timer' in owner_info: front_lidar_data = callback_df if 'ObjectCollisionEstimator' in owner_info: object_collision_data = callback_df # add color to list if needed if(len(colors) <= color_i): colors.append('#%06X' % random.randint(0, 256**3-1)) # get human readable name of callback substr = 'node: ' index = str.find(owner_info, substr) if index >= 0: index += len(substr) node = owner_info[index:(str.find(owner_info, ','))] substr = 'topic: /' index = str.find(owner_info, substr) if index >= 0: index += len(substr) topic = owner_info[index:] else: topic = '' # get first and last timestamp of data thefirstdate = callback_df.loc[:, 'timestamp'].iloc[0] if earliest_date is None: earliest_date = thefirstdate elif earliest_date is not None and thefirstdate <= earliest_date: earliest_date = thefirstdate thelastdate = callback_df.loc[:, 'timestamp'].iloc[len(callback_df)-1] if latest_date is None: latest_date = thelastdate elif latest_date is not None and thelastdate >= latest_date: latest_date = thelastdate # add name of callback and count to list dropped_data.append( [str(node), str(topic), float(len(callback_df)), period, 0.0, 0.0, colors[color_i]]) color_i += 1 front_lidar_data = front_lidar_data.reset_index(drop=True) object_collision_data = object_collision_data.reset_index(drop=True) # ensure dataframes are same length for latency calc, drop extra lidar frames extra = len(front_lidar_data) - len(object_collision_data) if(extra > 0): front_lidar_data.drop(front_lidar_data.tail(extra).index, inplace=True) latency = object_collision_data['timestamp'] - front_lidar_data['timestamp'] dropped_df = pd.DataFrame( dropped_data, columns=['node', 'topic', 'count', 'period', 'dropped', 'expected_count', 'color']) latency_df = pd.DataFrame( {'index': range(0, len(latency)), 'latency': latency, 'timestamp': front_lidar_data['timestamp']}) # sort values by node and topic dropped_df = dropped_df.sort_values(by=['node', 'topic']) # calculate run time approx_run_time = None if earliest_date is not None and latest_date is not None: approx_run_time = getRunTime(earliest_date, latest_date) # calculate estimated count and received count dropped_df = calcTotals(approx_run_time, dropped_df) node_graph = None if(nx_available): # generate node graph node_graph = generateNodeGraph(dropped_df) # count expected and dropped messages dropped_df = countDropped(dropped_df, node_graph) # prepare output data_dict = { 'dropped': dropped_df, 'latency': latency_df, 'node_graph': node_graph, 'start': earliest_date, 'end': latest_date, 'run_time': approx_run_time, } return data_dict def getRunTime(start, end): # calculate run time in seconds for experiment return (end - start).total_seconds() def calcTotals(run_time, dataframe): # calculate expected counts for each period mask = (dataframe['period'] != 0) period_non_zero = dataframe[mask] dataframe.loc[mask, 'expected_count'] = (run_time / period_non_zero['period']).apply(np.floor) return dataframe def generateNodeGraph(dataframe): connections = [] # for every node that has a defined period for node in dataframe.node: # assume node has sub nodes by default sub_node_exists = True # search for sub nodes of current node, assume node name is topic name current_node = node # current top-level node of fork fork_topics = [] sub_topics = [] in_fork = False while sub_node_exists: if(len(fork_topics) != 0 and not in_fork): # fork topic exists current_node = fork_topics.pop(0) in_fork = True if(len(sub_topics) != 0): # sub topics still exist current_node = sub_topics.pop(0) sub_node_df = dataframe.loc[ ((dataframe.topic == current_node) & (dataframe.expected_count == 0))] if not sub_node_df.empty: # node has sub node(s) if(sub_node_df.shape[0] > 1): # node has more than one sub node for fork in sub_node_df.node: if fork not in fork_topics: fork_topics.append(fork) for sub_node in sub_node_df.node: # add to list of tuples connections.append((current_node, sub_node)) if not dataframe.loc[dataframe.topic == sub_node].empty: if sub_node not in sub_topics: sub_topics.append(sub_node) else: # no sub nodes if(in_fork): in_fork = False continue sub_node_exists = False else: # no sub nodes if(in_fork): in_fork = False continue sub_node_exists = False # generate DAG from list of tuples graph = nx.DiGraph() graph.add_edges_from(connections) return graph def countDropped(dataframe, node_graph): mask = (dataframe['expected_count'] != 0) expected_non_zero = dataframe[mask] # for every node that has a defined period for node in expected_non_zero.node: # assume node has sub nodes by default sub_node_exists = True # search for sub nodes of current node, assume node name is topic name current_node = node # current top-level node of fork fork_topics = [] sub_topics = [] in_fork = False # pred = len(node_graph.pred[node]) # if(pred > 0): # TODO(flynneva): figure out a way to trace up the node graph # to determine if a fusion node reduces the total expected # count = expected_non_zero.expected_count.sum() # expected = count - dataframe.loc[( # (dataframe.node == node) & # (dataframe.topic == '')), # 'expected_count'].values[0] # subtract front lidar expected count due to fusion node # TODO(flynneva): figure out a better way to handle fusion nodes # expected -= dataframe.loc[( # (dataframe.node == 'FrontLidarDriver') & # (dataframe.topic == '')), # 'expected_count'].values[0] # else: # calculate dropped for current node expected = dataframe.loc[( (dataframe.node == node) & (dataframe.topic == '')), 'expected_count'].values[0] count = dataframe.loc[( (dataframe.node == current_node) & (dataframe.topic == '')), 'count'].values[0] dataframe.loc[( (dataframe.node == current_node) & (dataframe.topic == '')), 'dropped'] = abs(expected - count) while sub_node_exists: if(len(fork_topics) != 0 and not in_fork): # fork topic exists current_node = fork_topics.pop(0) in_fork = True if(len(sub_topics) != 0): # sub topics still exist current_node = sub_topics.pop(0) sub_node_df = dataframe.loc[ ((dataframe.topic == current_node) & (dataframe.expected_count == 0))] if not sub_node_df.empty: # node has sub node(s) if(sub_node_df.shape[0] > 1): # node has more than one sub node for fork in sub_node_df.node: if fork not in fork_topics: fork_topics.append(fork) for sub_node in sub_node_df.node: dataframe.loc[( (dataframe.node == sub_node) & (dataframe.topic == current_node)), 'expected_count'] = expected count = dataframe.loc[( (dataframe.node == sub_node) & (dataframe.topic == current_node)), 'count'].values[0] dataframe.loc[( (dataframe.node == sub_node) & (dataframe.topic == current_node)), 'dropped'] = abs(expected - count) if not dataframe.loc[dataframe.topic == sub_node].empty: if sub_node not in sub_topics: sub_topics.append(sub_node) else: # no sub nodes if(in_fork): in_fork = False continue sub_node_exists = False else: # no sub nodes if(in_fork): in_fork = False continue sub_node_exists = False return dataframe Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/fusion_8hpp/","text":"reference_system/include/reference_system/nodes/rclcpp/fusion.hpp Namespaces Name nodes nodes::rclcpp_system Classes Name class nodes::rclcpp_system::Fusion Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__RCLCPP__FUSION_HPP_ #define REFERENCE_SYSTEM__NODES__RCLCPP__FUSION_HPP_ #include <chrono> #include <string> #include <utility> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/msg_types.hpp\" #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/number_cruncher.hpp\" #include \"reference_system/sample_management.hpp\" namespace nodes { namespace rclcpp_system { class Fusion : public rclcpp::Node { public: explicit Fusion(const FusionSettings & settings) : Node(settings.node_name), number_crunch_limit_(settings.number_crunch_limit) { subscriptions_[0].subscription = this->create_subscription<message_t>( settings.input_0, 1, [this](const message_t::SharedPtr msg) {input_callback(0U, msg);}); subscriptions_[1].subscription = this->create_subscription<message_t>( settings.input_1, 1, [this](const message_t::SharedPtr msg) {input_callback(1U, msg);}); publisher_ = this->create_publisher<message_t>(settings.output_topic, 1); } private: void input_callback( const uint64_t input_number, const message_t::SharedPtr input_message) { uint64_t timestamp = now_as_int(); subscriptions_[input_number].cache = input_message; // only process and publish when we can perform an actual fusion, this means // we have received a sample from each subscription if (!subscriptions_[0].cache || !subscriptions_[1].cache) { return; } auto number_cruncher_result = number_cruncher(number_crunch_limit_); auto output_message = publisher_->borrow_loaned_message(); uint32_t missed_samples = get_missed_samples_and_update_seq_nr( subscriptions_[0].cache, subscriptions_[0].sequence_number) + get_missed_samples_and_update_seq_nr( subscriptions_[1].cache, subscriptions_[1].sequence_number); output_message.get().size = 0; merge_history_into_sample(output_message.get(), subscriptions_[0].cache); merge_history_into_sample(output_message.get(), subscriptions_[1].cache); set_sample( this->get_name(), sequence_number_++, missed_samples, timestamp, output_message.get()); output_message.get().data[0] = number_cruncher_result; publisher_->publish(std::move(output_message)); subscriptions_[0].cache.reset(); subscriptions_[1].cache.reset(); } private: struct subscription_t { rclcpp::Subscription<message_t>::SharedPtr subscription; uint32_t sequence_number = 0; message_t::SharedPtr cache; }; rclcpp::Publisher<message_t>::SharedPtr publisher_; subscription_t subscriptions_[2]; uint64_t number_crunch_limit_; uint32_t sequence_number_ = 0; }; } // namespace rclcpp_system } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__RCLCPP__FUSION_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/include/reference_system/nodes/rclcpp/fusion.hpp"},{"location":"Files/fusion_8hpp/#reference_systemincludereference_systemnodesrclcppfusionhpp","text":"","title":"reference_system/include/reference_system/nodes/rclcpp/fusion.hpp"},{"location":"Files/fusion_8hpp/#namespaces","text":"Name nodes nodes::rclcpp_system","title":"Namespaces"},{"location":"Files/fusion_8hpp/#classes","text":"Name class nodes::rclcpp_system::Fusion","title":"Classes"},{"location":"Files/fusion_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__RCLCPP__FUSION_HPP_ #define REFERENCE_SYSTEM__NODES__RCLCPP__FUSION_HPP_ #include <chrono> #include <string> #include <utility> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/msg_types.hpp\" #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/number_cruncher.hpp\" #include \"reference_system/sample_management.hpp\" namespace nodes { namespace rclcpp_system { class Fusion : public rclcpp::Node { public: explicit Fusion(const FusionSettings & settings) : Node(settings.node_name), number_crunch_limit_(settings.number_crunch_limit) { subscriptions_[0].subscription = this->create_subscription<message_t>( settings.input_0, 1, [this](const message_t::SharedPtr msg) {input_callback(0U, msg);}); subscriptions_[1].subscription = this->create_subscription<message_t>( settings.input_1, 1, [this](const message_t::SharedPtr msg) {input_callback(1U, msg);}); publisher_ = this->create_publisher<message_t>(settings.output_topic, 1); } private: void input_callback( const uint64_t input_number, const message_t::SharedPtr input_message) { uint64_t timestamp = now_as_int(); subscriptions_[input_number].cache = input_message; // only process and publish when we can perform an actual fusion, this means // we have received a sample from each subscription if (!subscriptions_[0].cache || !subscriptions_[1].cache) { return; } auto number_cruncher_result = number_cruncher(number_crunch_limit_); auto output_message = publisher_->borrow_loaned_message(); uint32_t missed_samples = get_missed_samples_and_update_seq_nr( subscriptions_[0].cache, subscriptions_[0].sequence_number) + get_missed_samples_and_update_seq_nr( subscriptions_[1].cache, subscriptions_[1].sequence_number); output_message.get().size = 0; merge_history_into_sample(output_message.get(), subscriptions_[0].cache); merge_history_into_sample(output_message.get(), subscriptions_[1].cache); set_sample( this->get_name(), sequence_number_++, missed_samples, timestamp, output_message.get()); output_message.get().data[0] = number_cruncher_result; publisher_->publish(std::move(output_message)); subscriptions_[0].cache.reset(); subscriptions_[1].cache.reset(); } private: struct subscription_t { rclcpp::Subscription<message_t>::SharedPtr subscription; uint32_t sequence_number = 0; message_t::SharedPtr cache; }; rclcpp::Publisher<message_t>::SharedPtr publisher_; subscription_t subscriptions_[2]; uint64_t number_crunch_limit_; uint32_t sequence_number_ = 0; }; } // namespace rclcpp_system } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__RCLCPP__FUSION_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/gtest__main_8cpp/","text":"reference_system/test/gtest_main.cpp Functions Name int main (int argc, char * argv[]) Functions Documentation function main int main( int argc, char * argv[] ) Source code // Copyright 2022 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include \"gtest/gtest.h\" #include <rclcpp/rclcpp.hpp> int main(int argc, char * argv[]) { ::testing::InitGoogleTest(&argc, argv); return RUN_ALL_TESTS(); } Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/test/gtest_main.cpp"},{"location":"Files/gtest__main_8cpp/#reference_systemtestgtest_maincpp","text":"","title":"reference_system/test/gtest_main.cpp"},{"location":"Files/gtest__main_8cpp/#functions","text":"Name int main (int argc, char * argv[])","title":"Functions"},{"location":"Files/gtest__main_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/gtest__main_8cpp/#function-main","text":"int main( int argc, char * argv[] )","title":"function main"},{"location":"Files/gtest__main_8cpp/#source-code","text":"// Copyright 2022 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include \"gtest/gtest.h\" #include <rclcpp/rclcpp.hpp> int main(int argc, char * argv[]) { ::testing::InitGoogleTest(&argc, argv); return RUN_ALL_TESTS(); } Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/intersection_8hpp/","text":"reference_system/include/reference_system/nodes/rclcpp/intersection.hpp Namespaces Name nodes nodes::rclcpp_system Classes Name class nodes::rclcpp_system::Intersection Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__RCLCPP__INTERSECTION_HPP_ #define REFERENCE_SYSTEM__NODES__RCLCPP__INTERSECTION_HPP_ #include <chrono> #include <string> #include <utility> #include <vector> #include <memory> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/msg_types.hpp\" #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/number_cruncher.hpp\" #include \"reference_system/sample_management.hpp\" namespace nodes { namespace rclcpp_system { class Intersection : public rclcpp::Node { public: explicit Intersection(const IntersectionSettings & settings) : Node(settings.node_name) { for (auto & connection : settings.connections) { rclcpp::SubscriptionOptionsWithAllocator<std::allocator<void>> options; rclcpp::CallbackGroup::SharedPtr callback_group = this->create_callback_group( rclcpp::CallbackGroupType::MutuallyExclusive); options.callback_group = callback_group; connections_.emplace_back( Connection{ this->create_publisher<message_t>(connection.output_topic, 1), this->create_subscription<message_t>( connection.input_topic, 1, [this, id = connections_.size()](const message_t::SharedPtr msg) { input_callback(msg, id); }), callback_group, connection.number_crunch_limit}); } } rclcpp::CallbackGroup::SharedPtr get_callback_group_of_subscription( const std::string & input_topic) { for (auto & connection : connections_) { if (input_topic == connection.subscription->get_topic_name()) { return connection.callback_group; } } RCLCPP_FATAL(get_logger(), \"Subscription for topic '%s' not found!\", input_topic.c_str()); std::exit(1); } private: void input_callback( const message_t::SharedPtr input_message, const uint64_t id) { uint64_t timestamp = now_as_int(); auto number_cruncher_result = number_cruncher(connections_[id].number_crunch_limit); auto output_message = connections_[id].publisher->borrow_loaned_message(); output_message.get().size = 0; merge_history_into_sample(output_message.get(), input_message); uint32_t missed_samples = get_missed_samples_and_update_seq_nr( input_message, connections_[id].input_sequence_number); set_sample( this->get_name(), connections_[id].sequence_number++, missed_samples, timestamp, output_message.get()); // use result so that it is not optimizied away by some clever compiler output_message.get().data[0] = number_cruncher_result; connections_[id].publisher->publish(std::move(output_message)); } private: struct Connection { rclcpp::Publisher<message_t>::SharedPtr publisher; rclcpp::Subscription<message_t>::SharedPtr subscription; rclcpp::CallbackGroup::SharedPtr callback_group; uint64_t number_crunch_limit; uint32_t sequence_number = 0; uint32_t input_sequence_number = 0; }; std::vector<Connection> connections_; }; } // namespace rclcpp_system } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__RCLCPP__INTERSECTION_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/include/reference_system/nodes/rclcpp/intersection.hpp"},{"location":"Files/intersection_8hpp/#reference_systemincludereference_systemnodesrclcppintersectionhpp","text":"","title":"reference_system/include/reference_system/nodes/rclcpp/intersection.hpp"},{"location":"Files/intersection_8hpp/#namespaces","text":"Name nodes nodes::rclcpp_system","title":"Namespaces"},{"location":"Files/intersection_8hpp/#classes","text":"Name class nodes::rclcpp_system::Intersection","title":"Classes"},{"location":"Files/intersection_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__RCLCPP__INTERSECTION_HPP_ #define REFERENCE_SYSTEM__NODES__RCLCPP__INTERSECTION_HPP_ #include <chrono> #include <string> #include <utility> #include <vector> #include <memory> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/msg_types.hpp\" #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/number_cruncher.hpp\" #include \"reference_system/sample_management.hpp\" namespace nodes { namespace rclcpp_system { class Intersection : public rclcpp::Node { public: explicit Intersection(const IntersectionSettings & settings) : Node(settings.node_name) { for (auto & connection : settings.connections) { rclcpp::SubscriptionOptionsWithAllocator<std::allocator<void>> options; rclcpp::CallbackGroup::SharedPtr callback_group = this->create_callback_group( rclcpp::CallbackGroupType::MutuallyExclusive); options.callback_group = callback_group; connections_.emplace_back( Connection{ this->create_publisher<message_t>(connection.output_topic, 1), this->create_subscription<message_t>( connection.input_topic, 1, [this, id = connections_.size()](const message_t::SharedPtr msg) { input_callback(msg, id); }), callback_group, connection.number_crunch_limit}); } } rclcpp::CallbackGroup::SharedPtr get_callback_group_of_subscription( const std::string & input_topic) { for (auto & connection : connections_) { if (input_topic == connection.subscription->get_topic_name()) { return connection.callback_group; } } RCLCPP_FATAL(get_logger(), \"Subscription for topic '%s' not found!\", input_topic.c_str()); std::exit(1); } private: void input_callback( const message_t::SharedPtr input_message, const uint64_t id) { uint64_t timestamp = now_as_int(); auto number_cruncher_result = number_cruncher(connections_[id].number_crunch_limit); auto output_message = connections_[id].publisher->borrow_loaned_message(); output_message.get().size = 0; merge_history_into_sample(output_message.get(), input_message); uint32_t missed_samples = get_missed_samples_and_update_seq_nr( input_message, connections_[id].input_sequence_number); set_sample( this->get_name(), connections_[id].sequence_number++, missed_samples, timestamp, output_message.get()); // use result so that it is not optimizied away by some clever compiler output_message.get().data[0] = number_cruncher_result; connections_[id].publisher->publish(std::move(output_message)); } private: struct Connection { rclcpp::Publisher<message_t>::SharedPtr publisher; rclcpp::Subscription<message_t>::SharedPtr subscription; rclcpp::CallbackGroup::SharedPtr callback_group; uint64_t number_crunch_limit; uint32_t sequence_number = 0; uint32_t input_sequence_number = 0; }; std::vector<Connection> connections_; }; } // namespace rclcpp_system } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__RCLCPP__INTERSECTION_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/memory__usage_8py/","text":"reference_system/reference_system_py/memory_usage.py Namespaces Name reference_system_py reference_system_py::memory_usage Source code # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import os import re from bokeh.models import ColumnDataSource from bokeh.models.axes import LinearAxis from bokeh.models.ranges import FactorRange, Range1d from bokeh.models.tools import HoverTool from bokeh.models.widgets.markups import Div from bokeh.models.widgets.tables import DataTable, TableColumn from bokeh.palettes import cividis from bokeh.plotting import figure from bokeh.transform import factor_cmap import pandas as pd from .constants import SIZE_AXIS_LABEL, SIZE_MAJOR_LABEL, SIZE_TITLE from .constants import SIZE_TABLE_ROW, SIZE_TABLE_WIDTH from .plot_utils import plot_barplot def summary_from_directories(dirs, duration, size): data = [] x = [] raw_df = [] summary_data = { 'exe': [], 'rmw': [], 'type': [], 'low': [], 'mean': [], 'high': [], 'std_dev': [], 'box_top': [], 'box_bottom': [] } dir_re = re.compile('([0-9]+)s/(rmw_.*)/([^/]+)$') for idx, directory in enumerate(dirs): match = dir_re.search(directory) if not match: raise ValueError(f'Given directory {directory} does not match naming requirements') extracted_duration, rmw, exe = match.groups() if int(extracted_duration) != duration: raise ValueError( f'Given directory {directory} does not have expected duration {duration}') fpath = directory + '/memory_log.txt' # open datafile and parse it into a usable structure data.append(open(fpath).read().splitlines()[1:]) data[idx] = [[float(element) for element in line.split()] for line in data[idx]] # add raw data to dataframe raw_df.append( pd.DataFrame( data=data[idx], columns=[ 'time', 'cpu', 'real', 'virtual'])) # calculate statics from raw data df_summary = raw_df[idx].describe().T.reset_index() # add data to dictionary for index, row in df_summary.iterrows(): summary_data['exe'].append(exe) summary_data['rmw'].append(rmw) summary_data['type'].append(row['index']) summary_data['low'].append(row['min']) summary_data['mean'].append(row['mean']) summary_data['high'].append(row['max']) summary_data['box_top'].append(row['mean'] + row['std']) summary_data['box_bottom'].append(row['mean'] - row['std']) summary_data['std_dev'].append(row['std']) df = pd.DataFrame.from_records( summary_data, columns=[ 'exe', 'rmw', 'type', 'low', 'mean', 'high', 'box_top', 'box_bottom', 'std_dev']) # sort by exe and rmw df = df.sort_values(['exe', 'rmw'], ascending=True) rmws = list(df.rmw.drop_duplicates()) x = [tuple(x) for x in df[['rmw', 'exe']].drop_duplicates().to_records(index=False)] cpu = df.type == 'cpu' real = df.type == 'real' virtual = df.type == 'virtual' cpu_source = ColumnDataSource(df[cpu]) real_source = ColumnDataSource(df[real]) virtual_source = ColumnDataSource(df[virtual]) # add exe and rmw list of tuples for x axis cpu_source.data['x'] = x real_source.data['x'] = x virtual_source.data['x'] = x fill_color = factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=0, end=1) # initialize cpu figure cpu_fig = figure( title='CPU Usage Over Time ' + str(duration) + 's', x_axis_label=f'Executors (with RMW)', y_axis_label='CPU (%)', x_range=FactorRange(*x), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) plot_barplot(cpu_fig, cpu_source, fill_color=fill_color) # initialize real memory figure real_fig = figure( title='Real Memory Usage Over Time ' + str(duration) + 's', x_axis_label=f'Executors (with RMW)', y_axis_label='Real Memory Usage (MB)', x_range=FactorRange(*x), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) plot_barplot(real_fig, real_source, fill_color=fill_color) # initialize virtual memory figure virtual_fig = figure( title='Virtual Memory Usage Over Time ' + str(duration) + 's', x_axis_label=f'Executors (with RMW)', y_axis_label='Virtual Memory Usage (MB)', x_range=FactorRange(*x), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) plot_barplot(virtual_fig, virtual_source, fill_color=fill_color) # add cpu usage table columns = [TableColumn(field=field, title=title) for field, title in [('exe', 'Benchmark'), ('rmw', 'RMW'), ('low', 'Min'), ('mean', 'Mean'), ('high', 'Max'), ('std_dev', 'Std. Dev.')]] cpu_table_title = Div( text='<b>CPU Usage Statistics ' + str(duration) + 's</b>', width=SIZE_TABLE_WIDTH, height=SIZE_TABLE_ROW ) cpu_table = [ cpu_table_title, DataTable( columns=columns, source=ColumnDataSource(df[cpu].round(decimals=2)), autosize_mode='fit_viewport', margin=(0, 10, 10, 10), height=(len(df[cpu].exe.values.tolist()) * SIZE_TABLE_ROW), width=SIZE_TABLE_WIDTH)] # add real table real_table_title = Div( text='<b>Real Memory Usage Statistics ' + str(duration) + 's</b>', width=SIZE_TABLE_WIDTH, height=SIZE_TABLE_ROW ) real_table = [ real_table_title, DataTable( columns=columns, source=ColumnDataSource(df[real]), margin=(0, 10, 10, 10), height=(len(df[real].exe.values.tolist()) * SIZE_TABLE_ROW), width=SIZE_TABLE_WIDTH)] # add virtual table virtual_table_title = Div( text='<b>Virtual Memory Usage Statistics ' + str(duration) + 's</b>', width=SIZE_TABLE_WIDTH, height=SIZE_TABLE_ROW ) virtual_table = [ virtual_table_title, DataTable( columns=columns, source=ColumnDataSource(df[virtual]), margin=(0, 10, 10, 10), height=(len(df[virtual].exe.values.tolist()) * SIZE_TABLE_ROW), width=SIZE_TABLE_WIDTH)] # add figures and tables to output memory_figs = [ [cpu_table], [cpu_fig], [real_table], [real_fig], [virtual_table], [virtual_fig] ] return memory_figs def individual(path, size): basename = os.path.basename(path)[:-4] # open file data = open(path).read().splitlines()[1:] data = [[float(element) for element in line.split()] for line in data] df = pd.DataFrame(data=data, columns=['Elapsed Time', 'CPU (%)', 'Real (MB)', 'Virtual (MB)']) # add summary stats df_summary = df.describe().T.reset_index() # initialize list of figures memory = [] source = ColumnDataSource(df) # colors colors = [ '#158171', '#286f80', '#1bab78' ] # initialize raw data figure raw_data_fig = figure( title='Memory and CPU Usage Data [' + basename + ']', x_axis_label=f'Time (sec)', y_axis_label='CPU (%)', plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) # add CPU usage to figure raw_data_fig.line( x='Elapsed Time', y='CPU (%)', line_width=1, source=source, line_color=colors[0], alpha=0.8, legend_label='CPU (%)', muted_color=colors[0], muted_alpha=0.2 ) # legend attributes raw_data_fig.legend.location = 'top_right' raw_data_fig.legend.click_policy = 'hide' # add extra y ranges raw_data_fig.extra_y_ranges = { 'Real (MB)': Range1d( start=0, end=df_summary.loc[2, 'max'] + 25 ) } raw_data_fig.add_layout( LinearAxis( y_range_name='Real (MB)', axis_label='Real (MB)'), 'right' ) # add Real memory usage to figure raw_data_fig.line( x='Elapsed Time', y='Real (MB)', y_range_name='Real (MB)', line_width=1, source=source, line_color=colors[1], alpha=0.8, legend_label='Real (MB)', muted_color=colors[1], muted_alpha=0.2 ) raw_data_fig.title.text_font_size = SIZE_TITLE raw_data_fig.xaxis.axis_label_text_font_size = SIZE_AXIS_LABEL raw_data_fig.yaxis.axis_label_text_font_size = SIZE_AXIS_LABEL raw_data_fig.xaxis.major_label_text_font_size = SIZE_MAJOR_LABEL raw_data_fig.yaxis.major_label_text_font_size = SIZE_MAJOR_LABEL # add hover tool hover = HoverTool() hover.tooltips = [ ('CPU (%)', '@{CPU (%)}{0.00}'), ('Real (MB)', '@{Real (MB)}{0.00}'), ('Virtual (MB)', '@{Virtual (MB)}{0.00}') ] raw_data_fig.add_tools(hover) # create summary table columns = [TableColumn(field=col, title=col) for col in df_summary.columns] table_title = Div( text='<b>Memory and CPU Usage Data: ' + basename + '</b>', width=1000, height=20, style={ 'font-size': SIZE_MAJOR_LABEL } ) summary_fig = [ table_title, DataTable( columns=columns, source=ColumnDataSource(df_summary), margin=(10, 10, 10, 10), height=140)] # add figure and table to output memory = [[summary_fig], [raw_data_fig]] return memory Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/reference_system_py/memory_usage.py"},{"location":"Files/memory__usage_8py/#reference_systemreference_system_pymemory_usagepy","text":"","title":"reference_system/reference_system_py/memory_usage.py"},{"location":"Files/memory__usage_8py/#namespaces","text":"Name reference_system_py reference_system_py::memory_usage","title":"Namespaces"},{"location":"Files/memory__usage_8py/#source-code","text":"# Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import os import re from bokeh.models import ColumnDataSource from bokeh.models.axes import LinearAxis from bokeh.models.ranges import FactorRange, Range1d from bokeh.models.tools import HoverTool from bokeh.models.widgets.markups import Div from bokeh.models.widgets.tables import DataTable, TableColumn from bokeh.palettes import cividis from bokeh.plotting import figure from bokeh.transform import factor_cmap import pandas as pd from .constants import SIZE_AXIS_LABEL, SIZE_MAJOR_LABEL, SIZE_TITLE from .constants import SIZE_TABLE_ROW, SIZE_TABLE_WIDTH from .plot_utils import plot_barplot def summary_from_directories(dirs, duration, size): data = [] x = [] raw_df = [] summary_data = { 'exe': [], 'rmw': [], 'type': [], 'low': [], 'mean': [], 'high': [], 'std_dev': [], 'box_top': [], 'box_bottom': [] } dir_re = re.compile('([0-9]+)s/(rmw_.*)/([^/]+)$') for idx, directory in enumerate(dirs): match = dir_re.search(directory) if not match: raise ValueError(f'Given directory {directory} does not match naming requirements') extracted_duration, rmw, exe = match.groups() if int(extracted_duration) != duration: raise ValueError( f'Given directory {directory} does not have expected duration {duration}') fpath = directory + '/memory_log.txt' # open datafile and parse it into a usable structure data.append(open(fpath).read().splitlines()[1:]) data[idx] = [[float(element) for element in line.split()] for line in data[idx]] # add raw data to dataframe raw_df.append( pd.DataFrame( data=data[idx], columns=[ 'time', 'cpu', 'real', 'virtual'])) # calculate statics from raw data df_summary = raw_df[idx].describe().T.reset_index() # add data to dictionary for index, row in df_summary.iterrows(): summary_data['exe'].append(exe) summary_data['rmw'].append(rmw) summary_data['type'].append(row['index']) summary_data['low'].append(row['min']) summary_data['mean'].append(row['mean']) summary_data['high'].append(row['max']) summary_data['box_top'].append(row['mean'] + row['std']) summary_data['box_bottom'].append(row['mean'] - row['std']) summary_data['std_dev'].append(row['std']) df = pd.DataFrame.from_records( summary_data, columns=[ 'exe', 'rmw', 'type', 'low', 'mean', 'high', 'box_top', 'box_bottom', 'std_dev']) # sort by exe and rmw df = df.sort_values(['exe', 'rmw'], ascending=True) rmws = list(df.rmw.drop_duplicates()) x = [tuple(x) for x in df[['rmw', 'exe']].drop_duplicates().to_records(index=False)] cpu = df.type == 'cpu' real = df.type == 'real' virtual = df.type == 'virtual' cpu_source = ColumnDataSource(df[cpu]) real_source = ColumnDataSource(df[real]) virtual_source = ColumnDataSource(df[virtual]) # add exe and rmw list of tuples for x axis cpu_source.data['x'] = x real_source.data['x'] = x virtual_source.data['x'] = x fill_color = factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=0, end=1) # initialize cpu figure cpu_fig = figure( title='CPU Usage Over Time ' + str(duration) + 's', x_axis_label=f'Executors (with RMW)', y_axis_label='CPU (%)', x_range=FactorRange(*x), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) plot_barplot(cpu_fig, cpu_source, fill_color=fill_color) # initialize real memory figure real_fig = figure( title='Real Memory Usage Over Time ' + str(duration) + 's', x_axis_label=f'Executors (with RMW)', y_axis_label='Real Memory Usage (MB)', x_range=FactorRange(*x), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) plot_barplot(real_fig, real_source, fill_color=fill_color) # initialize virtual memory figure virtual_fig = figure( title='Virtual Memory Usage Over Time ' + str(duration) + 's', x_axis_label=f'Executors (with RMW)', y_axis_label='Virtual Memory Usage (MB)', x_range=FactorRange(*x), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) plot_barplot(virtual_fig, virtual_source, fill_color=fill_color) # add cpu usage table columns = [TableColumn(field=field, title=title) for field, title in [('exe', 'Benchmark'), ('rmw', 'RMW'), ('low', 'Min'), ('mean', 'Mean'), ('high', 'Max'), ('std_dev', 'Std. Dev.')]] cpu_table_title = Div( text='<b>CPU Usage Statistics ' + str(duration) + 's</b>', width=SIZE_TABLE_WIDTH, height=SIZE_TABLE_ROW ) cpu_table = [ cpu_table_title, DataTable( columns=columns, source=ColumnDataSource(df[cpu].round(decimals=2)), autosize_mode='fit_viewport', margin=(0, 10, 10, 10), height=(len(df[cpu].exe.values.tolist()) * SIZE_TABLE_ROW), width=SIZE_TABLE_WIDTH)] # add real table real_table_title = Div( text='<b>Real Memory Usage Statistics ' + str(duration) + 's</b>', width=SIZE_TABLE_WIDTH, height=SIZE_TABLE_ROW ) real_table = [ real_table_title, DataTable( columns=columns, source=ColumnDataSource(df[real]), margin=(0, 10, 10, 10), height=(len(df[real].exe.values.tolist()) * SIZE_TABLE_ROW), width=SIZE_TABLE_WIDTH)] # add virtual table virtual_table_title = Div( text='<b>Virtual Memory Usage Statistics ' + str(duration) + 's</b>', width=SIZE_TABLE_WIDTH, height=SIZE_TABLE_ROW ) virtual_table = [ virtual_table_title, DataTable( columns=columns, source=ColumnDataSource(df[virtual]), margin=(0, 10, 10, 10), height=(len(df[virtual].exe.values.tolist()) * SIZE_TABLE_ROW), width=SIZE_TABLE_WIDTH)] # add figures and tables to output memory_figs = [ [cpu_table], [cpu_fig], [real_table], [real_fig], [virtual_table], [virtual_fig] ] return memory_figs def individual(path, size): basename = os.path.basename(path)[:-4] # open file data = open(path).read().splitlines()[1:] data = [[float(element) for element in line.split()] for line in data] df = pd.DataFrame(data=data, columns=['Elapsed Time', 'CPU (%)', 'Real (MB)', 'Virtual (MB)']) # add summary stats df_summary = df.describe().T.reset_index() # initialize list of figures memory = [] source = ColumnDataSource(df) # colors colors = [ '#158171', '#286f80', '#1bab78' ] # initialize raw data figure raw_data_fig = figure( title='Memory and CPU Usage Data [' + basename + ']', x_axis_label=f'Time (sec)', y_axis_label='CPU (%)', plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) # add CPU usage to figure raw_data_fig.line( x='Elapsed Time', y='CPU (%)', line_width=1, source=source, line_color=colors[0], alpha=0.8, legend_label='CPU (%)', muted_color=colors[0], muted_alpha=0.2 ) # legend attributes raw_data_fig.legend.location = 'top_right' raw_data_fig.legend.click_policy = 'hide' # add extra y ranges raw_data_fig.extra_y_ranges = { 'Real (MB)': Range1d( start=0, end=df_summary.loc[2, 'max'] + 25 ) } raw_data_fig.add_layout( LinearAxis( y_range_name='Real (MB)', axis_label='Real (MB)'), 'right' ) # add Real memory usage to figure raw_data_fig.line( x='Elapsed Time', y='Real (MB)', y_range_name='Real (MB)', line_width=1, source=source, line_color=colors[1], alpha=0.8, legend_label='Real (MB)', muted_color=colors[1], muted_alpha=0.2 ) raw_data_fig.title.text_font_size = SIZE_TITLE raw_data_fig.xaxis.axis_label_text_font_size = SIZE_AXIS_LABEL raw_data_fig.yaxis.axis_label_text_font_size = SIZE_AXIS_LABEL raw_data_fig.xaxis.major_label_text_font_size = SIZE_MAJOR_LABEL raw_data_fig.yaxis.major_label_text_font_size = SIZE_MAJOR_LABEL # add hover tool hover = HoverTool() hover.tooltips = [ ('CPU (%)', '@{CPU (%)}{0.00}'), ('Real (MB)', '@{Real (MB)}{0.00}'), ('Virtual (MB)', '@{Virtual (MB)}{0.00}') ] raw_data_fig.add_tools(hover) # create summary table columns = [TableColumn(field=col, title=col) for col in df_summary.columns] table_title = Div( text='<b>Memory and CPU Usage Data: ' + basename + '</b>', width=1000, height=20, style={ 'font-size': SIZE_MAJOR_LABEL } ) summary_fig = [ table_title, DataTable( columns=columns, source=ColumnDataSource(df_summary), margin=(10, 10, 10, 10), height=140)] # add figure and table to output memory = [[summary_fig], [raw_data_fig]] return memory Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/msg__types_8hpp/","text":"reference_system/include/reference_system/msg_types.hpp Types Name using reference_interfaces::msg::Message4kb message_t Types Documentation using message_t using message_t = reference_interfaces::msg::Message4kb; Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__MSG_TYPES_HPP_ #define REFERENCE_SYSTEM__MSG_TYPES_HPP_ #include \"reference_interfaces/msg/message4kb.hpp\" using message_t = reference_interfaces::msg::Message4kb; #endif // REFERENCE_SYSTEM__MSG_TYPES_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/include/reference_system/msg_types.hpp"},{"location":"Files/msg__types_8hpp/#reference_systemincludereference_systemmsg_typeshpp","text":"","title":"reference_system/include/reference_system/msg_types.hpp"},{"location":"Files/msg__types_8hpp/#types","text":"Name using reference_interfaces::msg::Message4kb message_t","title":"Types"},{"location":"Files/msg__types_8hpp/#types-documentation","text":"","title":"Types Documentation"},{"location":"Files/msg__types_8hpp/#using-message_t","text":"using message_t = reference_interfaces::msg::Message4kb;","title":"using message_t"},{"location":"Files/msg__types_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__MSG_TYPES_HPP_ #define REFERENCE_SYSTEM__MSG_TYPES_HPP_ #include \"reference_interfaces/msg/message4kb.hpp\" using message_t = reference_interfaces::msg::Message4kb; #endif // REFERENCE_SYSTEM__MSG_TYPES_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/number__cruncher_8hpp/","text":"reference_system/include/reference_system/number_cruncher.hpp Functions Name template <typename Tp > void escape (Tp const & value) int64_t number_cruncher (const uint64_t maximum_number) long double get_crunch_time_in_ms (const uint64_t maximum_number) Functions Documentation function escape template <typename Tp > inline void escape( Tp const & value ) function number_cruncher static inline int64_t number_cruncher( const uint64_t maximum_number ) function get_crunch_time_in_ms static inline long double get_crunch_time_in_ms( const uint64_t maximum_number ) Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NUMBER_CRUNCHER_HPP_ #define REFERENCE_SYSTEM__NUMBER_CRUNCHER_HPP_ #include <chrono> #include <cmath> #include <vector> // prevents the compiler from optimizing access to value. // Taken from http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0412r0.html template<typename Tp> inline void escape(Tp const & value) { asm volatile (\"\" : : \"g\" (value) : \"memory\"); } // Computes an expensive function (count number of primes below maximum_number) // This serves as a scalable dummy-workload for the various nodes. static inline int64_t number_cruncher(const uint64_t maximum_number) { int64_t number_of_primes = 0; uint64_t initial_value = 2; // edge case where max number is too low if (maximum_number <= initial_value) { return 2; } for (uint64_t i = initial_value; i <= maximum_number; ++i) { bool is_prime = true; for (uint64_t n = initial_value; n < i; ++n) { if (i % n == 0) { is_prime = false; break; } } escape(is_prime); if (is_prime) { // number_of_primes cannot overflow since there are fewer than 2**63 // primes in [0, 2**64). ++number_of_primes; } } return number_of_primes; } // Returns the time (in ms of wall-clock time) needed to compute number_cruncher(maximum_number) static inline long double get_crunch_time_in_ms(const uint64_t maximum_number) { auto start = std::chrono::system_clock::now(); number_cruncher(maximum_number); auto stop = std::chrono::system_clock::now(); using milliseconds_ld = std::chrono::duration<long double, std::milli>; return milliseconds_ld(stop - start).count(); } #endif // REFERENCE_SYSTEM__NUMBER_CRUNCHER_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/include/reference_system/number_cruncher.hpp"},{"location":"Files/number__cruncher_8hpp/#reference_systemincludereference_systemnumber_cruncherhpp","text":"","title":"reference_system/include/reference_system/number_cruncher.hpp"},{"location":"Files/number__cruncher_8hpp/#functions","text":"Name template <typename Tp > void escape (Tp const & value) int64_t number_cruncher (const uint64_t maximum_number) long double get_crunch_time_in_ms (const uint64_t maximum_number)","title":"Functions"},{"location":"Files/number__cruncher_8hpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/number__cruncher_8hpp/#function-escape","text":"template <typename Tp > inline void escape( Tp const & value )","title":"function escape"},{"location":"Files/number__cruncher_8hpp/#function-number_cruncher","text":"static inline int64_t number_cruncher( const uint64_t maximum_number )","title":"function number_cruncher"},{"location":"Files/number__cruncher_8hpp/#function-get_crunch_time_in_ms","text":"static inline long double get_crunch_time_in_ms( const uint64_t maximum_number )","title":"function get_crunch_time_in_ms"},{"location":"Files/number__cruncher_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NUMBER_CRUNCHER_HPP_ #define REFERENCE_SYSTEM__NUMBER_CRUNCHER_HPP_ #include <chrono> #include <cmath> #include <vector> // prevents the compiler from optimizing access to value. // Taken from http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0412r0.html template<typename Tp> inline void escape(Tp const & value) { asm volatile (\"\" : : \"g\" (value) : \"memory\"); } // Computes an expensive function (count number of primes below maximum_number) // This serves as a scalable dummy-workload for the various nodes. static inline int64_t number_cruncher(const uint64_t maximum_number) { int64_t number_of_primes = 0; uint64_t initial_value = 2; // edge case where max number is too low if (maximum_number <= initial_value) { return 2; } for (uint64_t i = initial_value; i <= maximum_number; ++i) { bool is_prime = true; for (uint64_t n = initial_value; n < i; ++n) { if (i % n == 0) { is_prime = false; break; } } escape(is_prime); if (is_prime) { // number_of_primes cannot overflow since there are fewer than 2**63 // primes in [0, 2**64). ++number_of_primes; } } return number_of_primes; } // Returns the time (in ms of wall-clock time) needed to compute number_cruncher(maximum_number) static inline long double get_crunch_time_in_ms(const uint64_t maximum_number) { auto start = std::chrono::system_clock::now(); number_cruncher(maximum_number); auto stop = std::chrono::system_clock::now(); using milliseconds_ld = std::chrono::duration<long double, std::milli>; return milliseconds_ld(stop - start).count(); } #endif // REFERENCE_SYSTEM__NUMBER_CRUNCHER_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/number__cruncher__benchmark_8cpp/","text":"autoware_reference_system/src/number_cruncher_benchmark.cpp Functions Name int main () Functions Documentation function main int main() Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // #include \"reference_system/number_cruncher.hpp\" #include <iostream> #include <iomanip> int main() { long double crunch_time = 0.0; std::cout << \"maximum_number run time\" << std::endl; for (uint64_t i = 64; crunch_time < 1000.0; i *= 2) { crunch_time = get_crunch_time_in_ms(i); std::cout << std::setfill(' ') << std::setw(12) << i << \" \" << crunch_time << \"ms\" << std::endl; } } Updated on 2022-04-30 at 21:32:33 +0000","title":"autoware_reference_system/src/number_cruncher_benchmark.cpp"},{"location":"Files/number__cruncher__benchmark_8cpp/#autoware_reference_systemsrcnumber_cruncher_benchmarkcpp","text":"","title":"autoware_reference_system/src/number_cruncher_benchmark.cpp"},{"location":"Files/number__cruncher__benchmark_8cpp/#functions","text":"Name int main ()","title":"Functions"},{"location":"Files/number__cruncher__benchmark_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/number__cruncher__benchmark_8cpp/#function-main","text":"int main()","title":"function main"},{"location":"Files/number__cruncher__benchmark_8cpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // #include \"reference_system/number_cruncher.hpp\" #include <iostream> #include <iomanip> int main() { long double crunch_time = 0.0; std::cout << \"maximum_number run time\" << std::endl; for (uint64_t i = 64; crunch_time < 1000.0; i *= 2) { crunch_time = get_crunch_time_in_ms(i); std::cout << std::setfill(' ') << std::setw(12) << i << \" \" << crunch_time << \"ms\" << std::endl; } } Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/plot__utils_8py/","text":"reference_system/reference_system_py/plot_utils.py Namespaces Name reference_system_py reference_system_py::plot_utils Source code # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import math from bokeh.models.tools import HoverTool from .constants import SIZE_AXIS_LABEL, SIZE_CATEGORY_LABEL, SIZE_MAJOR_LABEL, SIZE_TITLE def plot_barplot(fig, data_source, fill_color='gray'): \"\"\" Plot a barplot in `fig` using data from `data_source`. `data_source` is assumed to contain the following columns: - 'x' contains the x-coordinate - 'low' and 'high' contain the minimum/maximum - 'box_bottom' and 'box_top' contain the beginning/end of the box (mean +- stddev) - 'mean' contains the mean value \"\"\" fig.segment( 'x', 'box_bottom', 'x', 'low', color='black', line_width=2, source=data_source) fig.segment( 'x', 'box_top', 'x', 'high', color='black', line_width=2, source=data_source) fig.vbar( width=0.2, x='x', top='box_top', bottom='box_bottom', line_color='black', line_width=1, source=data_source, fill_color=fill_color ) fig.scatter( size=25, x='x', y='high', source=data_source, line_color='black', line_width=2, marker='dash', fill_color=fill_color ) fig.scatter( size=25, x='x', y='low', source=data_source, line_color='black', line_width=2, marker='dash', fill_color=fill_color ) fig.y_range.start = 0 fig.x_range.range_padding = 0.1 fig.title.text_font_size = SIZE_TITLE fig.xaxis.axis_label_text_font_size = SIZE_AXIS_LABEL fig.yaxis.axis_label_text_font_size = SIZE_AXIS_LABEL fig.yaxis.major_label_text_font_size = SIZE_MAJOR_LABEL fig.below[0].group_text_font_size = SIZE_CATEGORY_LABEL fig.below[0].major_label_text_font_size = SIZE_MAJOR_LABEL fig.xaxis.major_label_orientation = math.pi/16 yaxis_label = fig.yaxis[0].axis_label # Add hover tool hover = HoverTool() hover.tooltips = [ ('Benchmark', '@{exe} [@{rmw}]'), ('Average '+yaxis_label, '@{mean}{0.00}'), ('Minimum '+yaxis_label, '@{low}{0.00}'), ('Maximum '+yaxis_label, '@{high}{0.00}'), ] fig.add_tools(hover) Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/reference_system_py/plot_utils.py"},{"location":"Files/plot__utils_8py/#reference_systemreference_system_pyplot_utilspy","text":"","title":"reference_system/reference_system_py/plot_utils.py"},{"location":"Files/plot__utils_8py/#namespaces","text":"Name reference_system_py reference_system_py::plot_utils","title":"Namespaces"},{"location":"Files/plot__utils_8py/#source-code","text":"# Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import math from bokeh.models.tools import HoverTool from .constants import SIZE_AXIS_LABEL, SIZE_CATEGORY_LABEL, SIZE_MAJOR_LABEL, SIZE_TITLE def plot_barplot(fig, data_source, fill_color='gray'): \"\"\" Plot a barplot in `fig` using data from `data_source`. `data_source` is assumed to contain the following columns: - 'x' contains the x-coordinate - 'low' and 'high' contain the minimum/maximum - 'box_bottom' and 'box_top' contain the beginning/end of the box (mean +- stddev) - 'mean' contains the mean value \"\"\" fig.segment( 'x', 'box_bottom', 'x', 'low', color='black', line_width=2, source=data_source) fig.segment( 'x', 'box_top', 'x', 'high', color='black', line_width=2, source=data_source) fig.vbar( width=0.2, x='x', top='box_top', bottom='box_bottom', line_color='black', line_width=1, source=data_source, fill_color=fill_color ) fig.scatter( size=25, x='x', y='high', source=data_source, line_color='black', line_width=2, marker='dash', fill_color=fill_color ) fig.scatter( size=25, x='x', y='low', source=data_source, line_color='black', line_width=2, marker='dash', fill_color=fill_color ) fig.y_range.start = 0 fig.x_range.range_padding = 0.1 fig.title.text_font_size = SIZE_TITLE fig.xaxis.axis_label_text_font_size = SIZE_AXIS_LABEL fig.yaxis.axis_label_text_font_size = SIZE_AXIS_LABEL fig.yaxis.major_label_text_font_size = SIZE_MAJOR_LABEL fig.below[0].group_text_font_size = SIZE_CATEGORY_LABEL fig.below[0].major_label_text_font_size = SIZE_MAJOR_LABEL fig.xaxis.major_label_orientation = math.pi/16 yaxis_label = fig.yaxis[0].axis_label # Add hover tool hover = HoverTool() hover.tooltips = [ ('Benchmark', '@{exe} [@{rmw}]'), ('Average '+yaxis_label, '@{mean}{0.00}'), ('Minimum '+yaxis_label, '@{low}{0.00}'), ('Maximum '+yaxis_label, '@{high}{0.00}'), ] fig.add_tools(hover) Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/priorities_8cpp/","text":"autoware_reference_system/src/priorities.cpp Attributes Name const std::set< std::string > hotpath_nodes const std::set< std::string > planner_nodes Attributes Documentation variable hotpath_nodes const std::set< std::string > hotpath_nodes = {\"FrontLidarDriver\", \"PointsTransformerFront\", \"RearLidarDriver\", \"PointsTransformerRear\", \"PointCloudFusion\", \"RayGroundFilter\", \"EuclideanClusterDetector\", \"ObjectCollisionEstimator\"}; variable planner_nodes const std::set< std::string > planner_nodes {\"BehaviorPlanner\"}; Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include \"autoware_reference_system/priorities.hpp\" #include <string> #include <set> const std::set<std::string> hotpath_nodes = {\"FrontLidarDriver\", \"PointsTransformerFront\", \"RearLidarDriver\", \"PointsTransformerRear\", \"PointCloudFusion\", \"RayGroundFilter\", \"EuclideanClusterDetector\", \"ObjectCollisionEstimator\"}; const std::set<std::string> planner_nodes {\"BehaviorPlanner\"}; Updated on 2022-04-30 at 21:32:33 +0000","title":"autoware_reference_system/src/priorities.cpp"},{"location":"Files/priorities_8cpp/#autoware_reference_systemsrcprioritiescpp","text":"","title":"autoware_reference_system/src/priorities.cpp"},{"location":"Files/priorities_8cpp/#attributes","text":"Name const std::set< std::string > hotpath_nodes const std::set< std::string > planner_nodes","title":"Attributes"},{"location":"Files/priorities_8cpp/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Files/priorities_8cpp/#variable-hotpath_nodes","text":"const std::set< std::string > hotpath_nodes = {\"FrontLidarDriver\", \"PointsTransformerFront\", \"RearLidarDriver\", \"PointsTransformerRear\", \"PointCloudFusion\", \"RayGroundFilter\", \"EuclideanClusterDetector\", \"ObjectCollisionEstimator\"};","title":"variable hotpath_nodes"},{"location":"Files/priorities_8cpp/#variable-planner_nodes","text":"const std::set< std::string > planner_nodes {\"BehaviorPlanner\"};","title":"variable planner_nodes"},{"location":"Files/priorities_8cpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include \"autoware_reference_system/priorities.hpp\" #include <string> #include <set> const std::set<std::string> hotpath_nodes = {\"FrontLidarDriver\", \"PointsTransformerFront\", \"RearLidarDriver\", \"PointsTransformerRear\", \"PointCloudFusion\", \"RayGroundFilter\", \"EuclideanClusterDetector\", \"ObjectCollisionEstimator\"}; const std::set<std::string> planner_nodes {\"BehaviorPlanner\"}; Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/priorities_8hpp/","text":"autoware_reference_system/include/autoware_reference_system/priorities.hpp Attributes Name const std::set< std::string > hotpath_nodes const std::set< std::string > planner_nodes constexpr int hotpath_prio constexpr int planner_prio Defines Name HOTPATH_AFFINITY PLANNER_AFFINITY Attributes Documentation variable hotpath_nodes const std::set< std::string > hotpath_nodes; variable planner_nodes const std::set< std::string > planner_nodes; variable hotpath_prio constexpr int hotpath_prio = 1; variable planner_prio constexpr int planner_prio = 30; Macros Documentation define HOTPATH_AFFINITY #define HOTPATH_AFFINITY {1, 2, 3} define PLANNER_AFFINITY #define PLANNER_AFFINITY {0} Source code // Copyright 2022 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef AUTOWARE_REFERENCE_SYSTEM__PRIORITIES_HPP_ #define AUTOWARE_REFERENCE_SYSTEM__PRIORITIES_HPP_ #include <sched.h> #include <string> #include <set> #include <unordered_set> extern const std::set<std::string> hotpath_nodes; extern const std::set<std::string> planner_nodes; constexpr int hotpath_prio = 1; #define HOTPATH_AFFINITY {1, 2, 3} constexpr int planner_prio = 30; #define PLANNER_AFFINITY {0} #endif // AUTOWARE_REFERENCE_SYSTEM__PRIORITIES_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"autoware_reference_system/include/autoware_reference_system/priorities.hpp"},{"location":"Files/priorities_8hpp/#autoware_reference_systemincludeautoware_reference_systemprioritieshpp","text":"","title":"autoware_reference_system/include/autoware_reference_system/priorities.hpp"},{"location":"Files/priorities_8hpp/#attributes","text":"Name const std::set< std::string > hotpath_nodes const std::set< std::string > planner_nodes constexpr int hotpath_prio constexpr int planner_prio","title":"Attributes"},{"location":"Files/priorities_8hpp/#defines","text":"Name HOTPATH_AFFINITY PLANNER_AFFINITY","title":"Defines"},{"location":"Files/priorities_8hpp/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Files/priorities_8hpp/#variable-hotpath_nodes","text":"const std::set< std::string > hotpath_nodes;","title":"variable hotpath_nodes"},{"location":"Files/priorities_8hpp/#variable-planner_nodes","text":"const std::set< std::string > planner_nodes;","title":"variable planner_nodes"},{"location":"Files/priorities_8hpp/#variable-hotpath_prio","text":"constexpr int hotpath_prio = 1;","title":"variable hotpath_prio"},{"location":"Files/priorities_8hpp/#variable-planner_prio","text":"constexpr int planner_prio = 30;","title":"variable planner_prio"},{"location":"Files/priorities_8hpp/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Files/priorities_8hpp/#define-hotpath_affinity","text":"#define HOTPATH_AFFINITY {1, 2, 3}","title":"define HOTPATH_AFFINITY"},{"location":"Files/priorities_8hpp/#define-planner_affinity","text":"#define PLANNER_AFFINITY {0}","title":"define PLANNER_AFFINITY"},{"location":"Files/priorities_8hpp/#source-code","text":"// Copyright 2022 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef AUTOWARE_REFERENCE_SYSTEM__PRIORITIES_HPP_ #define AUTOWARE_REFERENCE_SYSTEM__PRIORITIES_HPP_ #include <sched.h> #include <string> #include <set> #include <unordered_set> extern const std::set<std::string> hotpath_nodes; extern const std::set<std::string> planner_nodes; constexpr int hotpath_prio = 1; #define HOTPATH_AFFINITY {1, 2, 3} constexpr int planner_prio = 30; #define PLANNER_AFFINITY {0} #endif // AUTOWARE_REFERENCE_SYSTEM__PRIORITIES_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/rclcpp__system_8hpp/","text":"reference_system/include/reference_system/system/type/rclcpp_system.hpp Classes Name struct RclcppSystem Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__SYSTEM__TYPE__RCLCPP_SYSTEM_HPP_ #define REFERENCE_SYSTEM__SYSTEM__TYPE__RCLCPP_SYSTEM_HPP_ #include \"reference_system/nodes/rclcpp/command.hpp\" #include \"reference_system/nodes/rclcpp/fusion.hpp\" #include \"reference_system/nodes/rclcpp/transform.hpp\" #include \"reference_system/nodes/rclcpp/cyclic.hpp\" #include \"reference_system/nodes/rclcpp/sensor.hpp\" #include \"reference_system/nodes/rclcpp/intersection.hpp\" struct RclcppSystem { using NodeBaseType = rclcpp::Node; using Command = nodes::rclcpp_system::Command; using Cyclic = nodes::rclcpp_system::Cyclic; using Fusion = nodes::rclcpp_system::Fusion; using Intersection = nodes::rclcpp_system::Intersection; using Sensor = nodes::rclcpp_system::Sensor; using Transform = nodes::rclcpp_system::Transform; }; #endif // REFERENCE_SYSTEM__SYSTEM__TYPE__RCLCPP_SYSTEM_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/include/reference_system/system/type/rclcpp_system.hpp"},{"location":"Files/rclcpp__system_8hpp/#reference_systemincludereference_systemsystemtyperclcpp_systemhpp","text":"","title":"reference_system/include/reference_system/system/type/rclcpp_system.hpp"},{"location":"Files/rclcpp__system_8hpp/#classes","text":"Name struct RclcppSystem","title":"Classes"},{"location":"Files/rclcpp__system_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__SYSTEM__TYPE__RCLCPP_SYSTEM_HPP_ #define REFERENCE_SYSTEM__SYSTEM__TYPE__RCLCPP_SYSTEM_HPP_ #include \"reference_system/nodes/rclcpp/command.hpp\" #include \"reference_system/nodes/rclcpp/fusion.hpp\" #include \"reference_system/nodes/rclcpp/transform.hpp\" #include \"reference_system/nodes/rclcpp/cyclic.hpp\" #include \"reference_system/nodes/rclcpp/sensor.hpp\" #include \"reference_system/nodes/rclcpp/intersection.hpp\" struct RclcppSystem { using NodeBaseType = rclcpp::Node; using Command = nodes::rclcpp_system::Command; using Cyclic = nodes::rclcpp_system::Cyclic; using Fusion = nodes::rclcpp_system::Fusion; using Intersection = nodes::rclcpp_system::Intersection; using Sensor = nodes::rclcpp_system::Sensor; using Transform = nodes::rclcpp_system::Transform; }; #endif // REFERENCE_SYSTEM__SYSTEM__TYPE__RCLCPP_SYSTEM_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/reference__interfaces_2CMakeLists_8txt/","text":"CMakeLists.txt Functions Name cmake_minimum_required (VERSION 3. 5) Functions Documentation function cmake_minimum_required cmake_minimum_required( VERSION 3. 5 ) Source code cmake_minimum_required(VERSION 3.5) project(reference_interfaces) # Default to C++17 if(NOT CMAKE_CXX_STANDARD) set(CMAKE_CXX_STANDARD 17) endif() if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\") add_compile_options(-Wall -Wextra -Wpedantic) endif() find_package(ament_cmake_auto REQUIRED) ament_auto_find_build_dependencies() # add additional messages here set(msg_files \"msg/TransmissionStats.idl\" \"msg/Message4kb.idl\" ) # add additional message dependencies here #set(msg_dependencies # \"std_msgs\" #) rosidl_generate_interfaces(${PROJECT_NAME} ${msg_files} DEPENDENCIES ${msg_dependencies} ADD_LINTER_TESTS ) ament_auto_package() # remove the below lines if fix to #143 is backported to older ROS distros # fix rosidl_generator_py bug #143 # https://github.com/ros2/rosidl_python/issues/143 set(GENERATED_FILE \"${CMAKE_CURRENT_BINARY_DIR}/rosidl_generator_py/${PROJECT_NAME}/msg/_transmission_stats.py\") set(DISTROS_WITH_FIX \"humble\") list(FIND DISTROS_WITH_FIX $ENV{ROS_DISTRO} DISTRO_ALREADY_FIXED) if (${DISTRO_ALREADY_FIXED} MATCHES -1) message(STATUS \"checking generated file: ${GENERATED_FILE}\") set(DISTROS_WITH_RENAMED_TARGET \"rolling\") list(FIND DISTROS_WITH_RENAMED_TARGET $ENV{ROS_DISTRO} TARGET_RENAMED) if (${TARGET_RENAMED} MATCHES -1) set(TARGET_NAME ${PROJECT_NAME}__python) else() set(TARGET_NAME ${PROJECT_NAME}__rosidl_generator_py) endif() add_custom_command( TARGET ${TARGET_NAME} POST_BUILD COMMAND sed -i \"s/all(val >= 0 and val) < 256/all(ord(val) >= 0 and ord(val) < 256/\" ${GENERATED_FILE} COMMENT \"Check generated IDL files for extra parenthesis...\" VERBATIM) endif() Updated on 2022-04-30 at 21:32:33 +0000","title":"CMakeLists.txt"},{"location":"Files/reference__interfaces_2CMakeLists_8txt/#cmakeliststxt","text":"","title":"CMakeLists.txt"},{"location":"Files/reference__interfaces_2CMakeLists_8txt/#functions","text":"Name cmake_minimum_required (VERSION 3. 5)","title":"Functions"},{"location":"Files/reference__interfaces_2CMakeLists_8txt/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/reference__interfaces_2CMakeLists_8txt/#function-cmake_minimum_required","text":"cmake_minimum_required( VERSION 3. 5 )","title":"function cmake_minimum_required"},{"location":"Files/reference__interfaces_2CMakeLists_8txt/#source-code","text":"cmake_minimum_required(VERSION 3.5) project(reference_interfaces) # Default to C++17 if(NOT CMAKE_CXX_STANDARD) set(CMAKE_CXX_STANDARD 17) endif() if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\") add_compile_options(-Wall -Wextra -Wpedantic) endif() find_package(ament_cmake_auto REQUIRED) ament_auto_find_build_dependencies() # add additional messages here set(msg_files \"msg/TransmissionStats.idl\" \"msg/Message4kb.idl\" ) # add additional message dependencies here #set(msg_dependencies # \"std_msgs\" #) rosidl_generate_interfaces(${PROJECT_NAME} ${msg_files} DEPENDENCIES ${msg_dependencies} ADD_LINTER_TESTS ) ament_auto_package() # remove the below lines if fix to #143 is backported to older ROS distros # fix rosidl_generator_py bug #143 # https://github.com/ros2/rosidl_python/issues/143 set(GENERATED_FILE \"${CMAKE_CURRENT_BINARY_DIR}/rosidl_generator_py/${PROJECT_NAME}/msg/_transmission_stats.py\") set(DISTROS_WITH_FIX \"humble\") list(FIND DISTROS_WITH_FIX $ENV{ROS_DISTRO} DISTRO_ALREADY_FIXED) if (${DISTRO_ALREADY_FIXED} MATCHES -1) message(STATUS \"checking generated file: ${GENERATED_FILE}\") set(DISTROS_WITH_RENAMED_TARGET \"rolling\") list(FIND DISTROS_WITH_RENAMED_TARGET $ENV{ROS_DISTRO} TARGET_RENAMED) if (${TARGET_RENAMED} MATCHES -1) set(TARGET_NAME ${PROJECT_NAME}__python) else() set(TARGET_NAME ${PROJECT_NAME}__rosidl_generator_py) endif() add_custom_command( TARGET ${TARGET_NAME} POST_BUILD COMMAND sed -i \"s/all(val >= 0 and val) < 256/all(ord(val) >= 0 and ord(val) < 256/\" ${GENERATED_FILE} COMMENT \"Check generated IDL files for extra parenthesis...\" VERBATIM) endif() Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/reference__system_2CMakeLists_8txt/","text":"CMakeLists.txt Functions Name cmake_minimum_required (VERSION 3. 5) IN_LIST AVAILABLE_FRAMEWORKS message (FATAL_ERROR \"Unsupported framework: ${FRAMEWORK}\" ) INTERFACE target_include_directories ( ${PROJECT_NAME} INTERFACE $< BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include > $< INSTALL_INTERFACE:include >) find_package (ament_lint_auto REQUIRED) ament_target_dependencies (test_sample_management reference_interfaces) if ( ${FRAMEWORK} STREQUAL) ament_target_dependencies (test_reference_system_rclcpp reference_interfaces rclcpp) Functions Documentation function cmake_minimum_required cmake_minimum_required( VERSION 3. 5 ) function message IN_LIST AVAILABLE_FRAMEWORKS message( FATAL_ERROR \"Unsupported framework: ${FRAMEWORK}\" ) function target_include_directories INTERFACE target_include_directories( ${PROJECT_NAME} INTERFACE $< BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include > $< INSTALL_INTERFACE:include > ) function find_package find_package( ament_lint_auto REQUIRED ) function ament_target_dependencies ament_target_dependencies( test_sample_management reference_interfaces ) function if if( ${FRAMEWORK} STREQUAL ) function ament_target_dependencies ament_target_dependencies( test_reference_system_rclcpp reference_interfaces rclcpp ) Source code cmake_minimum_required(VERSION 3.5) project(reference_system) set(FRAMEWORK ros CACHE STRING \"The framework to build for. Currently supported values are ROS 2 (\\\"ros\\\").\") set(AVAILABLE_FRAMEWORKS ros) if(NOT ${FRAMEWORK} IN_LIST AVAILABLE_FRAMEWORKS) message(FATAL_ERROR \"Unsupported framework: ${FRAMEWORK}\") endif() if(NOT CMAKE_CXX_STANDARD) set(CMAKE_CXX_STANDARD 17) endif() if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\") add_compile_options(-Wall -Wextra -Wpedantic) endif() find_package(ament_cmake_auto REQUIRED) ament_auto_find_build_dependencies() # Add header-only library add_library(${PROJECT_NAME} INTERFACE) target_include_directories(${PROJECT_NAME} INTERFACE $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include> $<INSTALL_INTERFACE:include> ) if(${BUILD_TESTING}) find_package(ament_lint_auto REQUIRED) ament_lint_auto_find_test_dependencies() find_package(ament_cmake_gtest) # unit tests ament_add_gtest(test_sample_management test/test_sample_management.cpp) target_link_libraries(test_sample_management ${PROJECT_NAME}) ament_target_dependencies(test_sample_management reference_interfaces) ament_add_gtest(test_number_cruncher test/test_number_cruncher.cpp) target_link_libraries(test_number_cruncher ${PROJECT_NAME}) # integration tests if(${FRAMEWORK} STREQUAL ros) ament_add_gtest(test_reference_system_rclcpp test/test_fixtures.hpp test/test_reference_system_rclcpp.cpp) target_link_libraries(test_reference_system_rclcpp ${PROJECT_NAME}) ament_target_dependencies(test_reference_system_rclcpp reference_interfaces rclcpp) endif() endif() # Install install(TARGETS ${PROJECT_NAME} EXPORT \"export_${PROJECT_NAME}\" ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR} LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR} RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR} INCLUDES DESTINATION include ) ament_python_install_package(reference_system_py) ament_auto_package() Updated on 2022-04-30 at 21:32:33 +0000","title":"CMakeLists.txt"},{"location":"Files/reference__system_2CMakeLists_8txt/#cmakeliststxt","text":"","title":"CMakeLists.txt"},{"location":"Files/reference__system_2CMakeLists_8txt/#functions","text":"Name cmake_minimum_required (VERSION 3. 5) IN_LIST AVAILABLE_FRAMEWORKS message (FATAL_ERROR \"Unsupported framework: ${FRAMEWORK}\" ) INTERFACE target_include_directories ( ${PROJECT_NAME} INTERFACE $< BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include > $< INSTALL_INTERFACE:include >) find_package (ament_lint_auto REQUIRED) ament_target_dependencies (test_sample_management reference_interfaces) if ( ${FRAMEWORK} STREQUAL) ament_target_dependencies (test_reference_system_rclcpp reference_interfaces rclcpp)","title":"Functions"},{"location":"Files/reference__system_2CMakeLists_8txt/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/reference__system_2CMakeLists_8txt/#function-cmake_minimum_required","text":"cmake_minimum_required( VERSION 3. 5 )","title":"function cmake_minimum_required"},{"location":"Files/reference__system_2CMakeLists_8txt/#function-message","text":"IN_LIST AVAILABLE_FRAMEWORKS message( FATAL_ERROR \"Unsupported framework: ${FRAMEWORK}\" )","title":"function message"},{"location":"Files/reference__system_2CMakeLists_8txt/#function-target_include_directories","text":"INTERFACE target_include_directories( ${PROJECT_NAME} INTERFACE $< BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include > $< INSTALL_INTERFACE:include > )","title":"function target_include_directories"},{"location":"Files/reference__system_2CMakeLists_8txt/#function-find_package","text":"find_package( ament_lint_auto REQUIRED )","title":"function find_package"},{"location":"Files/reference__system_2CMakeLists_8txt/#function-ament_target_dependencies","text":"ament_target_dependencies( test_sample_management reference_interfaces )","title":"function ament_target_dependencies"},{"location":"Files/reference__system_2CMakeLists_8txt/#function-if","text":"if( ${FRAMEWORK} STREQUAL )","title":"function if"},{"location":"Files/reference__system_2CMakeLists_8txt/#function-ament_target_dependencies_1","text":"ament_target_dependencies( test_reference_system_rclcpp reference_interfaces rclcpp )","title":"function ament_target_dependencies"},{"location":"Files/reference__system_2CMakeLists_8txt/#source-code","text":"cmake_minimum_required(VERSION 3.5) project(reference_system) set(FRAMEWORK ros CACHE STRING \"The framework to build for. Currently supported values are ROS 2 (\\\"ros\\\").\") set(AVAILABLE_FRAMEWORKS ros) if(NOT ${FRAMEWORK} IN_LIST AVAILABLE_FRAMEWORKS) message(FATAL_ERROR \"Unsupported framework: ${FRAMEWORK}\") endif() if(NOT CMAKE_CXX_STANDARD) set(CMAKE_CXX_STANDARD 17) endif() if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\") add_compile_options(-Wall -Wextra -Wpedantic) endif() find_package(ament_cmake_auto REQUIRED) ament_auto_find_build_dependencies() # Add header-only library add_library(${PROJECT_NAME} INTERFACE) target_include_directories(${PROJECT_NAME} INTERFACE $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include> $<INSTALL_INTERFACE:include> ) if(${BUILD_TESTING}) find_package(ament_lint_auto REQUIRED) ament_lint_auto_find_test_dependencies() find_package(ament_cmake_gtest) # unit tests ament_add_gtest(test_sample_management test/test_sample_management.cpp) target_link_libraries(test_sample_management ${PROJECT_NAME}) ament_target_dependencies(test_sample_management reference_interfaces) ament_add_gtest(test_number_cruncher test/test_number_cruncher.cpp) target_link_libraries(test_number_cruncher ${PROJECT_NAME}) # integration tests if(${FRAMEWORK} STREQUAL ros) ament_add_gtest(test_reference_system_rclcpp test/test_fixtures.hpp test/test_reference_system_rclcpp.cpp) target_link_libraries(test_reference_system_rclcpp ${PROJECT_NAME}) ament_target_dependencies(test_reference_system_rclcpp reference_interfaces rclcpp) endif() endif() # Install install(TARGETS ${PROJECT_NAME} EXPORT \"export_${PROJECT_NAME}\" ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR} LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR} RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR} INCLUDES DESTINATION include ) ament_python_install_package(reference_system_py) ament_auto_package() Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/reference__system_2README_8md/","text":"README.md Source code # The reference system With the distributed development of ROS across many different organizations it is sometimes hard to benchmark and concretely show how a certain change to a certain system improves or reduces the performance of that system. For example did a change from one executor to another actually reduce the CPU or was it something else entirely? The `reference_system` package was developed to provide the fundamental building blocks to create complex systems that then can be used to evaluate features or performance in a standardized and repeatable way. The first project to use this `reference_system` is [the `autoware_reference_system`.](autoware_reference_system/README.md) Future _reference systems_ could be proposed that are more complex using the same basic node building blocks within the `reference_system` package. ## Defining a reference system A _reference system_ is defined by: - A [platform](#supported-platforms) is defined by: - Hardware (e.g. an off-the-shelf single-board computer, embedded ECU, etc.) - if there are multiple configurations available for such hardware, ensure it is specified - Operating System (OS) like RT Linux, QNX, etc. along with any special configurations made - for simplicity and ease of benchmarking, **all nodes must run on a single process** - a fixed number of nodes - each node with: - a fixed number of publishers and subscribers - a fixed _processing time_ or a fixed _publishing rate_ - a fixed _message type_ of fixed size to be used for every _node_ With these defined attributes the _reference system_ can be replicated across many different possible configurations to be used to benchmark each configuration against the other in a reliable and fair manner. With this approach [portable and repeatable tests](#testing) can also be defined to reliably confirm if a given _reference system_ meets the requirements. ## Supported Platforms To enable as many people as possible to replicate this reference system, the platform(s) were chosen to be easily accessible (inexpensive, high volume), have lots of documentation, large community use and will be supported well into the future. Platforms were not chosen for performance of the reference system - we know we could run \u201cfaster\u201d with a more powerful CPU or GPU but then it would be harder for others to validate findings and test their own configurations. Accessibility is the key here and will be considered if more platforms want to be added to this benchmark list. **Platforms:** - [Raspberry Pi 4B](https://www.raspberrypi.org/products/raspberry-pi-4-model-b/): - 4 GB RAM version is the assumed default - other versions could also be tested / added by the community - [real-time Linux kernel](https://github.com/ros-realtime/rt-kernel-docker-builder) _Note: create an [issue](https://github.com/ros-realtime/reference-system-autoware/issues/)_ _to add more platforms to the list, keeping in mind the above criteria_ !!! warning Each reference system can be run on other targets as well however the results will change drastically depending on the specifications of the target hardware. ## Base node types Most real-world systems can be boiled down to only a handful of base node \"types\" that are then repeated to make the real-world system. This does not cover _all_ possible node types, however it allows for numerous complicated systems to be developed using the same base building blocks. 1. **Sensor Node** - input node to system - one publisher, zero subscribers - publishes message cyclically at some fixed frequency 2. **Transform Node** - one subscriber, one publisher - starts processing for N milliseconds after a message is received - publishes message after processing is complete 3. **Fusion Node** - 2 subscribers, one publisher - starts processing for N milliseconds after a message is received **from all** subscriptions - publishes message after processing is complete 4. **Cyclic Node** - N subscribers, one publisher - cyclically processes all received messages since the last cycle for N milliseconds - publishes message after processing is complete 5. **Command Node** - prints output stats everytime a message is received 6. **Intersection Node** - behaves like N transform nodes - N subscribers, N publisher bundled together in one-to-one connections - starts processing on connection where sample was received - publishes message after processing is complete These basic building-block nodes can be mixed-and-matched to create quite complex systems that replicate real-world scenarios to benchmark different configurations against each other. New base node types can be added if necessary. ## Implemented reference systems The first reference system benchmark proposed is based on the *Autoware.Auto* LiDAR data pipeline as stated above and shown in the node graph image above as well. 1. **Autoware Reference System** - ROS2 - Executors - Single Threaded - Static Single Threaded - Multithreaded - Callback Group - Prioritized Results below show various characteristics of the same simulated system (Autoware.Auto). ## Testing and Dependencies Common benchmarking scripts are provided within the `reference_system/reference_system_py` directory which is a python module itself. The methods and tools provided there can assist with running standardized benchmarking tests and with generating reports as well. See [the `autoware_reference_system` for an example](autoware_reference_system/scripts/benchmark.py) Unit and integration tests have also been written for the `reference_system` and can be found within [the `test` directory](test/test_reference_system_rclcpp.cpp). If a new system type is to be added, new unit and integration tests should also be added as well. ## Setup Raspberry Pi 4 for the test The goal is to provide a clean computation environment for the test avoiding an interference of other Ubuntu components. ### Setup a constant CPU frequency Frequency is setup to 1.50 GHz for all CPUs ```console # run it as root sudo su echo -n \"setup constant CPU frequency to 1.50 GHz ... \" # disable ondemand governor systemctl disable ondemand # set performance governor for all cpus echo performance | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor >/dev/null # set constant frequency echo 1500000 | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_min_freq >/dev/null echo 1500000 | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_max_freq >/dev/null # reset frequency counters echo 1 | tee /sys/devices/system/cpu/cpu*/cpufreq/stats/reset >/dev/null echo done sleep 1 # get freq info echo `cpufreq-info | grep stats | cut -d ' ' -f 23-25` Isolate CPUs CPU 2,3 are isolated to run tests. sudo apt install -y sysstat u-boot-tools # modify kernel cmdline cd ~ dd if=/boot/firmware/boot.scr of=boot.script bs=72 skip=1 # edit boot.script and modify bootargs to ubuntu@ubuntu:~$ cat boot.script | grep \"setenv bootargs\" | head -1 setenv bootargs \" ${bootargs} rcu_nocbs=2,3 nohz_full=2,3 isolcpus=2,3 irqaffinity=0,1 audit=0 watchdog=0 skew_tick=1 quiet splash\" # generate boot.scr mkimage -A arm64 -O linux -T script -C none -d boot.script boot.scr # replace boot.scr sudo cp boot.scr /boot/firmware/boot.scr sudo reboot # check cmdline ubuntu@ubuntu:~$ cat /proc/cmdline coherent_pool=1M 8250.nr_uarts=1 snd_bcm2835.enable_compat_alsa=0 snd_bcm2835.enable_hdmi=1 bcm2708_fb.fbwidth=0 bcm2708_fb.fbheight=0 bcm2708_fb.fbswap=1 smsc95xx.macaddr=DC:A6:32:2E:5 4:97 vc_mem.mem_base=0x3ec00000 vc_mem.mem_size=0x40000000 net.ifnames=0 dwc_otg.lpm_enable=0 console=ttyS0,115200 console=tty1 root=LABEL=writable rootfstype=ext4 elevator=deadline roo twait fixrtc rcu_nocbs=2,3 nohz_full=2,3 isolcpus=2,3 irqaffinity=0,1 audit=0 watchdog=0 skew_tick=1 quiet splash # check interrupts # Only the number of interrupts handled by CPU 0,1 increases. watch -n1 cat /proc/interrupts # check soft interrupts watch -n1 cat /proc/softirqs # check isolated CPUs cat /sys/devices/system/cpu/isolated 2-3 cat /sys/devices/system/cpu/present 0-3 # run reference system on CPU2 taskset -c 2 install/autoware_reference_system/lib/autoware_reference_system/autoware_default_singlethreaded > /dev/null # get pid RF_PID=`pidof autoware_default_singlethreaded` && cat /proc/$RF_PID/status | grep ^Cpu # check how many threads are running ps -aL | grep $RF_PID 3835 3835 ttyS0 00:03:46 autoware_defaul 3835 3836 ttyS0 00:00:00 autoware_defaul 3835 3837 ttyS0 00:00:00 autoware_defaul 3835 3838 ttyS0 00:00:00 autoware_defaul 3835 3839 ttyS0 00:00:00 gc 3835 3840 ttyS0 00:00:00 dq.builtins 3835 3841 ttyS0 00:00:00 dq.user 3835 3842 ttyS0 00:00:00 tev 3835 3843 ttyS0 00:00:00 recv 3835 3844 ttyS0 00:00:00 recvMC 3835 3845 ttyS0 00:00:00 recvUC 3835 3846 ttyS0 00:00:00 autoware_defaul Hints If you run colcon build on a Raspberry Pi 4 with little memory, use export MAKEFLAGS=\"-j 1\" to inhibit parallelism. Otherwise, the system could hang due to memory swapping. ``` Updated on 2022-04-30 at 21:32:33 +0000","title":"README.md"},{"location":"Files/reference__system_2README_8md/#readmemd","text":"","title":"README.md"},{"location":"Files/reference__system_2README_8md/#source-code","text":"# The reference system With the distributed development of ROS across many different organizations it is sometimes hard to benchmark and concretely show how a certain change to a certain system improves or reduces the performance of that system. For example did a change from one executor to another actually reduce the CPU or was it something else entirely? The `reference_system` package was developed to provide the fundamental building blocks to create complex systems that then can be used to evaluate features or performance in a standardized and repeatable way. The first project to use this `reference_system` is [the `autoware_reference_system`.](autoware_reference_system/README.md) Future _reference systems_ could be proposed that are more complex using the same basic node building blocks within the `reference_system` package. ## Defining a reference system A _reference system_ is defined by: - A [platform](#supported-platforms) is defined by: - Hardware (e.g. an off-the-shelf single-board computer, embedded ECU, etc.) - if there are multiple configurations available for such hardware, ensure it is specified - Operating System (OS) like RT Linux, QNX, etc. along with any special configurations made - for simplicity and ease of benchmarking, **all nodes must run on a single process** - a fixed number of nodes - each node with: - a fixed number of publishers and subscribers - a fixed _processing time_ or a fixed _publishing rate_ - a fixed _message type_ of fixed size to be used for every _node_ With these defined attributes the _reference system_ can be replicated across many different possible configurations to be used to benchmark each configuration against the other in a reliable and fair manner. With this approach [portable and repeatable tests](#testing) can also be defined to reliably confirm if a given _reference system_ meets the requirements. ## Supported Platforms To enable as many people as possible to replicate this reference system, the platform(s) were chosen to be easily accessible (inexpensive, high volume), have lots of documentation, large community use and will be supported well into the future. Platforms were not chosen for performance of the reference system - we know we could run \u201cfaster\u201d with a more powerful CPU or GPU but then it would be harder for others to validate findings and test their own configurations. Accessibility is the key here and will be considered if more platforms want to be added to this benchmark list. **Platforms:** - [Raspberry Pi 4B](https://www.raspberrypi.org/products/raspberry-pi-4-model-b/): - 4 GB RAM version is the assumed default - other versions could also be tested / added by the community - [real-time Linux kernel](https://github.com/ros-realtime/rt-kernel-docker-builder) _Note: create an [issue](https://github.com/ros-realtime/reference-system-autoware/issues/)_ _to add more platforms to the list, keeping in mind the above criteria_ !!! warning Each reference system can be run on other targets as well however the results will change drastically depending on the specifications of the target hardware. ## Base node types Most real-world systems can be boiled down to only a handful of base node \"types\" that are then repeated to make the real-world system. This does not cover _all_ possible node types, however it allows for numerous complicated systems to be developed using the same base building blocks. 1. **Sensor Node** - input node to system - one publisher, zero subscribers - publishes message cyclically at some fixed frequency 2. **Transform Node** - one subscriber, one publisher - starts processing for N milliseconds after a message is received - publishes message after processing is complete 3. **Fusion Node** - 2 subscribers, one publisher - starts processing for N milliseconds after a message is received **from all** subscriptions - publishes message after processing is complete 4. **Cyclic Node** - N subscribers, one publisher - cyclically processes all received messages since the last cycle for N milliseconds - publishes message after processing is complete 5. **Command Node** - prints output stats everytime a message is received 6. **Intersection Node** - behaves like N transform nodes - N subscribers, N publisher bundled together in one-to-one connections - starts processing on connection where sample was received - publishes message after processing is complete These basic building-block nodes can be mixed-and-matched to create quite complex systems that replicate real-world scenarios to benchmark different configurations against each other. New base node types can be added if necessary. ## Implemented reference systems The first reference system benchmark proposed is based on the *Autoware.Auto* LiDAR data pipeline as stated above and shown in the node graph image above as well. 1. **Autoware Reference System** - ROS2 - Executors - Single Threaded - Static Single Threaded - Multithreaded - Callback Group - Prioritized Results below show various characteristics of the same simulated system (Autoware.Auto). ## Testing and Dependencies Common benchmarking scripts are provided within the `reference_system/reference_system_py` directory which is a python module itself. The methods and tools provided there can assist with running standardized benchmarking tests and with generating reports as well. See [the `autoware_reference_system` for an example](autoware_reference_system/scripts/benchmark.py) Unit and integration tests have also been written for the `reference_system` and can be found within [the `test` directory](test/test_reference_system_rclcpp.cpp). If a new system type is to be added, new unit and integration tests should also be added as well. ## Setup Raspberry Pi 4 for the test The goal is to provide a clean computation environment for the test avoiding an interference of other Ubuntu components. ### Setup a constant CPU frequency Frequency is setup to 1.50 GHz for all CPUs ```console # run it as root sudo su echo -n \"setup constant CPU frequency to 1.50 GHz ... \" # disable ondemand governor systemctl disable ondemand # set performance governor for all cpus echo performance | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor >/dev/null # set constant frequency echo 1500000 | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_min_freq >/dev/null echo 1500000 | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_max_freq >/dev/null # reset frequency counters echo 1 | tee /sys/devices/system/cpu/cpu*/cpufreq/stats/reset >/dev/null echo done sleep 1 # get freq info echo `cpufreq-info | grep stats | cut -d ' ' -f 23-25`","title":"Source code"},{"location":"Files/reference__system_2README_8md/#isolate-cpus","text":"CPU 2,3 are isolated to run tests. sudo apt install -y sysstat u-boot-tools # modify kernel cmdline cd ~ dd if=/boot/firmware/boot.scr of=boot.script bs=72 skip=1 # edit boot.script and modify bootargs to ubuntu@ubuntu:~$ cat boot.script | grep \"setenv bootargs\" | head -1 setenv bootargs \" ${bootargs} rcu_nocbs=2,3 nohz_full=2,3 isolcpus=2,3 irqaffinity=0,1 audit=0 watchdog=0 skew_tick=1 quiet splash\" # generate boot.scr mkimage -A arm64 -O linux -T script -C none -d boot.script boot.scr # replace boot.scr sudo cp boot.scr /boot/firmware/boot.scr sudo reboot # check cmdline ubuntu@ubuntu:~$ cat /proc/cmdline coherent_pool=1M 8250.nr_uarts=1 snd_bcm2835.enable_compat_alsa=0 snd_bcm2835.enable_hdmi=1 bcm2708_fb.fbwidth=0 bcm2708_fb.fbheight=0 bcm2708_fb.fbswap=1 smsc95xx.macaddr=DC:A6:32:2E:5 4:97 vc_mem.mem_base=0x3ec00000 vc_mem.mem_size=0x40000000 net.ifnames=0 dwc_otg.lpm_enable=0 console=ttyS0,115200 console=tty1 root=LABEL=writable rootfstype=ext4 elevator=deadline roo twait fixrtc rcu_nocbs=2,3 nohz_full=2,3 isolcpus=2,3 irqaffinity=0,1 audit=0 watchdog=0 skew_tick=1 quiet splash # check interrupts # Only the number of interrupts handled by CPU 0,1 increases. watch -n1 cat /proc/interrupts # check soft interrupts watch -n1 cat /proc/softirqs # check isolated CPUs cat /sys/devices/system/cpu/isolated 2-3 cat /sys/devices/system/cpu/present 0-3 # run reference system on CPU2 taskset -c 2 install/autoware_reference_system/lib/autoware_reference_system/autoware_default_singlethreaded > /dev/null # get pid RF_PID=`pidof autoware_default_singlethreaded` && cat /proc/$RF_PID/status | grep ^Cpu # check how many threads are running ps -aL | grep $RF_PID 3835 3835 ttyS0 00:03:46 autoware_defaul 3835 3836 ttyS0 00:00:00 autoware_defaul 3835 3837 ttyS0 00:00:00 autoware_defaul 3835 3838 ttyS0 00:00:00 autoware_defaul 3835 3839 ttyS0 00:00:00 gc 3835 3840 ttyS0 00:00:00 dq.builtins 3835 3841 ttyS0 00:00:00 dq.user 3835 3842 ttyS0 00:00:00 tev 3835 3843 ttyS0 00:00:00 recv 3835 3844 ttyS0 00:00:00 recvMC 3835 3845 ttyS0 00:00:00 recvUC 3835 3846 ttyS0 00:00:00 autoware_defaul","title":"Isolate CPUs"},{"location":"Files/reference__system_2README_8md/#hints","text":"If you run colcon build on a Raspberry Pi 4 with little memory, use export MAKEFLAGS=\"-j 1\" to inhibit parallelism. Otherwise, the system could hang due to memory swapping. ``` Updated on 2022-04-30 at 21:32:33 +0000","title":"Hints"},{"location":"Files/reference__system_2reference__system__py_2benchmark_8py/","text":"reference_system/reference_system_py/benchmark.py Namespaces Name reference_system_py reference_system_py::benchmark Source code #!/usr/bin/env python3 # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # Generates traces for specified executables and RMWs import contextlib import fcntl import os from pathlib import Path import subprocess import time from ament_index_python import get_package_prefix from bokeh.io import output_file as bokeh_output_file from bokeh.layouts import layout as bokeh_layout from bokeh.plotting import save as bokeh_save import psutil from . import callback_duration from . import dropped_messages from . import memory_usage from . import std_latency from .constants import SIZE_SUBPLOT, SIZE_SUMMARY try: from tracetools_trace.tools.names import DEFAULT_EVENTS_ROS from trace_utils import initDataModel tracetools_available = True except ModuleNotFoundError: tracetools_available = False ROS_HOME = Path(os.environ.get('ROS_HOME', os.environ['HOME']+'/.ros')) def available_executables(pkg, pattern='*'): prefix = get_package_prefix(pkg) return [path.stem for path in (Path(prefix)/'lib'/pkg).glob(pattern)] def get_benchmark_directory(base_directory, executable, runtime_sec, rmw, create=False): \"\"\" Return the directory to place measurements and reports for the given experiment. If `create` is True, the directory is created if it does not exist yet. \"\"\" # Note: memory_usage.py and std_latency.py make assumptions about the directory format. # Do not change this without also changing these other files. directory = Path(base_directory)/f'{runtime_sec}s/{rmw}/{executable}/' if create: directory.mkdir(parents=True, exist_ok=True) return directory def get_benchmark_directories_below(base_directory, runtime_sec=None): \"\"\"Return all benchmark directories found below `base_directory`.\"\"\" runtime_re = '*[0-9]' if runtime_sec is None else str(runtime_sec) return [str(directory) for directory in Path(base_directory).glob(f'*{runtime_re}s/rmw_*/*')] @contextlib.contextmanager def terminatingRos2Run(pkg, executable, rmw, env=os.environ, args=[], **kwargs): \"\"\" Run the given executable (part of the given package) under the given rmw. The executable is automatically terminated upon exit from the context \"\"\" env = env.copy() env['RCUTILS_CONSOLE_OUTPUT_FORMAT'] = '[{severity}] [{name}]: {message}' env['RMW_IMPLEMENTATION'] = rmw env['RCL_ASSERT_RMW_ID_MATCHES'] = rmw assert 'timeout' not in kwargs, ('terminatingRos2Run does not support the timeout argument;' + 'use time.sleep in the with block instead') ros_executable = Path(get_package_prefix(pkg))/'lib'/pkg/executable cmdline = f'{ros_executable} {\" \".join(args)}' process = subprocess.Popen(cmdline, shell=True, env=env, **kwargs) shellproc = psutil.Process(process.pid) try: yield process finally: if process.poll() not in (None, 0): # Process terminated with an error raise RuntimeError(f'Command \"{cmdline}\" terminated with error: {process.returncode}') # The process returned by subprocess.Popen is the shell process, not the # ROS process. Terminating the former will not necessarily terminate the latter. # Terminate all the *children* of the shell process instead. children = shellproc.children() assert len(children) <= 1 if children: rosproc = children[0] rosproc.terminate() @contextlib.contextmanager def roudi_daemon(env=os.environ, roudi_config_path=None): \"\"\" Context manager that runs a RouDi instance for the duration of the context. The `env` parameter specifies environment variables for the RouDi process. The `roudi_config_path` parameter can be used to provide a RouDi toml configuration file. \"\"\" if 'ICEORYX_HOME' not in env: raise RuntimeError('Cannot find ICEORYX_HOME in environment. ' + 'Is the iceoryx environment set up?') try: with open('/tmp/roudi.lock') as roudi_lock: try: fcntl.flock(roudi_lock.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB) except BlockingIOError as exception: raise RuntimeError('RouDi already running.') from exception finally: fcntl.flock(roudi_lock.fileno(), fcntl.LOCK_UN) except FileNotFoundError: pass # If the file does not exist, everything is fine; roudi is not running. roudi_shell = subprocess.Popen(('$ICEORYX_HOME/bin/iox-roudi ' + ('' if roudi_config_path is None else f\"-c '{roudi_config_path}'\")), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env) try: yield roudi_shell finally: if roudi_shell.poll() is not None: raise RuntimeError(f'Roudi terminated with return code {roudi_shell.returncode}:\\n' + f'Output: {roudi_shell.stderr.read()}') roudi_process, = psutil.Process(roudi_shell.pid).children() roudi_process.terminate() roudi_process.wait() def generate_callback_trace(executable, pkg, directory, runtime_sec, rmw): \"\"\" Generate a tracefile for the given executable using the 'callback' method. The 'callback' method measures the executable using 'ros2 trace' \"\"\" raise NotImplementedError('lttng currently does not work within ADE') if not tracetools_available: raise RuntimeError('Unable to import tracetools_trace. Are the tracetools installed?') log_directory = get_benchmark_directory(directory, executable, runtime_sec, rmw, create=True) kernel_events = [] user_events = DEFAULT_EVENTS_ROS session = f'callback_trace_{pkg}_{executable}_{rmw}_{runtime_sec}s' tracer = subprocess.Popen(f'ros2 trace -s {session} ' + f'-p {log_directory/\"callback_trace\"} ' + f'-k {\" \".join(kernel_events)} ' + f'-u {\" \".join(user_events)} ', shell=True, text=True, stdin=subprocess.PIPE) try: with terminatingRos2Run(pkg, executable, rmw, stdout=subprocess.DEVNULL): # transmit the key press that ros2 trace requires to start tracer.stdin.write('\\n') time.sleep(runtime_sec) finally: tracer.terminate() def generate_std_trace(executable, pkg, directory, runtime_sec, rmw): \"\"\" Generate a tracefile for the given executable using the 'std' method. The 'std' method logs stdout of the executable. \"\"\" log_directory = get_benchmark_directory(directory, executable, runtime_sec, rmw, create=True) logfile = log_directory/'std_output.log' with logfile.open('w', encoding='utf8') as logfd: with terminatingRos2Run(pkg, executable, rmw, stdout=logfd, text=True): time.sleep(runtime_sec) def generate_memory_trace(executable, pkg, directory, runtime_sec, rmw): \"\"\" Generate a tracefile for the given executable using the 'memory' method. The 'memory' method uses `psrecord` to profile memory and CPU usage. \"\"\" log_directory = get_benchmark_directory(directory, executable, runtime_sec, rmw, create=True) logfile = log_directory/f'memory_log.txt' plotfile = log_directory/f'memory_log.png' psrecord_cmd = subprocess.run('command -v psrecord', shell=True, stdout=subprocess.DEVNULL) if psrecord_cmd.returncode != 0: raise RuntimeError('psrecord is not installed; install it with pip install -U psrecord') with terminatingRos2Run(pkg, executable, rmw, stdout=subprocess.DEVNULL) as rosprocess: # Note: psrecord does provide a duration argument, but it just kills its subprocess # using SIGKILL, which does not reliably terminate ROS programs. # We therefore run psrecord inside the terminatingRos2Run instead. tracerprocess = subprocess.Popen(f'psrecord --include-children ' + f'--log {logfile} ' + f'--plot {plotfile} ' + f'{rosprocess.pid} ', shell=True) time.sleep(runtime_sec+0.5) tracerprocess.wait(20) def generate_trace(trace_type, *args, **kwargs): if trace_type == 'memory': return generate_memory_trace(*args, **kwargs) elif trace_type == 'callback': return generate_callback_trace(*args, **kwargs) elif trace_type == 'std': return generate_std_trace(*args, **kwargs) else: raise ValueError(f'Invalid trace_type: {trace_type}') def generate_callback_report(executable, pkg, directory, runtime_sec, rmw): \"\"\"Generate a per-executable report from the 'callback' trace file.\"\"\" if not tracetools_available: raise RuntimeError('Unable to import tracetools_trace. Are the tracetools installed?') log_directory = get_benchmark_directory(directory, executable, runtime_sec, rmw) duration_output = log_directory/'callback_duration_report.html' dropped_msgs_output = log_directory/'tracing_latency_and_dropped_messages_report.html' data_model = initDataModel(log_directory/'callback_trace') bokeh_output_file(filename=duration_output, title='Callback Duration Report') print('Output report to', duration_output) duration_summary = callback_duration.summary( data_model=data_model, size=SIZE_SUMMARY) duration_individual = callback_duration.individual( data_model=data_model, size=SIZE_SUBPLOT) report = bokeh_layout([[duration_summary], *duration_individual]) bokeh_save(report) bokeh_output_file(filename=dropped_msgs_output, title='ROS 2 Tracing Latency and Dropped Messages Report') print('Output report to', dropped_msgs_output) dropped_msgs = dropped_messages.individual( data_model=data_model, size=SIZE_SUMMARY) report = bokeh_layout([[dropped_msgs]]) bokeh_save(report) def generate_memory_report(executable, pkg, directory, runtime_sec, rmw): \"\"\"Generate a per-executable report from the 'memory' trace file.\"\"\" log_directory = get_benchmark_directory(directory, executable, runtime_sec, rmw) output = log_directory/'memory_and_cpu_usage_report.html' input_path = log_directory/'memory_log.txt' bokeh_output_file(filename=output, title='Memory and CPU Usage Report') print('Output report to', output) mem_individual = memory_usage.individual(input_path, size=SIZE_SUMMARY) report = bokeh_layout([*mem_individual]) bokeh_save(report) def generate_report(trace_type, *args, **kwargs): if trace_type == 'memory': return generate_memory_report(*args, **kwargs) elif trace_type == 'callback': return generate_callback_report(*args, **kwargs) elif trace_type == 'std': return None # No postprocessing needed for std trace else: raise ValueError(f'Invalid trace_type: {trace_type}') def generate_summary_report(trace_type, pkg, directory, runtime_sec): \"\"\"Generate a summary report for the given `trace_type`, using all traces under `directory`.\"\"\" trace_dirs = get_benchmark_directories_below(directory, runtime_sec=runtime_sec) if trace_type == 'memory': output_file = f'{directory}/memory_and_cpu_usage_summary_report_{runtime_sec}s.html' bokeh_output_file(filename=output_file, title='Memory Usage Report') mem_summary = memory_usage.summary_from_directories(trace_dirs, duration=runtime_sec, size=SIZE_SUMMARY) report = bokeh_layout([*mem_summary]) elif trace_type == 'std': output_file = f'{directory}/executor_kpi_summary_report_{runtime_sec}s.html' bokeh_output_file(filename=output_file, title='Executor Key Performance Indicator (KPI) Report') std_summary = std_latency.summary_from_directories(trace_dirs, duration=runtime_sec, size=SIZE_SUMMARY) report = bokeh_layout([*std_summary]) else: raise NotImplementedError(f'Unsupported trace type {trace_type}') print('Output report to', output_file) bokeh_save(report) def setup_benchmark_directory(pkg, create=False): base_dir = ROS_HOME/f'benchmark_{pkg}' if not create: latest = base_dir/'latest' if not latest.exists(): raise FileNotFoundError(f'Benchmark directory {base_dir} does not exist') return latest base_dir.mkdir(exist_ok=True, parents=True) # Create a subdirectory with a timestamp and link 'latest' to it. timestamp = time.strftime('%Y-%m-%d-%H-%M-%S') benchmark_dir = base_dir/timestamp latest_symlink = base_dir/'latest' latest_symlink.unlink(missing_ok=True) latest_symlink.symlink_to(benchmark_dir) return benchmark_dir Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/reference_system_py/benchmark.py"},{"location":"Files/reference__system_2reference__system__py_2benchmark_8py/#reference_systemreference_system_pybenchmarkpy","text":"","title":"reference_system/reference_system_py/benchmark.py"},{"location":"Files/reference__system_2reference__system__py_2benchmark_8py/#namespaces","text":"Name reference_system_py reference_system_py::benchmark","title":"Namespaces"},{"location":"Files/reference__system_2reference__system__py_2benchmark_8py/#source-code","text":"#!/usr/bin/env python3 # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # Generates traces for specified executables and RMWs import contextlib import fcntl import os from pathlib import Path import subprocess import time from ament_index_python import get_package_prefix from bokeh.io import output_file as bokeh_output_file from bokeh.layouts import layout as bokeh_layout from bokeh.plotting import save as bokeh_save import psutil from . import callback_duration from . import dropped_messages from . import memory_usage from . import std_latency from .constants import SIZE_SUBPLOT, SIZE_SUMMARY try: from tracetools_trace.tools.names import DEFAULT_EVENTS_ROS from trace_utils import initDataModel tracetools_available = True except ModuleNotFoundError: tracetools_available = False ROS_HOME = Path(os.environ.get('ROS_HOME', os.environ['HOME']+'/.ros')) def available_executables(pkg, pattern='*'): prefix = get_package_prefix(pkg) return [path.stem for path in (Path(prefix)/'lib'/pkg).glob(pattern)] def get_benchmark_directory(base_directory, executable, runtime_sec, rmw, create=False): \"\"\" Return the directory to place measurements and reports for the given experiment. If `create` is True, the directory is created if it does not exist yet. \"\"\" # Note: memory_usage.py and std_latency.py make assumptions about the directory format. # Do not change this without also changing these other files. directory = Path(base_directory)/f'{runtime_sec}s/{rmw}/{executable}/' if create: directory.mkdir(parents=True, exist_ok=True) return directory def get_benchmark_directories_below(base_directory, runtime_sec=None): \"\"\"Return all benchmark directories found below `base_directory`.\"\"\" runtime_re = '*[0-9]' if runtime_sec is None else str(runtime_sec) return [str(directory) for directory in Path(base_directory).glob(f'*{runtime_re}s/rmw_*/*')] @contextlib.contextmanager def terminatingRos2Run(pkg, executable, rmw, env=os.environ, args=[], **kwargs): \"\"\" Run the given executable (part of the given package) under the given rmw. The executable is automatically terminated upon exit from the context \"\"\" env = env.copy() env['RCUTILS_CONSOLE_OUTPUT_FORMAT'] = '[{severity}] [{name}]: {message}' env['RMW_IMPLEMENTATION'] = rmw env['RCL_ASSERT_RMW_ID_MATCHES'] = rmw assert 'timeout' not in kwargs, ('terminatingRos2Run does not support the timeout argument;' + 'use time.sleep in the with block instead') ros_executable = Path(get_package_prefix(pkg))/'lib'/pkg/executable cmdline = f'{ros_executable} {\" \".join(args)}' process = subprocess.Popen(cmdline, shell=True, env=env, **kwargs) shellproc = psutil.Process(process.pid) try: yield process finally: if process.poll() not in (None, 0): # Process terminated with an error raise RuntimeError(f'Command \"{cmdline}\" terminated with error: {process.returncode}') # The process returned by subprocess.Popen is the shell process, not the # ROS process. Terminating the former will not necessarily terminate the latter. # Terminate all the *children* of the shell process instead. children = shellproc.children() assert len(children) <= 1 if children: rosproc = children[0] rosproc.terminate() @contextlib.contextmanager def roudi_daemon(env=os.environ, roudi_config_path=None): \"\"\" Context manager that runs a RouDi instance for the duration of the context. The `env` parameter specifies environment variables for the RouDi process. The `roudi_config_path` parameter can be used to provide a RouDi toml configuration file. \"\"\" if 'ICEORYX_HOME' not in env: raise RuntimeError('Cannot find ICEORYX_HOME in environment. ' + 'Is the iceoryx environment set up?') try: with open('/tmp/roudi.lock') as roudi_lock: try: fcntl.flock(roudi_lock.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB) except BlockingIOError as exception: raise RuntimeError('RouDi already running.') from exception finally: fcntl.flock(roudi_lock.fileno(), fcntl.LOCK_UN) except FileNotFoundError: pass # If the file does not exist, everything is fine; roudi is not running. roudi_shell = subprocess.Popen(('$ICEORYX_HOME/bin/iox-roudi ' + ('' if roudi_config_path is None else f\"-c '{roudi_config_path}'\")), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env) try: yield roudi_shell finally: if roudi_shell.poll() is not None: raise RuntimeError(f'Roudi terminated with return code {roudi_shell.returncode}:\\n' + f'Output: {roudi_shell.stderr.read()}') roudi_process, = psutil.Process(roudi_shell.pid).children() roudi_process.terminate() roudi_process.wait() def generate_callback_trace(executable, pkg, directory, runtime_sec, rmw): \"\"\" Generate a tracefile for the given executable using the 'callback' method. The 'callback' method measures the executable using 'ros2 trace' \"\"\" raise NotImplementedError('lttng currently does not work within ADE') if not tracetools_available: raise RuntimeError('Unable to import tracetools_trace. Are the tracetools installed?') log_directory = get_benchmark_directory(directory, executable, runtime_sec, rmw, create=True) kernel_events = [] user_events = DEFAULT_EVENTS_ROS session = f'callback_trace_{pkg}_{executable}_{rmw}_{runtime_sec}s' tracer = subprocess.Popen(f'ros2 trace -s {session} ' + f'-p {log_directory/\"callback_trace\"} ' + f'-k {\" \".join(kernel_events)} ' + f'-u {\" \".join(user_events)} ', shell=True, text=True, stdin=subprocess.PIPE) try: with terminatingRos2Run(pkg, executable, rmw, stdout=subprocess.DEVNULL): # transmit the key press that ros2 trace requires to start tracer.stdin.write('\\n') time.sleep(runtime_sec) finally: tracer.terminate() def generate_std_trace(executable, pkg, directory, runtime_sec, rmw): \"\"\" Generate a tracefile for the given executable using the 'std' method. The 'std' method logs stdout of the executable. \"\"\" log_directory = get_benchmark_directory(directory, executable, runtime_sec, rmw, create=True) logfile = log_directory/'std_output.log' with logfile.open('w', encoding='utf8') as logfd: with terminatingRos2Run(pkg, executable, rmw, stdout=logfd, text=True): time.sleep(runtime_sec) def generate_memory_trace(executable, pkg, directory, runtime_sec, rmw): \"\"\" Generate a tracefile for the given executable using the 'memory' method. The 'memory' method uses `psrecord` to profile memory and CPU usage. \"\"\" log_directory = get_benchmark_directory(directory, executable, runtime_sec, rmw, create=True) logfile = log_directory/f'memory_log.txt' plotfile = log_directory/f'memory_log.png' psrecord_cmd = subprocess.run('command -v psrecord', shell=True, stdout=subprocess.DEVNULL) if psrecord_cmd.returncode != 0: raise RuntimeError('psrecord is not installed; install it with pip install -U psrecord') with terminatingRos2Run(pkg, executable, rmw, stdout=subprocess.DEVNULL) as rosprocess: # Note: psrecord does provide a duration argument, but it just kills its subprocess # using SIGKILL, which does not reliably terminate ROS programs. # We therefore run psrecord inside the terminatingRos2Run instead. tracerprocess = subprocess.Popen(f'psrecord --include-children ' + f'--log {logfile} ' + f'--plot {plotfile} ' + f'{rosprocess.pid} ', shell=True) time.sleep(runtime_sec+0.5) tracerprocess.wait(20) def generate_trace(trace_type, *args, **kwargs): if trace_type == 'memory': return generate_memory_trace(*args, **kwargs) elif trace_type == 'callback': return generate_callback_trace(*args, **kwargs) elif trace_type == 'std': return generate_std_trace(*args, **kwargs) else: raise ValueError(f'Invalid trace_type: {trace_type}') def generate_callback_report(executable, pkg, directory, runtime_sec, rmw): \"\"\"Generate a per-executable report from the 'callback' trace file.\"\"\" if not tracetools_available: raise RuntimeError('Unable to import tracetools_trace. Are the tracetools installed?') log_directory = get_benchmark_directory(directory, executable, runtime_sec, rmw) duration_output = log_directory/'callback_duration_report.html' dropped_msgs_output = log_directory/'tracing_latency_and_dropped_messages_report.html' data_model = initDataModel(log_directory/'callback_trace') bokeh_output_file(filename=duration_output, title='Callback Duration Report') print('Output report to', duration_output) duration_summary = callback_duration.summary( data_model=data_model, size=SIZE_SUMMARY) duration_individual = callback_duration.individual( data_model=data_model, size=SIZE_SUBPLOT) report = bokeh_layout([[duration_summary], *duration_individual]) bokeh_save(report) bokeh_output_file(filename=dropped_msgs_output, title='ROS 2 Tracing Latency and Dropped Messages Report') print('Output report to', dropped_msgs_output) dropped_msgs = dropped_messages.individual( data_model=data_model, size=SIZE_SUMMARY) report = bokeh_layout([[dropped_msgs]]) bokeh_save(report) def generate_memory_report(executable, pkg, directory, runtime_sec, rmw): \"\"\"Generate a per-executable report from the 'memory' trace file.\"\"\" log_directory = get_benchmark_directory(directory, executable, runtime_sec, rmw) output = log_directory/'memory_and_cpu_usage_report.html' input_path = log_directory/'memory_log.txt' bokeh_output_file(filename=output, title='Memory and CPU Usage Report') print('Output report to', output) mem_individual = memory_usage.individual(input_path, size=SIZE_SUMMARY) report = bokeh_layout([*mem_individual]) bokeh_save(report) def generate_report(trace_type, *args, **kwargs): if trace_type == 'memory': return generate_memory_report(*args, **kwargs) elif trace_type == 'callback': return generate_callback_report(*args, **kwargs) elif trace_type == 'std': return None # No postprocessing needed for std trace else: raise ValueError(f'Invalid trace_type: {trace_type}') def generate_summary_report(trace_type, pkg, directory, runtime_sec): \"\"\"Generate a summary report for the given `trace_type`, using all traces under `directory`.\"\"\" trace_dirs = get_benchmark_directories_below(directory, runtime_sec=runtime_sec) if trace_type == 'memory': output_file = f'{directory}/memory_and_cpu_usage_summary_report_{runtime_sec}s.html' bokeh_output_file(filename=output_file, title='Memory Usage Report') mem_summary = memory_usage.summary_from_directories(trace_dirs, duration=runtime_sec, size=SIZE_SUMMARY) report = bokeh_layout([*mem_summary]) elif trace_type == 'std': output_file = f'{directory}/executor_kpi_summary_report_{runtime_sec}s.html' bokeh_output_file(filename=output_file, title='Executor Key Performance Indicator (KPI) Report') std_summary = std_latency.summary_from_directories(trace_dirs, duration=runtime_sec, size=SIZE_SUMMARY) report = bokeh_layout([*std_summary]) else: raise NotImplementedError(f'Unsupported trace type {trace_type}') print('Output report to', output_file) bokeh_save(report) def setup_benchmark_directory(pkg, create=False): base_dir = ROS_HOME/f'benchmark_{pkg}' if not create: latest = base_dir/'latest' if not latest.exists(): raise FileNotFoundError(f'Benchmark directory {base_dir} does not exist') return latest base_dir.mkdir(exist_ok=True, parents=True) # Create a subdirectory with a timestamp and link 'latest' to it. timestamp = time.strftime('%Y-%m-%d-%H-%M-%S') benchmark_dir = base_dir/timestamp latest_symlink = base_dir/'latest' latest_symlink.unlink(missing_ok=True) latest_symlink.symlink_to(benchmark_dir) return benchmark_dir Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/sample__management_8hpp/","text":"reference_system/include/reference_system/sample_management.hpp Classes Name class SampleManagementSettings A singleton for sample management settings that may differ between experiments. struct statistic_value_t struct sample_statistic_t Functions Name void set_benchmark_mode (const bool benchmark_mode) bool is_in_benchmark_mode () uint64_t now_as_int () template <typename SampleTypePointer > void set_sample (const std::string & node_name, const uint32_t sequence_number, const uint32_t dropped_samples, const uint64_t timestamp, SampleTypePointer & sample) template <typename SampleTypePointer > uint64_t get_sample_timestamp (const SampleTypePointer & sample) template <typename SampleTypePointer > uint32_t get_sample_sequence_number (const SampleTypePointer & sample) template <typename SampleTypePointer > uint32_t get_missed_samples_and_update_seq_nr (const SampleTypePointer & sample, uint32_t & sequence_number) template <typename SampleTypePointer ,typename SourceType > void merge_history_into_sample (SampleTypePointer & sample, const SourceType & source) std::ostream & operator<< (std::ostream & output, const statistic_value_t & v) template <typename SampleTypePointer > void print_sample_path (const std::string & node_name, const uint32_t lost_samples, const SampleTypePointer & sample) Functions Documentation function set_benchmark_mode void set_benchmark_mode( const bool benchmark_mode ) function is_in_benchmark_mode bool is_in_benchmark_mode() function now_as_int uint64_t now_as_int() function set_sample template <typename SampleTypePointer > void set_sample( const std::string & node_name, const uint32_t sequence_number, const uint32_t dropped_samples, const uint64_t timestamp, SampleTypePointer & sample ) function get_sample_timestamp template <typename SampleTypePointer > uint64_t get_sample_timestamp( const SampleTypePointer & sample ) function get_sample_sequence_number template <typename SampleTypePointer > uint32_t get_sample_sequence_number( const SampleTypePointer & sample ) function get_missed_samples_and_update_seq_nr template <typename SampleTypePointer > uint32_t get_missed_samples_and_update_seq_nr( const SampleTypePointer & sample, uint32_t & sequence_number ) function merge_history_into_sample template <typename SampleTypePointer , typename SourceType > void merge_history_into_sample( SampleTypePointer & sample, const SourceType & source ) function operator<< std::ostream & operator<<( std::ostream & output, const statistic_value_t & v ) function print_sample_path template <typename SampleTypePointer > void print_sample_path( const std::string & node_name, const uint32_t lost_samples, const SampleTypePointer & sample ) Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__SAMPLE_MANAGEMENT_HPP_ #define REFERENCE_SYSTEM__SAMPLE_MANAGEMENT_HPP_ #include <algorithm> #include <chrono> #include <iostream> #include <limits> #include <map> #include <mutex> #include <string> #include <vector> #include <cmath> #include <set> #include \"reference_system/msg_types.hpp\" class SampleManagementSettings { public: static SampleManagementSettings & get() { static SampleManagementSettings settings; return settings; } void set_hot_path( const std::set<std::string> & hot_path_nodes, const std::set<std::string> & hot_path_roots, const std::string & hot_path_sink) { m_hot_path_nodes = hot_path_nodes; m_hot_path_roots = hot_path_roots; m_hot_path_sink = hot_path_sink; } const std::string & hot_path_sink() const noexcept { return m_hot_path_sink; } bool is_hot_path_root(const std::string & name) const noexcept { return m_hot_path_roots.count(name) > 0; } bool is_hot_path_node(const std::string & name) const noexcept { return m_hot_path_nodes.count(name) > 0; } std::string hot_path_name() const noexcept { std::string roots_name; for (const auto & root : m_hot_path_roots) { if (roots_name != \"\") { roots_name += \"/\"; } roots_name += root; } return roots_name + \" -> \" + hot_path_sink(); } void set_benchmark_mode(bool value) { m_benchmark_mode = value; } bool is_in_benchmark_mode() const noexcept { return m_benchmark_mode; } private: bool m_benchmark_mode; std::set<std::string> m_hot_path_nodes; std::set<std::string> m_hot_path_roots; std::string m_hot_path_sink; SampleManagementSettings() : m_benchmark_mode(false) {} }; void set_benchmark_mode(const bool benchmark_mode) { SampleManagementSettings::get().set_benchmark_mode(benchmark_mode); } bool is_in_benchmark_mode() { return SampleManagementSettings::get().is_in_benchmark_mode(); } uint64_t now_as_int() { const auto now = std::chrono::system_clock::now().time_since_epoch(); return static_cast<uint64_t>( std::chrono::duration_cast<std::chrono::nanoseconds>(now).count()); } template<typename SampleTypePointer> void set_sample( const std::string & node_name, const uint32_t sequence_number, const uint32_t dropped_samples, const uint64_t timestamp, SampleTypePointer & sample) { if (is_in_benchmark_mode()) { return; } if (sample.size >= message_t::STATS_CAPACITY) { return; } uint64_t idx = sample.size; ++sample.size; const size_t name_len = std::min( node_name.size(), sample.stats[idx].node_name.size() - 1); memcpy(sample.stats[idx].node_name.data(), node_name.data(), name_len); sample.stats[idx].node_name[name_len] = '\\0'; sample.stats[idx].timestamp = timestamp; sample.stats[idx].sequence_number = sequence_number; sample.stats[idx].dropped_samples = dropped_samples; } template<typename SampleTypePointer> uint64_t get_sample_timestamp(const SampleTypePointer & sample) { if (is_in_benchmark_mode() || sample->size == 0) { return 0; } else { return sample->stats[sample->size - 1].timestamp; } } template<typename SampleTypePointer> uint32_t get_sample_sequence_number(const SampleTypePointer & sample) { if (is_in_benchmark_mode() || sample->size == 0) { return 0; } else { return sample->stats[sample->size - 1].sequence_number; } } template<typename SampleTypePointer> uint32_t get_missed_samples_and_update_seq_nr( const SampleTypePointer & sample, uint32_t & sequence_number) { uint32_t updated_seq_nr = get_sample_sequence_number(sample); uint32_t missed_samples = (updated_seq_nr > sequence_number) ? updated_seq_nr - sequence_number - 1 : 0; sequence_number = updated_seq_nr; return missed_samples; } template<typename SampleTypePointer, typename SourceType> void merge_history_into_sample( SampleTypePointer & sample, const SourceType & source) { if (is_in_benchmark_mode()) { return; } std::vector<uint64_t> entries_to_add; for (uint64_t i = 0; i < source->size; ++i) { bool entry_found = false; // The unsigned char* returned by data() needs to be casted to char* std::string source_name(reinterpret_cast<const char *>(source->stats[i].node_name.data())); for (uint64_t k = 0; k < sample.size; ++k) { // The unsigned char* returned by data() needs to be casted to char* std::string sample_name(reinterpret_cast<const char *>(sample.stats[k].node_name.data())); if (source_name == sample_name) { entry_found = true; break; } } if (!entry_found) { entries_to_add.emplace_back(i); } } for (auto i : entries_to_add) { memcpy( sample.stats.data() + sample.size, source->stats.data() + i, sizeof(reference_interfaces::msg::TransmissionStats)); ++sample.size; } } struct statistic_value_t { double average = 0.0; double deviation = 0.0; uint64_t min = std::numeric_limits<uint64_t>::max(); uint64_t max = 0; uint64_t current = 0; double total_number = 0.0; std::string suffix; double adjustment = 0.0; double m2 = 0.0; void set(const uint64_t value) { // Use Welford's online algorithm to calculate deviation ++total_number; current = value; // Ensure uint64_t is smaller than double on the current system if (std::numeric_limits<uint64_t>::max() > std::numeric_limits<double>::max()) { if (static_cast<double>(value) > std::numeric_limits<double>::max()) { throw std::overflow_error(\"Passed statistics sample is too large for a double\"); } } double value_d = static_cast<double>(value); auto previous_delta = value_d - average; average += previous_delta / total_number; auto new_delta = value_d - average; m2 += (previous_delta * new_delta); deviation = std::sqrt(m2 / (total_number - 1)); min = std::min(min, value); max = std::max(max, value); } }; struct sample_statistic_t { uint64_t timepoint_of_first_received_sample = 0; uint32_t previous_behavior_planner_sequence = 0; uint64_t previous_behavior_planner_time_stamp = 0; statistic_value_t latency; statistic_value_t hot_path_latency; statistic_value_t behavior_planner_period; }; std::ostream & operator<<(std::ostream & output, const statistic_value_t & v) { if (v.adjustment == 0.0) { output << v.current << v.suffix << \" [min=\" << v.min << v.suffix << \", max=\" << v.max << v.suffix << \", average=\" << v.average << v.suffix << \", deviation=\" << v.deviation << \"]\"; } else { output << static_cast<double>(v.current) / v.adjustment << v.suffix << \" [min=\" << static_cast<double>(v.min) / v.adjustment << v.suffix << \", max=\" << static_cast<double>(v.max) / v.adjustment << v.suffix << \", average=\" << v.average / v.adjustment << v.suffix << \", deviation=\" << v.deviation / v.adjustment << v.suffix << \"]\"; } return output; } template<typename SampleTypePointer> void print_sample_path( const std::string & node_name, const uint32_t lost_samples, const SampleTypePointer & sample) { static int benchmark_counter = 0; ++benchmark_counter; // benchmark_counter = dismissing first 100 samples to get rid of startup // jitter if (is_in_benchmark_mode() || sample->size <= 0 || benchmark_counter < 10) { return; } static std::map<std::string, sample_statistic_t> advanced_statistics; static std::map<std::string, std::map<std::string, statistic_value_t>> dropped_samples; auto iter = advanced_statistics.find(node_name); if (iter == advanced_statistics.end()) { advanced_statistics[node_name].timepoint_of_first_received_sample = now_as_int(); advanced_statistics[node_name].latency.suffix = \"ms\"; advanced_statistics[node_name].latency.adjustment = 1000000.0; advanced_statistics[node_name].hot_path_latency.suffix = \"ms\"; advanced_statistics[node_name].hot_path_latency.adjustment = 1000000.0; advanced_statistics[node_name].behavior_planner_period.suffix = \"ms\"; advanced_statistics[node_name].behavior_planner_period.adjustment = 1000000.0; } const uint64_t timestamp_in_ns = static_cast<uint64_t>( std::chrono::duration_cast<std::chrono::nanoseconds>( std::chrono::system_clock::now().time_since_epoch()) .count()); static std::mutex cout_mutex; std::lock_guard<std::mutex> lock(cout_mutex); std::cout << \"----------------------------------------------------------\" << std::endl; std::cout << \"sample path: (\" << node_name << \") \" << std::endl; std::cout << \" order timepoint sequence nr. node \" \"name dropped samples\" << std::endl; std::map<uint64_t, uint64_t> timestamp2Order; uint64_t min_time_stamp = std::numeric_limits<uint64_t>::max(); for (uint64_t i = 0; i < sample->size; ++i) { timestamp2Order[sample->stats[i].timestamp] = 0; min_time_stamp = std::min(min_time_stamp, sample->stats[i].timestamp); } uint64_t i = 0; for (auto & e : timestamp2Order) { e.second = i++; } (void)lost_samples; // to avoid unused param warning in Clang #if 0 for (uint64_t i = 0; i < sample->size; ++i) { std::string name((const char *)sample->stats[i].node_name.data()); std::cout << \" [\"; std::cout.width(2); std::cout << timestamp2Order[sample->stats[i].timestamp]; std::cout << \"] \" << sample->stats[i].timestamp << \" \"; std::cout.width(10); std::cout << sample->stats[i].sequence_number; std::cout << \" \"; std::cout.width(24); std::cout << name; std::cout << \" \"; dropped_samples[node_name][name].set(sample->stats[i].dropped_samples); std::cout << dropped_samples[node_name][name]; std::cout << std::endl; } std::cout << \" [\"; std::cout.width(2); std::cout << timestamp2Order.size(); std::cout << \"] \" << timestamp_in_ns << \" \"; std::cout.width(10); std::cout << \"endpoint\"; std::cout << \" \"; std::cout.width(24); std::cout << node_name; std::cout << \" \"; dropped_samples[node_name][node_name].set(lost_samples); std::cout << dropped_samples[node_name][node_name]; std::cout << std::endl; #endif // hot path latency uint64_t hot_path_latency_in_ns = 0; bool does_contain_hot_path = false; uint64_t root_timestamp = 0; const auto settings = SampleManagementSettings::get(); for (uint64_t i = 0; i < sample->size; ++i) { uint64_t idx = sample->size - i - 1; std::string current_node_name( reinterpret_cast<const char *>(sample->stats[idx].node_name.data())); if (settings.is_hot_path_root(current_node_name)) { root_timestamp = std::max(root_timestamp, sample->stats[idx].timestamp); } if (current_node_name == settings.hot_path_sink()) { hot_path_latency_in_ns = sample->stats[idx].timestamp; does_contain_hot_path = true; } } hot_path_latency_in_ns -= root_timestamp; // hot path drops uint64_t hot_path_drops = 0; if (does_contain_hot_path) { for (uint64_t i = 0; i < sample->size; ++i) { uint64_t idx = sample->size - i - 1; std::string current_node_name( reinterpret_cast<const char *>(sample->stats[idx].node_name.data())); if (settings.is_hot_path_node(current_node_name) > 0) { hot_path_drops += sample->stats[idx].dropped_samples; } } } // behavior planner cycle time bool does_contain_behavior_planner = false; for (uint64_t i = 0; i < sample->size; ++i) { std::string current_node_name( reinterpret_cast<const char *>(sample->stats[i].node_name.data())); if (current_node_name == \"BehaviorPlanner\") { does_contain_behavior_planner = true; auto seq_nr = sample->stats[i].sequence_number; auto timestamp = sample->stats[i].timestamp; auto prev_seq_nr = advanced_statistics[node_name].previous_behavior_planner_sequence; auto prev_timestamp = advanced_statistics[node_name].previous_behavior_planner_time_stamp; if (prev_timestamp != 0) { std::cout << \"bp period\" << std::endl; advanced_statistics[node_name].behavior_planner_period.set( static_cast<uint64_t>(static_cast<double>(timestamp - prev_timestamp) / static_cast<double>(seq_nr - prev_seq_nr))); } advanced_statistics[node_name].previous_behavior_planner_sequence = seq_nr; advanced_statistics[node_name].previous_behavior_planner_time_stamp = timestamp; } } std::cout << \"latency\" << std::endl; advanced_statistics[node_name].latency.set(timestamp_in_ns - min_time_stamp); std::cout << std::endl; std::cout << \"Statistics:\" << std::endl; std::cout << \" latency: \" << advanced_statistics[node_name].latency << std::endl; if (does_contain_hot_path) { std::cout << \"hotpath\" << std::endl; dropped_samples[node_name][\"hotpath\"].set(hot_path_drops); advanced_statistics[node_name].hot_path_latency.set(hot_path_latency_in_ns); std::cout << \" hot path: \" << settings.hot_path_name() << std::endl; std::cout << \" hot path latency: \" << advanced_statistics[node_name].hot_path_latency << std::endl; std::cout << \" hot path drops: \" << dropped_samples[node_name][\"hotpath\"] << std::endl; } if (does_contain_behavior_planner) { std::cout << \" behavior planner period: \" << advanced_statistics[node_name].behavior_planner_period << std::endl; } std::cout << \"----------------------------------------------------------\" << std::endl; std::cout << std::endl; } #endif // REFERENCE_SYSTEM__SAMPLE_MANAGEMENT_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/include/reference_system/sample_management.hpp"},{"location":"Files/sample__management_8hpp/#reference_systemincludereference_systemsample_managementhpp","text":"","title":"reference_system/include/reference_system/sample_management.hpp"},{"location":"Files/sample__management_8hpp/#classes","text":"Name class SampleManagementSettings A singleton for sample management settings that may differ between experiments. struct statistic_value_t struct sample_statistic_t","title":"Classes"},{"location":"Files/sample__management_8hpp/#functions","text":"Name void set_benchmark_mode (const bool benchmark_mode) bool is_in_benchmark_mode () uint64_t now_as_int () template <typename SampleTypePointer > void set_sample (const std::string & node_name, const uint32_t sequence_number, const uint32_t dropped_samples, const uint64_t timestamp, SampleTypePointer & sample) template <typename SampleTypePointer > uint64_t get_sample_timestamp (const SampleTypePointer & sample) template <typename SampleTypePointer > uint32_t get_sample_sequence_number (const SampleTypePointer & sample) template <typename SampleTypePointer > uint32_t get_missed_samples_and_update_seq_nr (const SampleTypePointer & sample, uint32_t & sequence_number) template <typename SampleTypePointer ,typename SourceType > void merge_history_into_sample (SampleTypePointer & sample, const SourceType & source) std::ostream & operator<< (std::ostream & output, const statistic_value_t & v) template <typename SampleTypePointer > void print_sample_path (const std::string & node_name, const uint32_t lost_samples, const SampleTypePointer & sample)","title":"Functions"},{"location":"Files/sample__management_8hpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/sample__management_8hpp/#function-set_benchmark_mode","text":"void set_benchmark_mode( const bool benchmark_mode )","title":"function set_benchmark_mode"},{"location":"Files/sample__management_8hpp/#function-is_in_benchmark_mode","text":"bool is_in_benchmark_mode()","title":"function is_in_benchmark_mode"},{"location":"Files/sample__management_8hpp/#function-now_as_int","text":"uint64_t now_as_int()","title":"function now_as_int"},{"location":"Files/sample__management_8hpp/#function-set_sample","text":"template <typename SampleTypePointer > void set_sample( const std::string & node_name, const uint32_t sequence_number, const uint32_t dropped_samples, const uint64_t timestamp, SampleTypePointer & sample )","title":"function set_sample"},{"location":"Files/sample__management_8hpp/#function-get_sample_timestamp","text":"template <typename SampleTypePointer > uint64_t get_sample_timestamp( const SampleTypePointer & sample )","title":"function get_sample_timestamp"},{"location":"Files/sample__management_8hpp/#function-get_sample_sequence_number","text":"template <typename SampleTypePointer > uint32_t get_sample_sequence_number( const SampleTypePointer & sample )","title":"function get_sample_sequence_number"},{"location":"Files/sample__management_8hpp/#function-get_missed_samples_and_update_seq_nr","text":"template <typename SampleTypePointer > uint32_t get_missed_samples_and_update_seq_nr( const SampleTypePointer & sample, uint32_t & sequence_number )","title":"function get_missed_samples_and_update_seq_nr"},{"location":"Files/sample__management_8hpp/#function-merge_history_into_sample","text":"template <typename SampleTypePointer , typename SourceType > void merge_history_into_sample( SampleTypePointer & sample, const SourceType & source )","title":"function merge_history_into_sample"},{"location":"Files/sample__management_8hpp/#function-operator","text":"std::ostream & operator<<( std::ostream & output, const statistic_value_t & v )","title":"function operator&lt;&lt;"},{"location":"Files/sample__management_8hpp/#function-print_sample_path","text":"template <typename SampleTypePointer > void print_sample_path( const std::string & node_name, const uint32_t lost_samples, const SampleTypePointer & sample )","title":"function print_sample_path"},{"location":"Files/sample__management_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__SAMPLE_MANAGEMENT_HPP_ #define REFERENCE_SYSTEM__SAMPLE_MANAGEMENT_HPP_ #include <algorithm> #include <chrono> #include <iostream> #include <limits> #include <map> #include <mutex> #include <string> #include <vector> #include <cmath> #include <set> #include \"reference_system/msg_types.hpp\" class SampleManagementSettings { public: static SampleManagementSettings & get() { static SampleManagementSettings settings; return settings; } void set_hot_path( const std::set<std::string> & hot_path_nodes, const std::set<std::string> & hot_path_roots, const std::string & hot_path_sink) { m_hot_path_nodes = hot_path_nodes; m_hot_path_roots = hot_path_roots; m_hot_path_sink = hot_path_sink; } const std::string & hot_path_sink() const noexcept { return m_hot_path_sink; } bool is_hot_path_root(const std::string & name) const noexcept { return m_hot_path_roots.count(name) > 0; } bool is_hot_path_node(const std::string & name) const noexcept { return m_hot_path_nodes.count(name) > 0; } std::string hot_path_name() const noexcept { std::string roots_name; for (const auto & root : m_hot_path_roots) { if (roots_name != \"\") { roots_name += \"/\"; } roots_name += root; } return roots_name + \" -> \" + hot_path_sink(); } void set_benchmark_mode(bool value) { m_benchmark_mode = value; } bool is_in_benchmark_mode() const noexcept { return m_benchmark_mode; } private: bool m_benchmark_mode; std::set<std::string> m_hot_path_nodes; std::set<std::string> m_hot_path_roots; std::string m_hot_path_sink; SampleManagementSettings() : m_benchmark_mode(false) {} }; void set_benchmark_mode(const bool benchmark_mode) { SampleManagementSettings::get().set_benchmark_mode(benchmark_mode); } bool is_in_benchmark_mode() { return SampleManagementSettings::get().is_in_benchmark_mode(); } uint64_t now_as_int() { const auto now = std::chrono::system_clock::now().time_since_epoch(); return static_cast<uint64_t>( std::chrono::duration_cast<std::chrono::nanoseconds>(now).count()); } template<typename SampleTypePointer> void set_sample( const std::string & node_name, const uint32_t sequence_number, const uint32_t dropped_samples, const uint64_t timestamp, SampleTypePointer & sample) { if (is_in_benchmark_mode()) { return; } if (sample.size >= message_t::STATS_CAPACITY) { return; } uint64_t idx = sample.size; ++sample.size; const size_t name_len = std::min( node_name.size(), sample.stats[idx].node_name.size() - 1); memcpy(sample.stats[idx].node_name.data(), node_name.data(), name_len); sample.stats[idx].node_name[name_len] = '\\0'; sample.stats[idx].timestamp = timestamp; sample.stats[idx].sequence_number = sequence_number; sample.stats[idx].dropped_samples = dropped_samples; } template<typename SampleTypePointer> uint64_t get_sample_timestamp(const SampleTypePointer & sample) { if (is_in_benchmark_mode() || sample->size == 0) { return 0; } else { return sample->stats[sample->size - 1].timestamp; } } template<typename SampleTypePointer> uint32_t get_sample_sequence_number(const SampleTypePointer & sample) { if (is_in_benchmark_mode() || sample->size == 0) { return 0; } else { return sample->stats[sample->size - 1].sequence_number; } } template<typename SampleTypePointer> uint32_t get_missed_samples_and_update_seq_nr( const SampleTypePointer & sample, uint32_t & sequence_number) { uint32_t updated_seq_nr = get_sample_sequence_number(sample); uint32_t missed_samples = (updated_seq_nr > sequence_number) ? updated_seq_nr - sequence_number - 1 : 0; sequence_number = updated_seq_nr; return missed_samples; } template<typename SampleTypePointer, typename SourceType> void merge_history_into_sample( SampleTypePointer & sample, const SourceType & source) { if (is_in_benchmark_mode()) { return; } std::vector<uint64_t> entries_to_add; for (uint64_t i = 0; i < source->size; ++i) { bool entry_found = false; // The unsigned char* returned by data() needs to be casted to char* std::string source_name(reinterpret_cast<const char *>(source->stats[i].node_name.data())); for (uint64_t k = 0; k < sample.size; ++k) { // The unsigned char* returned by data() needs to be casted to char* std::string sample_name(reinterpret_cast<const char *>(sample.stats[k].node_name.data())); if (source_name == sample_name) { entry_found = true; break; } } if (!entry_found) { entries_to_add.emplace_back(i); } } for (auto i : entries_to_add) { memcpy( sample.stats.data() + sample.size, source->stats.data() + i, sizeof(reference_interfaces::msg::TransmissionStats)); ++sample.size; } } struct statistic_value_t { double average = 0.0; double deviation = 0.0; uint64_t min = std::numeric_limits<uint64_t>::max(); uint64_t max = 0; uint64_t current = 0; double total_number = 0.0; std::string suffix; double adjustment = 0.0; double m2 = 0.0; void set(const uint64_t value) { // Use Welford's online algorithm to calculate deviation ++total_number; current = value; // Ensure uint64_t is smaller than double on the current system if (std::numeric_limits<uint64_t>::max() > std::numeric_limits<double>::max()) { if (static_cast<double>(value) > std::numeric_limits<double>::max()) { throw std::overflow_error(\"Passed statistics sample is too large for a double\"); } } double value_d = static_cast<double>(value); auto previous_delta = value_d - average; average += previous_delta / total_number; auto new_delta = value_d - average; m2 += (previous_delta * new_delta); deviation = std::sqrt(m2 / (total_number - 1)); min = std::min(min, value); max = std::max(max, value); } }; struct sample_statistic_t { uint64_t timepoint_of_first_received_sample = 0; uint32_t previous_behavior_planner_sequence = 0; uint64_t previous_behavior_planner_time_stamp = 0; statistic_value_t latency; statistic_value_t hot_path_latency; statistic_value_t behavior_planner_period; }; std::ostream & operator<<(std::ostream & output, const statistic_value_t & v) { if (v.adjustment == 0.0) { output << v.current << v.suffix << \" [min=\" << v.min << v.suffix << \", max=\" << v.max << v.suffix << \", average=\" << v.average << v.suffix << \", deviation=\" << v.deviation << \"]\"; } else { output << static_cast<double>(v.current) / v.adjustment << v.suffix << \" [min=\" << static_cast<double>(v.min) / v.adjustment << v.suffix << \", max=\" << static_cast<double>(v.max) / v.adjustment << v.suffix << \", average=\" << v.average / v.adjustment << v.suffix << \", deviation=\" << v.deviation / v.adjustment << v.suffix << \"]\"; } return output; } template<typename SampleTypePointer> void print_sample_path( const std::string & node_name, const uint32_t lost_samples, const SampleTypePointer & sample) { static int benchmark_counter = 0; ++benchmark_counter; // benchmark_counter = dismissing first 100 samples to get rid of startup // jitter if (is_in_benchmark_mode() || sample->size <= 0 || benchmark_counter < 10) { return; } static std::map<std::string, sample_statistic_t> advanced_statistics; static std::map<std::string, std::map<std::string, statistic_value_t>> dropped_samples; auto iter = advanced_statistics.find(node_name); if (iter == advanced_statistics.end()) { advanced_statistics[node_name].timepoint_of_first_received_sample = now_as_int(); advanced_statistics[node_name].latency.suffix = \"ms\"; advanced_statistics[node_name].latency.adjustment = 1000000.0; advanced_statistics[node_name].hot_path_latency.suffix = \"ms\"; advanced_statistics[node_name].hot_path_latency.adjustment = 1000000.0; advanced_statistics[node_name].behavior_planner_period.suffix = \"ms\"; advanced_statistics[node_name].behavior_planner_period.adjustment = 1000000.0; } const uint64_t timestamp_in_ns = static_cast<uint64_t>( std::chrono::duration_cast<std::chrono::nanoseconds>( std::chrono::system_clock::now().time_since_epoch()) .count()); static std::mutex cout_mutex; std::lock_guard<std::mutex> lock(cout_mutex); std::cout << \"----------------------------------------------------------\" << std::endl; std::cout << \"sample path: (\" << node_name << \") \" << std::endl; std::cout << \" order timepoint sequence nr. node \" \"name dropped samples\" << std::endl; std::map<uint64_t, uint64_t> timestamp2Order; uint64_t min_time_stamp = std::numeric_limits<uint64_t>::max(); for (uint64_t i = 0; i < sample->size; ++i) { timestamp2Order[sample->stats[i].timestamp] = 0; min_time_stamp = std::min(min_time_stamp, sample->stats[i].timestamp); } uint64_t i = 0; for (auto & e : timestamp2Order) { e.second = i++; } (void)lost_samples; // to avoid unused param warning in Clang #if 0 for (uint64_t i = 0; i < sample->size; ++i) { std::string name((const char *)sample->stats[i].node_name.data()); std::cout << \" [\"; std::cout.width(2); std::cout << timestamp2Order[sample->stats[i].timestamp]; std::cout << \"] \" << sample->stats[i].timestamp << \" \"; std::cout.width(10); std::cout << sample->stats[i].sequence_number; std::cout << \" \"; std::cout.width(24); std::cout << name; std::cout << \" \"; dropped_samples[node_name][name].set(sample->stats[i].dropped_samples); std::cout << dropped_samples[node_name][name]; std::cout << std::endl; } std::cout << \" [\"; std::cout.width(2); std::cout << timestamp2Order.size(); std::cout << \"] \" << timestamp_in_ns << \" \"; std::cout.width(10); std::cout << \"endpoint\"; std::cout << \" \"; std::cout.width(24); std::cout << node_name; std::cout << \" \"; dropped_samples[node_name][node_name].set(lost_samples); std::cout << dropped_samples[node_name][node_name]; std::cout << std::endl; #endif // hot path latency uint64_t hot_path_latency_in_ns = 0; bool does_contain_hot_path = false; uint64_t root_timestamp = 0; const auto settings = SampleManagementSettings::get(); for (uint64_t i = 0; i < sample->size; ++i) { uint64_t idx = sample->size - i - 1; std::string current_node_name( reinterpret_cast<const char *>(sample->stats[idx].node_name.data())); if (settings.is_hot_path_root(current_node_name)) { root_timestamp = std::max(root_timestamp, sample->stats[idx].timestamp); } if (current_node_name == settings.hot_path_sink()) { hot_path_latency_in_ns = sample->stats[idx].timestamp; does_contain_hot_path = true; } } hot_path_latency_in_ns -= root_timestamp; // hot path drops uint64_t hot_path_drops = 0; if (does_contain_hot_path) { for (uint64_t i = 0; i < sample->size; ++i) { uint64_t idx = sample->size - i - 1; std::string current_node_name( reinterpret_cast<const char *>(sample->stats[idx].node_name.data())); if (settings.is_hot_path_node(current_node_name) > 0) { hot_path_drops += sample->stats[idx].dropped_samples; } } } // behavior planner cycle time bool does_contain_behavior_planner = false; for (uint64_t i = 0; i < sample->size; ++i) { std::string current_node_name( reinterpret_cast<const char *>(sample->stats[i].node_name.data())); if (current_node_name == \"BehaviorPlanner\") { does_contain_behavior_planner = true; auto seq_nr = sample->stats[i].sequence_number; auto timestamp = sample->stats[i].timestamp; auto prev_seq_nr = advanced_statistics[node_name].previous_behavior_planner_sequence; auto prev_timestamp = advanced_statistics[node_name].previous_behavior_planner_time_stamp; if (prev_timestamp != 0) { std::cout << \"bp period\" << std::endl; advanced_statistics[node_name].behavior_planner_period.set( static_cast<uint64_t>(static_cast<double>(timestamp - prev_timestamp) / static_cast<double>(seq_nr - prev_seq_nr))); } advanced_statistics[node_name].previous_behavior_planner_sequence = seq_nr; advanced_statistics[node_name].previous_behavior_planner_time_stamp = timestamp; } } std::cout << \"latency\" << std::endl; advanced_statistics[node_name].latency.set(timestamp_in_ns - min_time_stamp); std::cout << std::endl; std::cout << \"Statistics:\" << std::endl; std::cout << \" latency: \" << advanced_statistics[node_name].latency << std::endl; if (does_contain_hot_path) { std::cout << \"hotpath\" << std::endl; dropped_samples[node_name][\"hotpath\"].set(hot_path_drops); advanced_statistics[node_name].hot_path_latency.set(hot_path_latency_in_ns); std::cout << \" hot path: \" << settings.hot_path_name() << std::endl; std::cout << \" hot path latency: \" << advanced_statistics[node_name].hot_path_latency << std::endl; std::cout << \" hot path drops: \" << dropped_samples[node_name][\"hotpath\"] << std::endl; } if (does_contain_behavior_planner) { std::cout << \" behavior planner period: \" << advanced_statistics[node_name].behavior_planner_period << std::endl; } std::cout << \"----------------------------------------------------------\" << std::endl; std::cout << std::endl; } #endif // REFERENCE_SYSTEM__SAMPLE_MANAGEMENT_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/sensor_8hpp/","text":"reference_system/include/reference_system/nodes/rclcpp/sensor.hpp Namespaces Name nodes nodes::rclcpp_system Classes Name class nodes::rclcpp_system::Sensor Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__RCLCPP__SENSOR_HPP_ #define REFERENCE_SYSTEM__NODES__RCLCPP__SENSOR_HPP_ #include <chrono> #include <string> #include <utility> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/msg_types.hpp\" #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/sample_management.hpp\" namespace nodes { namespace rclcpp_system { class Sensor : public rclcpp::Node { public: explicit Sensor(const SensorSettings & settings) : Node(settings.node_name) { publisher_ = this->create_publisher<message_t>(settings.topic_name, 1); timer_ = this->create_wall_timer( settings.cycle_time, [this] {timer_callback();}); } private: void timer_callback() { uint64_t timestamp = now_as_int(); auto message = publisher_->borrow_loaned_message(); message.get().size = 0; set_sample( this->get_name(), sequence_number_++, 0, timestamp, message.get()); publisher_->publish(std::move(message)); } private: rclcpp::Publisher<message_t>::SharedPtr publisher_; rclcpp::TimerBase::SharedPtr timer_; uint32_t sequence_number_ = 0; }; } // namespace rclcpp_system } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__RCLCPP__SENSOR_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/include/reference_system/nodes/rclcpp/sensor.hpp"},{"location":"Files/sensor_8hpp/#reference_systemincludereference_systemnodesrclcppsensorhpp","text":"","title":"reference_system/include/reference_system/nodes/rclcpp/sensor.hpp"},{"location":"Files/sensor_8hpp/#namespaces","text":"Name nodes nodes::rclcpp_system","title":"Namespaces"},{"location":"Files/sensor_8hpp/#classes","text":"Name class nodes::rclcpp_system::Sensor","title":"Classes"},{"location":"Files/sensor_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__RCLCPP__SENSOR_HPP_ #define REFERENCE_SYSTEM__NODES__RCLCPP__SENSOR_HPP_ #include <chrono> #include <string> #include <utility> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/msg_types.hpp\" #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/sample_management.hpp\" namespace nodes { namespace rclcpp_system { class Sensor : public rclcpp::Node { public: explicit Sensor(const SensorSettings & settings) : Node(settings.node_name) { publisher_ = this->create_publisher<message_t>(settings.topic_name, 1); timer_ = this->create_wall_timer( settings.cycle_time, [this] {timer_callback();}); } private: void timer_callback() { uint64_t timestamp = now_as_int(); auto message = publisher_->borrow_loaned_message(); message.get().size = 0; set_sample( this->get_name(), sequence_number_++, 0, timestamp, message.get()); publisher_->publish(std::move(message)); } private: rclcpp::Publisher<message_t>::SharedPtr publisher_; rclcpp::TimerBase::SharedPtr timer_; uint32_t sequence_number_ = 0; }; } // namespace rclcpp_system } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__RCLCPP__SENSOR_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/settings_8hpp/","text":"reference_system/include/reference_system/nodes/settings.hpp Namespaces Name nodes Classes Name struct nodes::CommandSettings struct nodes::FusionSettings struct nodes::TransformSettings struct nodes::IntersectionSettings struct nodes::IntersectionSettings::Connection struct nodes::CyclicSettings struct nodes::SensorSettings Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__SETTINGS_HPP_ #define REFERENCE_SYSTEM__NODES__SETTINGS_HPP_ #include <chrono> #include <string> #include <vector> namespace nodes { struct CommandSettings { std::string node_name; std::string input_topic; }; struct FusionSettings { std::string node_name; std::string input_0; std::string input_1; std::string output_topic; uint64_t number_crunch_limit; }; struct TransformSettings { std::string node_name; std::string input_topic; std::string output_topic; uint64_t number_crunch_limit; }; struct IntersectionSettings { struct Connection { std::string input_topic; std::string output_topic; uint64_t number_crunch_limit; }; std::string node_name; std::vector<Connection> connections; }; struct CyclicSettings { std::string node_name; std::vector<std::string> inputs; std::string output_topic; uint64_t number_crunch_limit; std::chrono::nanoseconds cycle_time; }; struct SensorSettings { std::string node_name; std::string topic_name; std::chrono::nanoseconds cycle_time; }; } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__SETTINGS_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/include/reference_system/nodes/settings.hpp"},{"location":"Files/settings_8hpp/#reference_systemincludereference_systemnodessettingshpp","text":"","title":"reference_system/include/reference_system/nodes/settings.hpp"},{"location":"Files/settings_8hpp/#namespaces","text":"Name nodes","title":"Namespaces"},{"location":"Files/settings_8hpp/#classes","text":"Name struct nodes::CommandSettings struct nodes::FusionSettings struct nodes::TransformSettings struct nodes::IntersectionSettings struct nodes::IntersectionSettings::Connection struct nodes::CyclicSettings struct nodes::SensorSettings","title":"Classes"},{"location":"Files/settings_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__SETTINGS_HPP_ #define REFERENCE_SYSTEM__NODES__SETTINGS_HPP_ #include <chrono> #include <string> #include <vector> namespace nodes { struct CommandSettings { std::string node_name; std::string input_topic; }; struct FusionSettings { std::string node_name; std::string input_0; std::string input_1; std::string output_topic; uint64_t number_crunch_limit; }; struct TransformSettings { std::string node_name; std::string input_topic; std::string output_topic; uint64_t number_crunch_limit; }; struct IntersectionSettings { struct Connection { std::string input_topic; std::string output_topic; uint64_t number_crunch_limit; }; std::string node_name; std::vector<Connection> connections; }; struct CyclicSettings { std::string node_name; std::vector<std::string> inputs; std::string output_topic; uint64_t number_crunch_limit; std::chrono::nanoseconds cycle_time; }; struct SensorSettings { std::string node_name; std::string topic_name; std::chrono::nanoseconds cycle_time; }; } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__SETTINGS_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/setup_8py/","text":"reference_system/setup.py Namespaces Name setup Source code #!/usr/bin/env python from setuptools import setup package_name = 'reference_system' setup( name=package_name, version='1.0.0', description='Scripts and utilities for the evaluation of executor reference systems', license='Apache 2.0 License', author='Tobias Stark', author_email='tobias.stark@apex.ai', data_files=[ f'share/{package_name}/package.xml', ('share/ament_index/resource_index/packages', [f'resource/{package_name}'])], packages=[package_name], tests_require=[], entry_points={}) Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/setup.py"},{"location":"Files/setup_8py/#reference_systemsetuppy","text":"","title":"reference_system/setup.py"},{"location":"Files/setup_8py/#namespaces","text":"Name setup","title":"Namespaces"},{"location":"Files/setup_8py/#source-code","text":"#!/usr/bin/env python from setuptools import setup package_name = 'reference_system' setup( name=package_name, version='1.0.0', description='Scripts and utilities for the evaluation of executor reference systems', license='Apache 2.0 License', author='Tobias Stark', author_email='tobias.stark@apex.ai', data_files=[ f'share/{package_name}/package.xml', ('share/ament_index/resource_index/packages', [f'resource/{package_name}'])], packages=[package_name], tests_require=[], entry_points={}) Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/std__latency_8py/","text":"reference_system/reference_system_py/std_latency.py Namespaces Name reference_system_py reference_system_py::std_latency Source code # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from collections import defaultdict import re from bokeh.models import ColumnDataSource from bokeh.models.ranges import FactorRange from bokeh.models.widgets.markups import Div from bokeh.models.widgets.tables import DataTable, TableColumn from bokeh.palettes import cividis from bokeh.plotting import figure from bokeh.transform import factor_cmap import pandas as pd from .constants import SIZE_TABLE_ROW, SIZE_TABLE_WIDTH from .plot_utils import plot_barplot def summary_from_directories(dirs, duration, size): data, hot_path_name = parseLogSummaryFromFiles( [directory+'/std_output.log' for directory in dirs], duration) df_dict = { 'exe': [], 'rmw': [], 'type': [], 'low': [], 'mean': [], 'high': [], 'std_dev': [], 'box_top': [], 'box_bottom': [] } def add_row(exe, rmw, data_type, stats): df_dict['exe'].append(exe) df_dict['rmw'].append(rmw) df_dict['type'].append(data_type) for stat, value in stats.items(): df_dict[stat].append(value) df_dict['box_top'].append(stats['mean'] + stats['std_dev']) df_dict['box_bottom'].append(stats['mean'] - stats['std_dev']) for (exe, rmw), results in data.items(): stats = results['hot_path']['latency'][-1] add_row(exe, rmw, 'latency', stats) stats = results['hot_path']['dropped'][-1] add_row(exe, rmw, 'dropped', stats) stats_list = results['behavior_planner']['period'] if stats_list: add_row(exe, rmw, 'period', stats_list[-1]) df = pd.DataFrame.from_dict(df_dict) # sort by exe and rmw df = df.sort_values(['exe', 'rmw'], ascending=True) rmws = list(df.rmw.drop_duplicates()) x = [tuple(x) for x in df[['rmw', 'exe']].drop_duplicates().to_records(index=False)] fill_color = factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=0, end=1) latency = df[df.type == 'latency'] dropped = df[df.type == 'dropped'] period = df[df.type == 'period'] latency_source = ColumnDataSource(latency) dropped_source = ColumnDataSource(dropped) period_source = ColumnDataSource(period) # add exe and rmw list of tuples for x axis latency_source.data['x'] = x dropped_source.data['x'] = x period_source.data['x'] = x # initialize list of figures std_figs = [] # initialize latency figure test_info = str(duration) + 's [' + hot_path_name + ']' columns = [TableColumn(field=field, title=title) for field, title in [('exe', 'Benchmark'), ('rmw', 'RMW'), ('low', 'Min'), ('mean', 'Mean'), ('high', 'Max'), ('std_dev', 'Std. Dev.')]] if not latency.empty: latency_fig = figure( title='Latency Summary ' + test_info, x_axis_label=f'Executors (with RMW)', y_axis_label='Latency (ms)', x_range=FactorRange(*x), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) plot_barplot(latency_fig, latency_source, fill_color=fill_color) latency_table_title = Div( text='<b>Latency Summary Table ' + test_info + '</b>', width=SIZE_TABLE_WIDTH, height=SIZE_TABLE_ROW) latency_table = [ latency_table_title, DataTable( columns=columns, source=ColumnDataSource(latency.round(decimals=3)), autosize_mode='fit_viewport', margin=(0, 10, 10, 10), height=(len(latency.exe.values.tolist()) * SIZE_TABLE_ROW), width=SIZE_TABLE_WIDTH)] std_figs += [[latency_table], [latency_fig]] if not dropped.empty: dropped_fig = figure( title='Dropped Messages Summary ' + test_info, x_axis_label=f'Executors (with RMW)', y_axis_label='Dropped Messages', x_range=FactorRange(*x), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) plot_barplot(dropped_fig, dropped_source, fill_color=fill_color) dropped_table_title = Div( text='<b>Dropped Messages Summary Table ' + test_info + '</b>', width=SIZE_TABLE_WIDTH, height=SIZE_TABLE_ROW) dropped_table = [ dropped_table_title, DataTable( columns=columns, source=ColumnDataSource(dropped.round(decimals=1)), autosize_mode='fit_viewport', margin=(0, 10, 10, 10), height=(len(dropped.exe.values.tolist()) * SIZE_TABLE_ROW), width=SIZE_TABLE_WIDTH)] std_figs += [[dropped_table], [dropped_fig]] if not period.empty: period_fig = figure( title='Behavior Planner Jitter Summary ' + str(duration) + 's', x_axis_label=f'Executors (with RMW)', y_axis_label='Period (ms)', x_range=FactorRange(*x), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) plot_barplot(period_fig, period_source, fill_color=fill_color) period_table_title = Div( text='<b>Behavior Planner Jitter Summary Table ' + str(duration) + 's</b>', width=SIZE_TABLE_WIDTH, height=SIZE_TABLE_ROW) period_table = [ period_table_title, DataTable( columns=columns, source=ColumnDataSource(period.round(decimals=3)), autosize_mode='fit_viewport', margin=(0, 10, 10, 10), height=(len(period.exe.values.tolist()) * SIZE_TABLE_ROW), width=SIZE_TABLE_WIDTH)] std_figs += [[period_table], [period_fig]] return std_figs def parse_stats_from_values(latency_, min_, max_, average_, deviation_): stats = { 'low': float(min_), 'high': float(max_), 'mean': float(average_), 'std_dev': float(deviation_)} return stats def parseLogSummaryFromFiles(files, duration): hot_path_name = None # result maps each pair (exe, rmw) to lists of results corresponding to the runs results = defaultdict(lambda: {'hot_path': {'latency': [], 'dropped': []}, 'behavior_planner': {'period': []}}) hot_path_name_regex = re.compile(r'^ *hot path: *(.*)$') hot_path_latency_regex = re.compile(r'^ *hot path latency: *(.+)ms \\[min=(.+)ms, ' + r'max=(.+)ms, average=(.+)ms, deviation=(.+)ms\\]$') hot_path_drops_regex = re.compile(r'^ *hot path drops: *(.+) \\[min=(.+), max=(.+), ' + r'average=(.+), deviation=(.+)\\]$') behavior_planner_period_regex = re.compile(r'^ *behavior planner period: *(.+)ms \\[' + r'min=(.+)ms, max=(.+)ms, average=(.+)ms, ' + r'deviation=(.+)ms\\]$') rmw_regex = re.compile(r'^RMW Implementation: (rmw_.*)') filename_regex = re.compile(r'.*/([0-9]+)s/(rmw_.*)/(.*)/std_output.log') for count, file in enumerate(files): match = filename_regex.match(file) if not match: raise ValueError(f'File {file} does not conform to the naming scheme') extracted_duration, rmw, exe = match.groups() if int(extracted_duration) != duration: raise ValueError(f'File {file} does not match expected duration {duration}') with open(file) as fp: rmw_line, *data = fp.read().splitlines() match = rmw_regex.match(rmw_line) if match and rmw != match.groups()[0]: raise ValueError((f'{file}: mismatch between filename-rmw (\"{rmw}\")' + f'and content-rmw(\"{match.groups()[0]}\")')) if rmw not in file: raise ValueError(f'File {file} contains data from RMW {rmw}, contradicting its name') for line in data: match = hot_path_name_regex.match(line) if match: name, = match.groups() if hot_path_name is not None and hot_path_name != name: raise ValueError('Two different hotpaths in a single summary: ' + f'{name} {hot_path_name}') hot_path_name = name continue match = hot_path_latency_regex.match(line) if match: results[(exe, rmw)]['hot_path']['latency'].append( parse_stats_from_values(*match.groups())) continue match = hot_path_drops_regex.match(line) if match: results[(exe, rmw)]['hot_path']['dropped'].append( parse_stats_from_values(*match.groups())) continue match = behavior_planner_period_regex.match(line) if match: results[(exe, rmw)]['behavior_planner']['period'].append( parse_stats_from_values(*match.groups())) continue if hot_path_name is None: raise RuntimeError('No hot_path defined in experiment.') return results, hot_path_name Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/reference_system_py/std_latency.py"},{"location":"Files/std__latency_8py/#reference_systemreference_system_pystd_latencypy","text":"","title":"reference_system/reference_system_py/std_latency.py"},{"location":"Files/std__latency_8py/#namespaces","text":"Name reference_system_py reference_system_py::std_latency","title":"Namespaces"},{"location":"Files/std__latency_8py/#source-code","text":"# Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from collections import defaultdict import re from bokeh.models import ColumnDataSource from bokeh.models.ranges import FactorRange from bokeh.models.widgets.markups import Div from bokeh.models.widgets.tables import DataTable, TableColumn from bokeh.palettes import cividis from bokeh.plotting import figure from bokeh.transform import factor_cmap import pandas as pd from .constants import SIZE_TABLE_ROW, SIZE_TABLE_WIDTH from .plot_utils import plot_barplot def summary_from_directories(dirs, duration, size): data, hot_path_name = parseLogSummaryFromFiles( [directory+'/std_output.log' for directory in dirs], duration) df_dict = { 'exe': [], 'rmw': [], 'type': [], 'low': [], 'mean': [], 'high': [], 'std_dev': [], 'box_top': [], 'box_bottom': [] } def add_row(exe, rmw, data_type, stats): df_dict['exe'].append(exe) df_dict['rmw'].append(rmw) df_dict['type'].append(data_type) for stat, value in stats.items(): df_dict[stat].append(value) df_dict['box_top'].append(stats['mean'] + stats['std_dev']) df_dict['box_bottom'].append(stats['mean'] - stats['std_dev']) for (exe, rmw), results in data.items(): stats = results['hot_path']['latency'][-1] add_row(exe, rmw, 'latency', stats) stats = results['hot_path']['dropped'][-1] add_row(exe, rmw, 'dropped', stats) stats_list = results['behavior_planner']['period'] if stats_list: add_row(exe, rmw, 'period', stats_list[-1]) df = pd.DataFrame.from_dict(df_dict) # sort by exe and rmw df = df.sort_values(['exe', 'rmw'], ascending=True) rmws = list(df.rmw.drop_duplicates()) x = [tuple(x) for x in df[['rmw', 'exe']].drop_duplicates().to_records(index=False)] fill_color = factor_cmap( 'x', palette=cividis(len(rmws)), factors=list(rmws), start=0, end=1) latency = df[df.type == 'latency'] dropped = df[df.type == 'dropped'] period = df[df.type == 'period'] latency_source = ColumnDataSource(latency) dropped_source = ColumnDataSource(dropped) period_source = ColumnDataSource(period) # add exe and rmw list of tuples for x axis latency_source.data['x'] = x dropped_source.data['x'] = x period_source.data['x'] = x # initialize list of figures std_figs = [] # initialize latency figure test_info = str(duration) + 's [' + hot_path_name + ']' columns = [TableColumn(field=field, title=title) for field, title in [('exe', 'Benchmark'), ('rmw', 'RMW'), ('low', 'Min'), ('mean', 'Mean'), ('high', 'Max'), ('std_dev', 'Std. Dev.')]] if not latency.empty: latency_fig = figure( title='Latency Summary ' + test_info, x_axis_label=f'Executors (with RMW)', y_axis_label='Latency (ms)', x_range=FactorRange(*x), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) plot_barplot(latency_fig, latency_source, fill_color=fill_color) latency_table_title = Div( text='<b>Latency Summary Table ' + test_info + '</b>', width=SIZE_TABLE_WIDTH, height=SIZE_TABLE_ROW) latency_table = [ latency_table_title, DataTable( columns=columns, source=ColumnDataSource(latency.round(decimals=3)), autosize_mode='fit_viewport', margin=(0, 10, 10, 10), height=(len(latency.exe.values.tolist()) * SIZE_TABLE_ROW), width=SIZE_TABLE_WIDTH)] std_figs += [[latency_table], [latency_fig]] if not dropped.empty: dropped_fig = figure( title='Dropped Messages Summary ' + test_info, x_axis_label=f'Executors (with RMW)', y_axis_label='Dropped Messages', x_range=FactorRange(*x), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) plot_barplot(dropped_fig, dropped_source, fill_color=fill_color) dropped_table_title = Div( text='<b>Dropped Messages Summary Table ' + test_info + '</b>', width=SIZE_TABLE_WIDTH, height=SIZE_TABLE_ROW) dropped_table = [ dropped_table_title, DataTable( columns=columns, source=ColumnDataSource(dropped.round(decimals=1)), autosize_mode='fit_viewport', margin=(0, 10, 10, 10), height=(len(dropped.exe.values.tolist()) * SIZE_TABLE_ROW), width=SIZE_TABLE_WIDTH)] std_figs += [[dropped_table], [dropped_fig]] if not period.empty: period_fig = figure( title='Behavior Planner Jitter Summary ' + str(duration) + 's', x_axis_label=f'Executors (with RMW)', y_axis_label='Period (ms)', x_range=FactorRange(*x), plot_width=int(size * 2.0), plot_height=size, margin=(10, 10, 10, 10) ) plot_barplot(period_fig, period_source, fill_color=fill_color) period_table_title = Div( text='<b>Behavior Planner Jitter Summary Table ' + str(duration) + 's</b>', width=SIZE_TABLE_WIDTH, height=SIZE_TABLE_ROW) period_table = [ period_table_title, DataTable( columns=columns, source=ColumnDataSource(period.round(decimals=3)), autosize_mode='fit_viewport', margin=(0, 10, 10, 10), height=(len(period.exe.values.tolist()) * SIZE_TABLE_ROW), width=SIZE_TABLE_WIDTH)] std_figs += [[period_table], [period_fig]] return std_figs def parse_stats_from_values(latency_, min_, max_, average_, deviation_): stats = { 'low': float(min_), 'high': float(max_), 'mean': float(average_), 'std_dev': float(deviation_)} return stats def parseLogSummaryFromFiles(files, duration): hot_path_name = None # result maps each pair (exe, rmw) to lists of results corresponding to the runs results = defaultdict(lambda: {'hot_path': {'latency': [], 'dropped': []}, 'behavior_planner': {'period': []}}) hot_path_name_regex = re.compile(r'^ *hot path: *(.*)$') hot_path_latency_regex = re.compile(r'^ *hot path latency: *(.+)ms \\[min=(.+)ms, ' + r'max=(.+)ms, average=(.+)ms, deviation=(.+)ms\\]$') hot_path_drops_regex = re.compile(r'^ *hot path drops: *(.+) \\[min=(.+), max=(.+), ' + r'average=(.+), deviation=(.+)\\]$') behavior_planner_period_regex = re.compile(r'^ *behavior planner period: *(.+)ms \\[' + r'min=(.+)ms, max=(.+)ms, average=(.+)ms, ' + r'deviation=(.+)ms\\]$') rmw_regex = re.compile(r'^RMW Implementation: (rmw_.*)') filename_regex = re.compile(r'.*/([0-9]+)s/(rmw_.*)/(.*)/std_output.log') for count, file in enumerate(files): match = filename_regex.match(file) if not match: raise ValueError(f'File {file} does not conform to the naming scheme') extracted_duration, rmw, exe = match.groups() if int(extracted_duration) != duration: raise ValueError(f'File {file} does not match expected duration {duration}') with open(file) as fp: rmw_line, *data = fp.read().splitlines() match = rmw_regex.match(rmw_line) if match and rmw != match.groups()[0]: raise ValueError((f'{file}: mismatch between filename-rmw (\"{rmw}\")' + f'and content-rmw(\"{match.groups()[0]}\")')) if rmw not in file: raise ValueError(f'File {file} contains data from RMW {rmw}, contradicting its name') for line in data: match = hot_path_name_regex.match(line) if match: name, = match.groups() if hot_path_name is not None and hot_path_name != name: raise ValueError('Two different hotpaths in a single summary: ' + f'{name} {hot_path_name}') hot_path_name = name continue match = hot_path_latency_regex.match(line) if match: results[(exe, rmw)]['hot_path']['latency'].append( parse_stats_from_values(*match.groups())) continue match = hot_path_drops_regex.match(line) if match: results[(exe, rmw)]['hot_path']['dropped'].append( parse_stats_from_values(*match.groups())) continue match = behavior_planner_period_regex.match(line) if match: results[(exe, rmw)]['behavior_planner']['period'].append( parse_stats_from_values(*match.groups())) continue if hot_path_name is None: raise RuntimeError('No hot_path defined in experiment.') return results, hot_path_name Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/test__autoware__reference__system_8cpp/","text":"autoware_reference_system/test/test_autoware_reference_system.cpp Functions Name TEST (TestReferenceSystemAutoware , DummyTest ) Functions Documentation function TEST TEST( TestReferenceSystemAutoware , DummyTest ) Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include \"gtest/gtest.h\" TEST(TestReferenceSystemAutoware, DummyTest) { EXPECT_EQ(1, 1); } Updated on 2022-04-30 at 21:32:33 +0000","title":"autoware_reference_system/test/test_autoware_reference_system.cpp"},{"location":"Files/test__autoware__reference__system_8cpp/#autoware_reference_systemtesttest_autoware_reference_systemcpp","text":"","title":"autoware_reference_system/test/test_autoware_reference_system.cpp"},{"location":"Files/test__autoware__reference__system_8cpp/#functions","text":"Name TEST (TestReferenceSystemAutoware , DummyTest )","title":"Functions"},{"location":"Files/test__autoware__reference__system_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/test__autoware__reference__system_8cpp/#function-test","text":"TEST( TestReferenceSystemAutoware , DummyTest )","title":"function TEST"},{"location":"Files/test__autoware__reference__system_8cpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include \"gtest/gtest.h\" TEST(TestReferenceSystemAutoware, DummyTest) { EXPECT_EQ(1, 1); } Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/test__fixtures_8hpp/","text":"reference_system/test/test_fixtures.hpp Classes Name class TestNodeGraph Types Name using std::chrono::milliseconds milliseconds Functions Name template <typename SystemType ,typename NodeType ,typename SettingsType > auto create_node (SettingsType settings) Attributes Name constexpr uint64_t CRUNCH Types Documentation using milliseconds using milliseconds = std::chrono::milliseconds; Functions Documentation function create_node template <typename SystemType , typename NodeType , typename SettingsType > auto create_node( SettingsType settings ) Attributes Documentation variable CRUNCH static constexpr uint64_t CRUNCH = 65536; Source code // Copyright 2022 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef TEST_FIXTURES_HPP_ #define TEST_FIXTURES_HPP_ #include <gtest/gtest.h> #include <memory> #include \"rclcpp/rclcpp.hpp\" class TestNodeGraph : public ::testing::Test { public: void SetUp() { rclcpp::init(0, nullptr); } void TearDown() { rclcpp::shutdown(); } }; using milliseconds = std::chrono::milliseconds; static constexpr uint64_t CRUNCH = 65536; template<typename SystemType, typename NodeType, typename SettingsType> auto create_node(SettingsType settings) ->std::shared_ptr<typename SystemType::NodeBaseType> { auto node = std::make_shared<NodeType>(settings); return node; } #endif // TEST_FIXTURES_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/test/test_fixtures.hpp"},{"location":"Files/test__fixtures_8hpp/#reference_systemtesttest_fixtureshpp","text":"","title":"reference_system/test/test_fixtures.hpp"},{"location":"Files/test__fixtures_8hpp/#classes","text":"Name class TestNodeGraph","title":"Classes"},{"location":"Files/test__fixtures_8hpp/#types","text":"Name using std::chrono::milliseconds milliseconds","title":"Types"},{"location":"Files/test__fixtures_8hpp/#functions","text":"Name template <typename SystemType ,typename NodeType ,typename SettingsType > auto create_node (SettingsType settings)","title":"Functions"},{"location":"Files/test__fixtures_8hpp/#attributes","text":"Name constexpr uint64_t CRUNCH","title":"Attributes"},{"location":"Files/test__fixtures_8hpp/#types-documentation","text":"","title":"Types Documentation"},{"location":"Files/test__fixtures_8hpp/#using-milliseconds","text":"using milliseconds = std::chrono::milliseconds;","title":"using milliseconds"},{"location":"Files/test__fixtures_8hpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/test__fixtures_8hpp/#function-create_node","text":"template <typename SystemType , typename NodeType , typename SettingsType > auto create_node( SettingsType settings )","title":"function create_node"},{"location":"Files/test__fixtures_8hpp/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Files/test__fixtures_8hpp/#variable-crunch","text":"static constexpr uint64_t CRUNCH = 65536;","title":"variable CRUNCH"},{"location":"Files/test__fixtures_8hpp/#source-code","text":"// Copyright 2022 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef TEST_FIXTURES_HPP_ #define TEST_FIXTURES_HPP_ #include <gtest/gtest.h> #include <memory> #include \"rclcpp/rclcpp.hpp\" class TestNodeGraph : public ::testing::Test { public: void SetUp() { rclcpp::init(0, nullptr); } void TearDown() { rclcpp::shutdown(); } }; using milliseconds = std::chrono::milliseconds; static constexpr uint64_t CRUNCH = 65536; template<typename SystemType, typename NodeType, typename SettingsType> auto create_node(SettingsType settings) ->std::shared_ptr<typename SystemType::NodeBaseType> { auto node = std::make_shared<NodeType>(settings); return node; } #endif // TEST_FIXTURES_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/test__number__cruncher_8cpp/","text":"reference_system/test/test_number_cruncher.cpp Functions Name TEST (test_number_cruncher , number_cruncher ) TEST (test_number_cruncher , crunch_time ) Functions Documentation function TEST TEST( test_number_cruncher , number_cruncher ) function TEST TEST( test_number_cruncher , crunch_time ) Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <gtest/gtest.h> #include <string> #include \"reference_system/number_cruncher.hpp\" TEST(test_number_cruncher, number_cruncher) { auto primes = number_cruncher(10); // 2, 3, 5, 7 EXPECT_EQ(primes, 4); primes = number_cruncher(20); // 11, 13, 17, 19 EXPECT_EQ(primes, 8); primes = number_cruncher(30); // 23, 29 EXPECT_EQ(primes, 10); } TEST(test_number_cruncher, crunch_time) { auto expected_fast = get_crunch_time_in_ms(100); auto expected_slow = get_crunch_time_in_ms(65536); // lower maximum number should result in faster crunch times EXPECT_LT(expected_fast, expected_slow); } Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/test/test_number_cruncher.cpp"},{"location":"Files/test__number__cruncher_8cpp/#reference_systemtesttest_number_crunchercpp","text":"","title":"reference_system/test/test_number_cruncher.cpp"},{"location":"Files/test__number__cruncher_8cpp/#functions","text":"Name TEST (test_number_cruncher , number_cruncher ) TEST (test_number_cruncher , crunch_time )","title":"Functions"},{"location":"Files/test__number__cruncher_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/test__number__cruncher_8cpp/#function-test","text":"TEST( test_number_cruncher , number_cruncher )","title":"function TEST"},{"location":"Files/test__number__cruncher_8cpp/#function-test_1","text":"TEST( test_number_cruncher , crunch_time )","title":"function TEST"},{"location":"Files/test__number__cruncher_8cpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <gtest/gtest.h> #include <string> #include \"reference_system/number_cruncher.hpp\" TEST(test_number_cruncher, number_cruncher) { auto primes = number_cruncher(10); // 2, 3, 5, 7 EXPECT_EQ(primes, 4); primes = number_cruncher(20); // 11, 13, 17, 19 EXPECT_EQ(primes, 8); primes = number_cruncher(30); // 23, 29 EXPECT_EQ(primes, 10); } TEST(test_number_cruncher, crunch_time) { auto expected_fast = get_crunch_time_in_ms(100); auto expected_slow = get_crunch_time_in_ms(65536); // lower maximum number should result in faster crunch times EXPECT_LT(expected_fast, expected_slow); } Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/test__platform_8py/","text":"autoware_reference_system/test/test_platform.py Namespaces Name test_platform Source code # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import multiprocessing import platform # this file has @variables@ that are meant to be automatically replaced # by values using the `configure_file` CMake function during the build platforms = {} # TODO(flynneva): move this to its own file for portability # can add more supported platforms here platforms['rpi4-linux-rt'] = { 'common-name': 'raspberrypi4', 'machine': 'aarch64', 'processor': 'aarch64', 'system': 'Linux', 'flavor': 'ubuntu', 'cores': 4, 'realtime': True } def test_platform(record_property): # get current system information system, node, release, version, machine, processor = platform.uname() platform_supported = False for pform in platforms: if(platforms[pform]['system'] == system): if(platforms[pform]['processor'] == processor): platform_supported = True assert multiprocessing.cpu_count() == platforms[pform]['cores'] if(platforms[pform]['realtime']): assert 'PREEMPT_RT' in version if platform_supported: print('platform supported') assert True else: print('platform unsupported') assert False Updated on 2022-04-30 at 21:32:33 +0000","title":"autoware_reference_system/test/test_platform.py"},{"location":"Files/test__platform_8py/#autoware_reference_systemtesttest_platformpy","text":"","title":"autoware_reference_system/test/test_platform.py"},{"location":"Files/test__platform_8py/#namespaces","text":"Name test_platform","title":"Namespaces"},{"location":"Files/test__platform_8py/#source-code","text":"# Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import multiprocessing import platform # this file has @variables@ that are meant to be automatically replaced # by values using the `configure_file` CMake function during the build platforms = {} # TODO(flynneva): move this to its own file for portability # can add more supported platforms here platforms['rpi4-linux-rt'] = { 'common-name': 'raspberrypi4', 'machine': 'aarch64', 'processor': 'aarch64', 'system': 'Linux', 'flavor': 'ubuntu', 'cores': 4, 'realtime': True } def test_platform(record_property): # get current system information system, node, release, version, machine, processor = platform.uname() platform_supported = False for pform in platforms: if(platforms[pform]['system'] == system): if(platforms[pform]['processor'] == processor): platform_supported = True assert multiprocessing.cpu_count() == platforms[pform]['cores'] if(platforms[pform]['realtime']): assert 'PREEMPT_RT' in version if platform_supported: print('platform supported') assert True else: print('platform unsupported') assert False Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/test__reference__system__rclcpp_8cpp/","text":"reference_system/test/test_reference_system_rclcpp.cpp Types Name using RclcppSystem SystemType Functions Name void sleep_for_sec (uint32_t secs) auto remove_default_topics (std::map< std::string, std::vector< std::string > > topic_map) TEST_F ( TestNodeGraph , rclcpp_sensor_node ) TEST_F ( TestNodeGraph , rclcpp_transform_node ) TEST_F ( TestNodeGraph , rclcpp_intersection_node ) TEST_F ( TestNodeGraph , rclcpp_fusion_node ) TEST_F ( TestNodeGraph , rclcpp_cyclic_node ) TEST_F ( TestNodeGraph , rclcpp_command_node ) Types Documentation using SystemType using SystemType = RclcppSystem; Functions Documentation function sleep_for_sec void sleep_for_sec( uint32_t secs ) function remove_default_topics auto remove_default_topics( std::map< std::string, std::vector< std::string > > topic_map ) function TEST_F TEST_F( TestNodeGraph , rclcpp_sensor_node ) function TEST_F TEST_F( TestNodeGraph , rclcpp_transform_node ) function TEST_F TEST_F( TestNodeGraph , rclcpp_intersection_node ) function TEST_F TEST_F( TestNodeGraph , rclcpp_fusion_node ) function TEST_F TEST_F( TestNodeGraph , rclcpp_cyclic_node ) function TEST_F TEST_F( TestNodeGraph , rclcpp_command_node ) Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <gtest/gtest.h> #include <chrono> #include <map> #include <string> #include <thread> #include <vector> #include \"test_fixtures.hpp\" #include \"rclcpp/node_interfaces/node_graph.hpp\" #include \"reference_system/system/type/rclcpp_system.hpp\" // set the system to use using SystemType = RclcppSystem; void sleep_for_sec(uint32_t secs) { std::this_thread::sleep_for(std::chrono::seconds(secs)); } // remove /rosout and /parameter_events topics from map if they exist auto remove_default_topics(std::map<std::string, std::vector<std::string>> topic_map) ->std::map<std::string, std::vector<std::string>> { std::vector<std::string> topics_to_remove{}; topics_to_remove.push_back(\"/rosout\"); topics_to_remove.push_back(\"/parameter_events\"); for (auto topic : topics_to_remove) { auto topic_iter = topic_map.find(topic); if (topic_iter != topic_map.end()) { std::cout << \"Removing default topic: \" << topic << std::endl; topic_map.erase(topic_iter); } } return topic_map; } TEST_F(TestNodeGraph, rclcpp_sensor_node) { ::testing::Test::RecordProperty(\"TEST_ID\", \"31c600f9-f6dc-407f-a487-b563178836ce\"); auto settings = nodes::SensorSettings(); settings.node_name = \"SensorNode\"; settings.topic_name = settings.node_name; settings.cycle_time = milliseconds(100); // create node auto node = create_node<SystemType, SystemType::Sensor, nodes::SensorSettings>(settings); sleep_for_sec(1); // confirm node was initialized with settings EXPECT_EQ(node->get_name(), settings.node_name); // get node graph of node auto * node_graph = node->get_node_graph_interface().get(); ASSERT_NE(nullptr, node_graph); auto topic_names_and_types = remove_default_topics(node_graph->get_topic_names_and_types(false)); // sensor nodes should publish one topic EXPECT_EQ(1, topic_names_and_types.size()); EXPECT_EQ(1, node_graph->count_publishers(settings.topic_name)); } TEST_F(TestNodeGraph, rclcpp_transform_node) { ::testing::Test::RecordProperty(\"TEST_ID\", \"76a88488-bf7b-414e-865b-92770f38cce2\"); auto settings = nodes::TransformSettings(); settings.node_name = \"TransformNode\"; settings.input_topic = settings.node_name + \"1\"; settings.output_topic = settings.node_name; settings.number_crunch_limit = CRUNCH; // create node auto node = create_node<SystemType, SystemType::Transform, nodes::TransformSettings>(settings); sleep_for_sec(1); // confirm node was initialized with settings EXPECT_EQ(node->get_name(), settings.node_name); // get node graph of node auto * node_graph = node->get_node_graph_interface().get(); ASSERT_NE(nullptr, node_graph); auto topic_names_and_types = remove_default_topics(node_graph->get_topic_names_and_types(false)); // transform nodes should publish one topic and subscribe to one topic auto pubs = 1; auto subs = 1; auto total_pubs_and_subs = pubs + subs; EXPECT_EQ(total_pubs_and_subs, topic_names_and_types.size()); EXPECT_EQ(pubs, node_graph->count_publishers(settings.output_topic)); EXPECT_EQ(subs, node_graph->count_subscribers(settings.input_topic)); } TEST_F(TestNodeGraph, rclcpp_intersection_node) { ::testing::Test::RecordProperty(\"TEST_ID\", \"f2d0485c-c608-446f-8ee8-2dbf1b04399d\"); auto settings = nodes::IntersectionSettings(); settings.node_name = \"IntersectionNode\"; std::string input_topic = settings.node_name + \"_in_\"; settings.connections.emplace_back(nodes::IntersectionSettings::Connection()); settings.connections.emplace_back(nodes::IntersectionSettings::Connection()); settings.connections[0].input_topic = input_topic + \"1\"; settings.connections[0].output_topic = settings.node_name + \"1\"; settings.connections[0].number_crunch_limit = CRUNCH; settings.connections[1].input_topic = input_topic + \"2\"; settings.connections[1].output_topic = settings.node_name + \"2\"; settings.connections[1].number_crunch_limit = CRUNCH; // create node auto node = create_node<SystemType, SystemType::Intersection, nodes::IntersectionSettings>(settings); sleep_for_sec(1); // confirm node was initialized with settings EXPECT_EQ(node->get_name(), settings.node_name); // get node graph of node auto * node_graph = node->get_node_graph_interface().get(); ASSERT_NE(nullptr, node_graph); auto topic_names_and_types = remove_default_topics(node_graph->get_topic_names_and_types(false)); // intersection nodes should publish two topics and subscribe to two topics auto pubs = settings.connections.size(); auto subs = settings.connections.size(); auto total_pubs_and_subs = pubs + subs; EXPECT_EQ(total_pubs_and_subs, topic_names_and_types.size()); for (auto connection : settings.connections) { EXPECT_EQ(1, node_graph->count_publishers(connection.output_topic)); EXPECT_EQ(1, node_graph->count_subscribers(connection.input_topic)); } } TEST_F(TestNodeGraph, rclcpp_fusion_node) { ::testing::Test::RecordProperty(\"TEST_ID\", \"0a389fbd-d87b-42fb-8abb-189425958264\"); auto settings = nodes::FusionSettings(); settings.node_name = \"FusionNode\"; settings.input_0 = settings.node_name + \"1\"; settings.input_1 = settings.node_name + \"2\"; settings.number_crunch_limit = CRUNCH; settings.output_topic = settings.node_name; // create node auto node = create_node<SystemType, SystemType::Fusion, nodes::FusionSettings>(settings); sleep_for_sec(1); // confirm node was initialized with settings EXPECT_EQ(node->get_name(), settings.node_name); // get node graph of node auto * node_graph = node->get_node_graph_interface().get(); ASSERT_NE(nullptr, node_graph); auto topic_names_and_types = remove_default_topics(node_graph->get_topic_names_and_types(false)); // intersection nodes should publish two topics and subscribe to two topics auto pubs = 1; auto subs = 2; auto total_pubs_and_subs = pubs + subs; EXPECT_EQ(total_pubs_and_subs, topic_names_and_types.size()); EXPECT_EQ(1, node_graph->count_publishers(settings.node_name)); EXPECT_EQ(1, node_graph->count_subscribers(settings.input_0)); EXPECT_EQ(1, node_graph->count_subscribers(settings.input_1)); } TEST_F(TestNodeGraph, rclcpp_cyclic_node) { ::testing::Test::RecordProperty(\"TEST_ID\", \"46542da9-cc40-4f2f-93b1-a82577ee90ab\"); auto settings = nodes::CyclicSettings(); settings.node_name = \"CyclicNode\"; settings.inputs.emplace_back(settings.node_name + \"1\"); settings.inputs.emplace_back(settings.node_name + \"2\"); settings.inputs.emplace_back(settings.node_name + \"3\"); settings.number_crunch_limit = CRUNCH; settings.output_topic = settings.node_name; // create node auto node = create_node<SystemType, SystemType::Cyclic, nodes::CyclicSettings>(settings); sleep_for_sec(1); // confirm node was initialized with settings EXPECT_EQ(node->get_name(), settings.node_name); // get node graph of node auto * node_graph = node->get_node_graph_interface().get(); ASSERT_NE(nullptr, node_graph); auto topic_names_and_types = remove_default_topics(node_graph->get_topic_names_and_types(false)); // intersection nodes should publish two topics and subscribe to two topics auto pubs = 1; auto subs = 3; auto total_pubs_and_subs = pubs + subs; EXPECT_EQ(total_pubs_and_subs, topic_names_and_types.size()); EXPECT_EQ(1, node_graph->count_publishers(settings.node_name)); EXPECT_EQ(1, node_graph->count_subscribers(settings.inputs[0])); EXPECT_EQ(1, node_graph->count_subscribers(settings.inputs[1])); EXPECT_EQ(1, node_graph->count_subscribers(settings.inputs[2])); } TEST_F(TestNodeGraph, rclcpp_command_node) { ::testing::Test::RecordProperty(\"TEST_ID\", \"7507e0fb-0374-48f1-8d97-535af2e57bb2\"); auto settings = nodes::CommandSettings(); settings.node_name = \"CommandNode\"; settings.input_topic = settings.node_name + \"_in\"; // create node auto node = create_node<SystemType, SystemType::Command, nodes::CommandSettings>(settings); sleep_for_sec(1); // confirm node was initialized with settings EXPECT_EQ(node->get_name(), settings.node_name); // get node graph of node auto * node_graph = node->get_node_graph_interface().get(); ASSERT_NE(nullptr, node_graph); auto topic_names_and_types = remove_default_topics(node_graph->get_topic_names_and_types(false)); // intersection nodes should publish two topics and subscribe to two topics auto pubs = 0; auto subs = 1; auto total_pubs_and_subs = pubs + subs; EXPECT_EQ(total_pubs_and_subs, topic_names_and_types.size()); EXPECT_EQ(0, node_graph->count_publishers(settings.node_name)); EXPECT_EQ(1, node_graph->count_subscribers(settings.input_topic)); } Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/test/test_reference_system_rclcpp.cpp"},{"location":"Files/test__reference__system__rclcpp_8cpp/#reference_systemtesttest_reference_system_rclcppcpp","text":"","title":"reference_system/test/test_reference_system_rclcpp.cpp"},{"location":"Files/test__reference__system__rclcpp_8cpp/#types","text":"Name using RclcppSystem SystemType","title":"Types"},{"location":"Files/test__reference__system__rclcpp_8cpp/#functions","text":"Name void sleep_for_sec (uint32_t secs) auto remove_default_topics (std::map< std::string, std::vector< std::string > > topic_map) TEST_F ( TestNodeGraph , rclcpp_sensor_node ) TEST_F ( TestNodeGraph , rclcpp_transform_node ) TEST_F ( TestNodeGraph , rclcpp_intersection_node ) TEST_F ( TestNodeGraph , rclcpp_fusion_node ) TEST_F ( TestNodeGraph , rclcpp_cyclic_node ) TEST_F ( TestNodeGraph , rclcpp_command_node )","title":"Functions"},{"location":"Files/test__reference__system__rclcpp_8cpp/#types-documentation","text":"","title":"Types Documentation"},{"location":"Files/test__reference__system__rclcpp_8cpp/#using-systemtype","text":"using SystemType = RclcppSystem;","title":"using SystemType"},{"location":"Files/test__reference__system__rclcpp_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/test__reference__system__rclcpp_8cpp/#function-sleep_for_sec","text":"void sleep_for_sec( uint32_t secs )","title":"function sleep_for_sec"},{"location":"Files/test__reference__system__rclcpp_8cpp/#function-remove_default_topics","text":"auto remove_default_topics( std::map< std::string, std::vector< std::string > > topic_map )","title":"function remove_default_topics"},{"location":"Files/test__reference__system__rclcpp_8cpp/#function-test_f","text":"TEST_F( TestNodeGraph , rclcpp_sensor_node )","title":"function TEST_F"},{"location":"Files/test__reference__system__rclcpp_8cpp/#function-test_f_1","text":"TEST_F( TestNodeGraph , rclcpp_transform_node )","title":"function TEST_F"},{"location":"Files/test__reference__system__rclcpp_8cpp/#function-test_f_2","text":"TEST_F( TestNodeGraph , rclcpp_intersection_node )","title":"function TEST_F"},{"location":"Files/test__reference__system__rclcpp_8cpp/#function-test_f_3","text":"TEST_F( TestNodeGraph , rclcpp_fusion_node )","title":"function TEST_F"},{"location":"Files/test__reference__system__rclcpp_8cpp/#function-test_f_4","text":"TEST_F( TestNodeGraph , rclcpp_cyclic_node )","title":"function TEST_F"},{"location":"Files/test__reference__system__rclcpp_8cpp/#function-test_f_5","text":"TEST_F( TestNodeGraph , rclcpp_command_node )","title":"function TEST_F"},{"location":"Files/test__reference__system__rclcpp_8cpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <gtest/gtest.h> #include <chrono> #include <map> #include <string> #include <thread> #include <vector> #include \"test_fixtures.hpp\" #include \"rclcpp/node_interfaces/node_graph.hpp\" #include \"reference_system/system/type/rclcpp_system.hpp\" // set the system to use using SystemType = RclcppSystem; void sleep_for_sec(uint32_t secs) { std::this_thread::sleep_for(std::chrono::seconds(secs)); } // remove /rosout and /parameter_events topics from map if they exist auto remove_default_topics(std::map<std::string, std::vector<std::string>> topic_map) ->std::map<std::string, std::vector<std::string>> { std::vector<std::string> topics_to_remove{}; topics_to_remove.push_back(\"/rosout\"); topics_to_remove.push_back(\"/parameter_events\"); for (auto topic : topics_to_remove) { auto topic_iter = topic_map.find(topic); if (topic_iter != topic_map.end()) { std::cout << \"Removing default topic: \" << topic << std::endl; topic_map.erase(topic_iter); } } return topic_map; } TEST_F(TestNodeGraph, rclcpp_sensor_node) { ::testing::Test::RecordProperty(\"TEST_ID\", \"31c600f9-f6dc-407f-a487-b563178836ce\"); auto settings = nodes::SensorSettings(); settings.node_name = \"SensorNode\"; settings.topic_name = settings.node_name; settings.cycle_time = milliseconds(100); // create node auto node = create_node<SystemType, SystemType::Sensor, nodes::SensorSettings>(settings); sleep_for_sec(1); // confirm node was initialized with settings EXPECT_EQ(node->get_name(), settings.node_name); // get node graph of node auto * node_graph = node->get_node_graph_interface().get(); ASSERT_NE(nullptr, node_graph); auto topic_names_and_types = remove_default_topics(node_graph->get_topic_names_and_types(false)); // sensor nodes should publish one topic EXPECT_EQ(1, topic_names_and_types.size()); EXPECT_EQ(1, node_graph->count_publishers(settings.topic_name)); } TEST_F(TestNodeGraph, rclcpp_transform_node) { ::testing::Test::RecordProperty(\"TEST_ID\", \"76a88488-bf7b-414e-865b-92770f38cce2\"); auto settings = nodes::TransformSettings(); settings.node_name = \"TransformNode\"; settings.input_topic = settings.node_name + \"1\"; settings.output_topic = settings.node_name; settings.number_crunch_limit = CRUNCH; // create node auto node = create_node<SystemType, SystemType::Transform, nodes::TransformSettings>(settings); sleep_for_sec(1); // confirm node was initialized with settings EXPECT_EQ(node->get_name(), settings.node_name); // get node graph of node auto * node_graph = node->get_node_graph_interface().get(); ASSERT_NE(nullptr, node_graph); auto topic_names_and_types = remove_default_topics(node_graph->get_topic_names_and_types(false)); // transform nodes should publish one topic and subscribe to one topic auto pubs = 1; auto subs = 1; auto total_pubs_and_subs = pubs + subs; EXPECT_EQ(total_pubs_and_subs, topic_names_and_types.size()); EXPECT_EQ(pubs, node_graph->count_publishers(settings.output_topic)); EXPECT_EQ(subs, node_graph->count_subscribers(settings.input_topic)); } TEST_F(TestNodeGraph, rclcpp_intersection_node) { ::testing::Test::RecordProperty(\"TEST_ID\", \"f2d0485c-c608-446f-8ee8-2dbf1b04399d\"); auto settings = nodes::IntersectionSettings(); settings.node_name = \"IntersectionNode\"; std::string input_topic = settings.node_name + \"_in_\"; settings.connections.emplace_back(nodes::IntersectionSettings::Connection()); settings.connections.emplace_back(nodes::IntersectionSettings::Connection()); settings.connections[0].input_topic = input_topic + \"1\"; settings.connections[0].output_topic = settings.node_name + \"1\"; settings.connections[0].number_crunch_limit = CRUNCH; settings.connections[1].input_topic = input_topic + \"2\"; settings.connections[1].output_topic = settings.node_name + \"2\"; settings.connections[1].number_crunch_limit = CRUNCH; // create node auto node = create_node<SystemType, SystemType::Intersection, nodes::IntersectionSettings>(settings); sleep_for_sec(1); // confirm node was initialized with settings EXPECT_EQ(node->get_name(), settings.node_name); // get node graph of node auto * node_graph = node->get_node_graph_interface().get(); ASSERT_NE(nullptr, node_graph); auto topic_names_and_types = remove_default_topics(node_graph->get_topic_names_and_types(false)); // intersection nodes should publish two topics and subscribe to two topics auto pubs = settings.connections.size(); auto subs = settings.connections.size(); auto total_pubs_and_subs = pubs + subs; EXPECT_EQ(total_pubs_and_subs, topic_names_and_types.size()); for (auto connection : settings.connections) { EXPECT_EQ(1, node_graph->count_publishers(connection.output_topic)); EXPECT_EQ(1, node_graph->count_subscribers(connection.input_topic)); } } TEST_F(TestNodeGraph, rclcpp_fusion_node) { ::testing::Test::RecordProperty(\"TEST_ID\", \"0a389fbd-d87b-42fb-8abb-189425958264\"); auto settings = nodes::FusionSettings(); settings.node_name = \"FusionNode\"; settings.input_0 = settings.node_name + \"1\"; settings.input_1 = settings.node_name + \"2\"; settings.number_crunch_limit = CRUNCH; settings.output_topic = settings.node_name; // create node auto node = create_node<SystemType, SystemType::Fusion, nodes::FusionSettings>(settings); sleep_for_sec(1); // confirm node was initialized with settings EXPECT_EQ(node->get_name(), settings.node_name); // get node graph of node auto * node_graph = node->get_node_graph_interface().get(); ASSERT_NE(nullptr, node_graph); auto topic_names_and_types = remove_default_topics(node_graph->get_topic_names_and_types(false)); // intersection nodes should publish two topics and subscribe to two topics auto pubs = 1; auto subs = 2; auto total_pubs_and_subs = pubs + subs; EXPECT_EQ(total_pubs_and_subs, topic_names_and_types.size()); EXPECT_EQ(1, node_graph->count_publishers(settings.node_name)); EXPECT_EQ(1, node_graph->count_subscribers(settings.input_0)); EXPECT_EQ(1, node_graph->count_subscribers(settings.input_1)); } TEST_F(TestNodeGraph, rclcpp_cyclic_node) { ::testing::Test::RecordProperty(\"TEST_ID\", \"46542da9-cc40-4f2f-93b1-a82577ee90ab\"); auto settings = nodes::CyclicSettings(); settings.node_name = \"CyclicNode\"; settings.inputs.emplace_back(settings.node_name + \"1\"); settings.inputs.emplace_back(settings.node_name + \"2\"); settings.inputs.emplace_back(settings.node_name + \"3\"); settings.number_crunch_limit = CRUNCH; settings.output_topic = settings.node_name; // create node auto node = create_node<SystemType, SystemType::Cyclic, nodes::CyclicSettings>(settings); sleep_for_sec(1); // confirm node was initialized with settings EXPECT_EQ(node->get_name(), settings.node_name); // get node graph of node auto * node_graph = node->get_node_graph_interface().get(); ASSERT_NE(nullptr, node_graph); auto topic_names_and_types = remove_default_topics(node_graph->get_topic_names_and_types(false)); // intersection nodes should publish two topics and subscribe to two topics auto pubs = 1; auto subs = 3; auto total_pubs_and_subs = pubs + subs; EXPECT_EQ(total_pubs_and_subs, topic_names_and_types.size()); EXPECT_EQ(1, node_graph->count_publishers(settings.node_name)); EXPECT_EQ(1, node_graph->count_subscribers(settings.inputs[0])); EXPECT_EQ(1, node_graph->count_subscribers(settings.inputs[1])); EXPECT_EQ(1, node_graph->count_subscribers(settings.inputs[2])); } TEST_F(TestNodeGraph, rclcpp_command_node) { ::testing::Test::RecordProperty(\"TEST_ID\", \"7507e0fb-0374-48f1-8d97-535af2e57bb2\"); auto settings = nodes::CommandSettings(); settings.node_name = \"CommandNode\"; settings.input_topic = settings.node_name + \"_in\"; // create node auto node = create_node<SystemType, SystemType::Command, nodes::CommandSettings>(settings); sleep_for_sec(1); // confirm node was initialized with settings EXPECT_EQ(node->get_name(), settings.node_name); // get node graph of node auto * node_graph = node->get_node_graph_interface().get(); ASSERT_NE(nullptr, node_graph); auto topic_names_and_types = remove_default_topics(node_graph->get_topic_names_and_types(false)); // intersection nodes should publish two topics and subscribe to two topics auto pubs = 0; auto subs = 1; auto total_pubs_and_subs = pubs + subs; EXPECT_EQ(total_pubs_and_subs, topic_names_and_types.size()); EXPECT_EQ(0, node_graph->count_publishers(settings.node_name)); EXPECT_EQ(1, node_graph->count_subscribers(settings.input_topic)); } Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/test__requirements_8py/","text":"autoware_reference_system/test/test_requirements.py Namespaces Name test_requirements Classes Name class test_requirements::TestRequirementsAutowareReferenceSystem Source code # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import os import time import unittest import launch from launch import LaunchDescription from launch.actions import ExecuteProcess import rclpy.context from ros2cli.node.direct import DirectNode import ros2topic.api # Tests to check if executable complies with the requirements for # the autoware_reference_system by checking number of nodes, publishers, # subscribers and frequency of some topics # this file has @variables@ that are meant to be automatically replaced # by values using the `configure_file` CMake function during the build checks = {'topic_exists': False, 'pubs_match': False, 'subs_match': False} # define autoware_reference_system requirements for each topic # NOTE: the pub/sub counts are for the topic, not the node itself reference_system = { '/FrontLidarDriver': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/RearLidarDriver': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointCloudMap': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/Visualizer': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/Lanelet2Map': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointsTransformerFront': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointsTransformerRear': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/VoxelGridDownsampler': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointCloudMapLoader': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/EuclideanClusterDetector': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/ObjectCollisionEstimator': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/MPCController': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/ParkingPlanner': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/LanePlanner': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointCloudFusion': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()}, '/NDTLocalizer': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()}, '/VehicleInterface': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/Lanelet2GlobalPlanner': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()}, '/Lanelet2MapLoader': {'pub_count': 1, 'sub_count': 3, 'checks': checks.copy()}, '/BehaviorPlanner': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()} # does not exist as topic but only as a node # '/VehicleDBWSystem': {'pub_count': 0, 'sub_count': 0, 'checks': checks.copy()} } def generate_test_description(ready_fn): env = os.environ.copy() env['RCUTILS_CONSOLE_OUTPUT_FORMAT'] = '[{severity}] [{name}]: {message}' launch_description = LaunchDescription() context = rclpy.context.Context() rclpy.init(context=context) launch_description.add_action( launch.actions.OpaqueFunction(function=lambda context: ready_fn())) proc_under_test = ExecuteProcess( cmd=['@TEST_EXECUTABLE@'], name='@TEST_EXECUTABLE_NAME@', output='screen', env=env, ) launch_description.add_action(proc_under_test) return launch_description, locals() class TestRequirementsAutowareReferenceSystem(unittest.TestCase): def test_pubs_and_subs(self): with DirectNode([]) as node: seen_topics = {} try: while True: print('topic_monitor looping:') for name in ros2topic.api.get_topic_names(node=node): if name not in seen_topics: seen_topics[name] = {'pub_count': 0, 'sub_count': 0} publishers = node.count_publishers(name) subscribers = node.count_subscribers(name) if seen_topics[name]['pub_count'] < publishers: seen_topics[name]['pub_count'] = publishers if seen_topics[name]['sub_count'] < subscribers: seen_topics[name]['sub_count'] = subscribers if len(seen_topics) > 0: print('Topic monitor data collected') for name in reference_system: if name in seen_topics.keys(): reference_system[name]['checks']['topic_exists'] = True if(reference_system[name]['pub_count'] == seen_topics[name]['pub_count']): reference_system[name]['checks']['pubs_match'] = True else: print('[' + name + '::pubs] EXPECTED: ' + str(reference_system[name]['pub_count'])) print('[' + name + '::pubs] RECEIVED: ' + str(seen_topics[name]['pub_count'])) if(reference_system[name]['sub_count'] == seen_topics[name]['sub_count']): reference_system[name]['checks']['subs_match'] = True else: print('[' + name + '::subs] EXPECTED: ' + str(reference_system[name]['sub_count'])) print('[' + name + '::subs] RECEIVED: ' + str(seen_topics[name]['sub_count'])) self.assertTrue(all(reference_system[name]['checks'].values())) print( f'\\t\\t{name}: ' f\"['topic_exists'=\" f\"{reference_system[name]['checks']['topic_exists']},\" f\" 'pubs_match'=\" f\"{reference_system[name]['checks']['pubs_match']},\" f\" 'subs_match'=\" f\"{reference_system[name]['checks']['subs_match']}]\") # exit while loop, data was collected return # slow down while loop time.sleep(0.5) except SystemError: pass except KeyboardInterrupt: pass Updated on 2022-04-30 at 21:32:33 +0000","title":"autoware_reference_system/test/test_requirements.py"},{"location":"Files/test__requirements_8py/#autoware_reference_systemtesttest_requirementspy","text":"","title":"autoware_reference_system/test/test_requirements.py"},{"location":"Files/test__requirements_8py/#namespaces","text":"Name test_requirements","title":"Namespaces"},{"location":"Files/test__requirements_8py/#classes","text":"Name class test_requirements::TestRequirementsAutowareReferenceSystem","title":"Classes"},{"location":"Files/test__requirements_8py/#source-code","text":"# Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import os import time import unittest import launch from launch import LaunchDescription from launch.actions import ExecuteProcess import rclpy.context from ros2cli.node.direct import DirectNode import ros2topic.api # Tests to check if executable complies with the requirements for # the autoware_reference_system by checking number of nodes, publishers, # subscribers and frequency of some topics # this file has @variables@ that are meant to be automatically replaced # by values using the `configure_file` CMake function during the build checks = {'topic_exists': False, 'pubs_match': False, 'subs_match': False} # define autoware_reference_system requirements for each topic # NOTE: the pub/sub counts are for the topic, not the node itself reference_system = { '/FrontLidarDriver': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/RearLidarDriver': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointCloudMap': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/Visualizer': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/Lanelet2Map': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointsTransformerFront': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointsTransformerRear': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/VoxelGridDownsampler': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointCloudMapLoader': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/EuclideanClusterDetector': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/ObjectCollisionEstimator': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/MPCController': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/ParkingPlanner': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/LanePlanner': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointCloudFusion': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()}, '/NDTLocalizer': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()}, '/VehicleInterface': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/Lanelet2GlobalPlanner': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()}, '/Lanelet2MapLoader': {'pub_count': 1, 'sub_count': 3, 'checks': checks.copy()}, '/BehaviorPlanner': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()} # does not exist as topic but only as a node # '/VehicleDBWSystem': {'pub_count': 0, 'sub_count': 0, 'checks': checks.copy()} } def generate_test_description(ready_fn): env = os.environ.copy() env['RCUTILS_CONSOLE_OUTPUT_FORMAT'] = '[{severity}] [{name}]: {message}' launch_description = LaunchDescription() context = rclpy.context.Context() rclpy.init(context=context) launch_description.add_action( launch.actions.OpaqueFunction(function=lambda context: ready_fn())) proc_under_test = ExecuteProcess( cmd=['@TEST_EXECUTABLE@'], name='@TEST_EXECUTABLE_NAME@', output='screen', env=env, ) launch_description.add_action(proc_under_test) return launch_description, locals() class TestRequirementsAutowareReferenceSystem(unittest.TestCase): def test_pubs_and_subs(self): with DirectNode([]) as node: seen_topics = {} try: while True: print('topic_monitor looping:') for name in ros2topic.api.get_topic_names(node=node): if name not in seen_topics: seen_topics[name] = {'pub_count': 0, 'sub_count': 0} publishers = node.count_publishers(name) subscribers = node.count_subscribers(name) if seen_topics[name]['pub_count'] < publishers: seen_topics[name]['pub_count'] = publishers if seen_topics[name]['sub_count'] < subscribers: seen_topics[name]['sub_count'] = subscribers if len(seen_topics) > 0: print('Topic monitor data collected') for name in reference_system: if name in seen_topics.keys(): reference_system[name]['checks']['topic_exists'] = True if(reference_system[name]['pub_count'] == seen_topics[name]['pub_count']): reference_system[name]['checks']['pubs_match'] = True else: print('[' + name + '::pubs] EXPECTED: ' + str(reference_system[name]['pub_count'])) print('[' + name + '::pubs] RECEIVED: ' + str(seen_topics[name]['pub_count'])) if(reference_system[name]['sub_count'] == seen_topics[name]['sub_count']): reference_system[name]['checks']['subs_match'] = True else: print('[' + name + '::subs] EXPECTED: ' + str(reference_system[name]['sub_count'])) print('[' + name + '::subs] RECEIVED: ' + str(seen_topics[name]['sub_count'])) self.assertTrue(all(reference_system[name]['checks'].values())) print( f'\\t\\t{name}: ' f\"['topic_exists'=\" f\"{reference_system[name]['checks']['topic_exists']},\" f\" 'pubs_match'=\" f\"{reference_system[name]['checks']['pubs_match']},\" f\" 'subs_match'=\" f\"{reference_system[name]['checks']['subs_match']}]\") # exit while loop, data was collected return # slow down while loop time.sleep(0.5) except SystemError: pass except KeyboardInterrupt: pass Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/test__sample__management_8cpp/","text":"reference_system/test/test_sample_management.cpp Functions Name TEST (test_sample_management , set_benchmark_mode ) TEST (test_sample_management , sample_helpers ) TEST (test_sample_management , statistic_value_struct ) TEST (test_sample_management , sample_statistic_struct ) TEST (test_sample_management , print_sample_path ) TEST (test_sample_management , set_sample_terminates_node_name ) Functions Documentation function TEST TEST( test_sample_management , set_benchmark_mode ) function TEST TEST( test_sample_management , sample_helpers ) function TEST TEST( test_sample_management , statistic_value_struct ) function TEST TEST( test_sample_management , sample_statistic_struct ) function TEST TEST( test_sample_management , print_sample_path ) function TEST TEST( test_sample_management , set_sample_terminates_node_name ) Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <gtest/gtest.h> #include <string> #include \"reference_system/sample_management.hpp\" #include \"reference_system/msg_types.hpp\" TEST(test_sample_management, set_benchmark_mode) { ::testing::Test::RecordProperty(\"TEST_ID\", \"41781862-6454-4d85-a3ee-bf82b1872763\"); EXPECT_FALSE(is_in_benchmark_mode()); set_benchmark_mode(true); EXPECT_TRUE(is_in_benchmark_mode()); set_benchmark_mode(false); EXPECT_FALSE(is_in_benchmark_mode()); } TEST(test_sample_management, sample_helpers) { ::testing::Test::RecordProperty(\"TEST_ID\", \"6245be8e-3050-432f-9f61-a73dd33ff2c4\"); message_t sample; std::string node_name = \"test_node\"; uint32_t sequence_number = 10; uint32_t dropped_samples = 5; uint64_t timestamp = 8675309; set_sample(node_name, sequence_number, dropped_samples, timestamp, sample); // EXPECT_EQ(sample.stats[0].node_name.data(), node_name.data()); // see reference_interfaces for more details // 4kb msg = 4032 = 63 * 64 bytes, 64 bytes = TransmissionStats length EXPECT_EQ(sample.stats.size(), 63u); EXPECT_EQ(sample.stats[0].sequence_number, sequence_number); EXPECT_EQ(sample.stats[0].dropped_samples, dropped_samples); EXPECT_EQ(sample.stats[0].timestamp, timestamp); auto retrieved_stamp = get_sample_timestamp(&sample); EXPECT_EQ(retrieved_stamp, timestamp); auto retrieved_sequence_number = get_sample_sequence_number(&sample); EXPECT_EQ(retrieved_sequence_number, sequence_number); auto retrieved_dropped_samples = get_missed_samples_and_update_seq_nr(&sample, sequence_number); // should be zero based on sequence number EXPECT_EQ(retrieved_dropped_samples, 0u); } TEST(test_sample_management, statistic_value_struct) { auto stats = statistic_value_t(); stats.suffix = \"the_suffix\"; // simulate multiple messages coming in stats.set(1); stats.set(4); stats.set(5); stats.set(7); EXPECT_EQ(stats.average, 4.25); EXPECT_EQ(stats.deviation, 2.5); EXPECT_EQ(stats.min, 1u); EXPECT_EQ(stats.max, 7u); EXPECT_EQ(stats.current, 7u); EXPECT_EQ(stats.total_number, 4u); EXPECT_EQ(stats.suffix, \"the_suffix\"); EXPECT_EQ(stats.adjustment, 0.0); } TEST(test_sample_management, sample_statistic_struct) { auto stats = sample_statistic_t(); stats.timepoint_of_first_received_sample = 1; stats.previous_behavior_planner_sequence = 2; stats.previous_behavior_planner_time_stamp = 3; EXPECT_EQ(stats.timepoint_of_first_received_sample, uint64_t(1)); EXPECT_EQ(stats.previous_behavior_planner_sequence, uint32_t(2)); EXPECT_EQ(stats.previous_behavior_planner_time_stamp, uint64_t(3)); } TEST(test_sample_management, print_sample_path) { message_t sample; std::string node_name = \"test_node\"; uint32_t sample_size = 105; // TODO(evan.flynn): add test for operator<< print function used within print_sample_path set_benchmark_mode(false); uint64_t timestamp = 1; for (uint32_t i = 0; i < sample_size; i++) { set_sample(node_name, i, 0, timestamp, sample); timestamp += 1; } // message sample size will always be 63 if message type is set to 4kb // see reference_interfaces package for more details EXPECT_EQ(sample.size, 63u); print_sample_path(\"test_node\", uint32_t(1), &sample); } TEST(test_sample_management, set_sample_terminates_node_name) { message_t sample; const std::string short_name(\"name_with_few_characters\"); const std::string long_name(sample.stats[0].node_name.size(), 'A'); // Fill the stats buffer with '%'-characters. These characters must no // longer be visible in the resulting buffer sample.size = 0; sample.stats[0].node_name.fill('%'); set_sample(short_name, 1, 0, 0, sample); EXPECT_STREQ( short_name.c_str(), reinterpret_cast<const char *>(sample.stats[0].node_name.data())); sample.size = 0; sample.stats[0].node_name.fill('%'); set_sample(long_name, 1, 0, 0, sample); ASSERT_EQ(sample.stats[0].node_name.back(), '\\0'); auto long_name_without_last_char = long_name.substr(0, long_name.size() - 1); EXPECT_STREQ( long_name_without_last_char.c_str(), reinterpret_cast<const char *>(sample.stats[0].node_name.data())); } Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/test/test_sample_management.cpp"},{"location":"Files/test__sample__management_8cpp/#reference_systemtesttest_sample_managementcpp","text":"","title":"reference_system/test/test_sample_management.cpp"},{"location":"Files/test__sample__management_8cpp/#functions","text":"Name TEST (test_sample_management , set_benchmark_mode ) TEST (test_sample_management , sample_helpers ) TEST (test_sample_management , statistic_value_struct ) TEST (test_sample_management , sample_statistic_struct ) TEST (test_sample_management , print_sample_path ) TEST (test_sample_management , set_sample_terminates_node_name )","title":"Functions"},{"location":"Files/test__sample__management_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Files/test__sample__management_8cpp/#function-test","text":"TEST( test_sample_management , set_benchmark_mode )","title":"function TEST"},{"location":"Files/test__sample__management_8cpp/#function-test_1","text":"TEST( test_sample_management , sample_helpers )","title":"function TEST"},{"location":"Files/test__sample__management_8cpp/#function-test_2","text":"TEST( test_sample_management , statistic_value_struct )","title":"function TEST"},{"location":"Files/test__sample__management_8cpp/#function-test_3","text":"TEST( test_sample_management , sample_statistic_struct )","title":"function TEST"},{"location":"Files/test__sample__management_8cpp/#function-test_4","text":"TEST( test_sample_management , print_sample_path )","title":"function TEST"},{"location":"Files/test__sample__management_8cpp/#function-test_5","text":"TEST( test_sample_management , set_sample_terminates_node_name )","title":"function TEST"},{"location":"Files/test__sample__management_8cpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <gtest/gtest.h> #include <string> #include \"reference_system/sample_management.hpp\" #include \"reference_system/msg_types.hpp\" TEST(test_sample_management, set_benchmark_mode) { ::testing::Test::RecordProperty(\"TEST_ID\", \"41781862-6454-4d85-a3ee-bf82b1872763\"); EXPECT_FALSE(is_in_benchmark_mode()); set_benchmark_mode(true); EXPECT_TRUE(is_in_benchmark_mode()); set_benchmark_mode(false); EXPECT_FALSE(is_in_benchmark_mode()); } TEST(test_sample_management, sample_helpers) { ::testing::Test::RecordProperty(\"TEST_ID\", \"6245be8e-3050-432f-9f61-a73dd33ff2c4\"); message_t sample; std::string node_name = \"test_node\"; uint32_t sequence_number = 10; uint32_t dropped_samples = 5; uint64_t timestamp = 8675309; set_sample(node_name, sequence_number, dropped_samples, timestamp, sample); // EXPECT_EQ(sample.stats[0].node_name.data(), node_name.data()); // see reference_interfaces for more details // 4kb msg = 4032 = 63 * 64 bytes, 64 bytes = TransmissionStats length EXPECT_EQ(sample.stats.size(), 63u); EXPECT_EQ(sample.stats[0].sequence_number, sequence_number); EXPECT_EQ(sample.stats[0].dropped_samples, dropped_samples); EXPECT_EQ(sample.stats[0].timestamp, timestamp); auto retrieved_stamp = get_sample_timestamp(&sample); EXPECT_EQ(retrieved_stamp, timestamp); auto retrieved_sequence_number = get_sample_sequence_number(&sample); EXPECT_EQ(retrieved_sequence_number, sequence_number); auto retrieved_dropped_samples = get_missed_samples_and_update_seq_nr(&sample, sequence_number); // should be zero based on sequence number EXPECT_EQ(retrieved_dropped_samples, 0u); } TEST(test_sample_management, statistic_value_struct) { auto stats = statistic_value_t(); stats.suffix = \"the_suffix\"; // simulate multiple messages coming in stats.set(1); stats.set(4); stats.set(5); stats.set(7); EXPECT_EQ(stats.average, 4.25); EXPECT_EQ(stats.deviation, 2.5); EXPECT_EQ(stats.min, 1u); EXPECT_EQ(stats.max, 7u); EXPECT_EQ(stats.current, 7u); EXPECT_EQ(stats.total_number, 4u); EXPECT_EQ(stats.suffix, \"the_suffix\"); EXPECT_EQ(stats.adjustment, 0.0); } TEST(test_sample_management, sample_statistic_struct) { auto stats = sample_statistic_t(); stats.timepoint_of_first_received_sample = 1; stats.previous_behavior_planner_sequence = 2; stats.previous_behavior_planner_time_stamp = 3; EXPECT_EQ(stats.timepoint_of_first_received_sample, uint64_t(1)); EXPECT_EQ(stats.previous_behavior_planner_sequence, uint32_t(2)); EXPECT_EQ(stats.previous_behavior_planner_time_stamp, uint64_t(3)); } TEST(test_sample_management, print_sample_path) { message_t sample; std::string node_name = \"test_node\"; uint32_t sample_size = 105; // TODO(evan.flynn): add test for operator<< print function used within print_sample_path set_benchmark_mode(false); uint64_t timestamp = 1; for (uint32_t i = 0; i < sample_size; i++) { set_sample(node_name, i, 0, timestamp, sample); timestamp += 1; } // message sample size will always be 63 if message type is set to 4kb // see reference_interfaces package for more details EXPECT_EQ(sample.size, 63u); print_sample_path(\"test_node\", uint32_t(1), &sample); } TEST(test_sample_management, set_sample_terminates_node_name) { message_t sample; const std::string short_name(\"name_with_few_characters\"); const std::string long_name(sample.stats[0].node_name.size(), 'A'); // Fill the stats buffer with '%'-characters. These characters must no // longer be visible in the resulting buffer sample.size = 0; sample.stats[0].node_name.fill('%'); set_sample(short_name, 1, 0, 0, sample); EXPECT_STREQ( short_name.c_str(), reinterpret_cast<const char *>(sample.stats[0].node_name.data())); sample.size = 0; sample.stats[0].node_name.fill('%'); set_sample(long_name, 1, 0, 0, sample); ASSERT_EQ(sample.stats[0].node_name.back(), '\\0'); auto long_name_without_last_char = long_name.substr(0, long_name.size() - 1); EXPECT_STREQ( long_name_without_last_char.c_str(), reinterpret_cast<const char *>(sample.stats[0].node_name.data())); } Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/trace__utils_8py/","text":"reference_system/reference_system_py/trace_utils.py Namespaces Name reference_system_py reference_system_py::trace_utils Source code # Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from tracetools_analysis.loading import load_file from tracetools_analysis.processor.ros2 import Ros2Handler from tracetools_analysis.utils.ros2 import Ros2DataModelUtil def initDataModel(path): events = load_file(path) handler = Ros2Handler.process(events) # handler.data.print_data() return Ros2DataModelUtil(handler.data) Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/reference_system_py/trace_utils.py"},{"location":"Files/trace__utils_8py/#reference_systemreference_system_pytrace_utilspy","text":"","title":"reference_system/reference_system_py/trace_utils.py"},{"location":"Files/trace__utils_8py/#namespaces","text":"Name reference_system_py reference_system_py::trace_utils","title":"Namespaces"},{"location":"Files/trace__utils_8py/#source-code","text":"# Copyright 2021 Apex.AI, Inc. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from tracetools_analysis.loading import load_file from tracetools_analysis.processor.ros2 import Ros2Handler from tracetools_analysis.utils.ros2 import Ros2DataModelUtil def initDataModel(path): events = load_file(path) handler = Ros2Handler.process(events) # handler.data.print_data() return Ros2DataModelUtil(handler.data) Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Files/transform_8hpp/","text":"reference_system/include/reference_system/nodes/rclcpp/transform.hpp Namespaces Name nodes nodes::rclcpp_system Classes Name class nodes::rclcpp_system::Transform Source code // Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__RCLCPP__TRANSFORM_HPP_ #define REFERENCE_SYSTEM__NODES__RCLCPP__TRANSFORM_HPP_ #include <chrono> #include <string> #include <utility> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/msg_types.hpp\" #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/number_cruncher.hpp\" #include \"reference_system/sample_management.hpp\" namespace nodes { namespace rclcpp_system { class Transform : public rclcpp::Node { public: explicit Transform(const TransformSettings & settings) : Node(settings.node_name), number_crunch_limit_(settings.number_crunch_limit) { subscription_ = this->create_subscription<message_t>( settings.input_topic, 1, [this](const message_t::SharedPtr msg) {input_callback(msg);}); publisher_ = this->create_publisher<message_t>(settings.output_topic, 1); } private: void input_callback(const message_t::SharedPtr input_message) { uint64_t timestamp = now_as_int(); auto number_cruncher_result = number_cruncher(number_crunch_limit_); auto output_message = publisher_->borrow_loaned_message(); output_message.get().size = 0; merge_history_into_sample(output_message.get(), input_message); uint32_t missed_samples = get_missed_samples_and_update_seq_nr( input_message, input_sequence_number_); set_sample( this->get_name(), sequence_number_++, missed_samples, timestamp, output_message.get()); // use result so that it is not optimizied away by some clever compiler output_message.get().data[0] = number_cruncher_result; publisher_->publish(std::move(output_message)); } private: rclcpp::Publisher<message_t>::SharedPtr publisher_; rclcpp::Subscription<message_t>::SharedPtr subscription_; uint64_t number_crunch_limit_; uint32_t sequence_number_ = 0; uint32_t input_sequence_number_ = 0; }; } // namespace rclcpp_system } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__RCLCPP__TRANSFORM_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system/include/reference_system/nodes/rclcpp/transform.hpp"},{"location":"Files/transform_8hpp/#reference_systemincludereference_systemnodesrclcpptransformhpp","text":"","title":"reference_system/include/reference_system/nodes/rclcpp/transform.hpp"},{"location":"Files/transform_8hpp/#namespaces","text":"Name nodes nodes::rclcpp_system","title":"Namespaces"},{"location":"Files/transform_8hpp/#classes","text":"Name class nodes::rclcpp_system::Transform","title":"Classes"},{"location":"Files/transform_8hpp/#source-code","text":"// Copyright 2021 Apex.AI, Inc. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef REFERENCE_SYSTEM__NODES__RCLCPP__TRANSFORM_HPP_ #define REFERENCE_SYSTEM__NODES__RCLCPP__TRANSFORM_HPP_ #include <chrono> #include <string> #include <utility> #include \"rclcpp/rclcpp.hpp\" #include \"reference_system/msg_types.hpp\" #include \"reference_system/nodes/settings.hpp\" #include \"reference_system/number_cruncher.hpp\" #include \"reference_system/sample_management.hpp\" namespace nodes { namespace rclcpp_system { class Transform : public rclcpp::Node { public: explicit Transform(const TransformSettings & settings) : Node(settings.node_name), number_crunch_limit_(settings.number_crunch_limit) { subscription_ = this->create_subscription<message_t>( settings.input_topic, 1, [this](const message_t::SharedPtr msg) {input_callback(msg);}); publisher_ = this->create_publisher<message_t>(settings.output_topic, 1); } private: void input_callback(const message_t::SharedPtr input_message) { uint64_t timestamp = now_as_int(); auto number_cruncher_result = number_cruncher(number_crunch_limit_); auto output_message = publisher_->borrow_loaned_message(); output_message.get().size = 0; merge_history_into_sample(output_message.get(), input_message); uint32_t missed_samples = get_missed_samples_and_update_seq_nr( input_message, input_sequence_number_); set_sample( this->get_name(), sequence_number_++, missed_samples, timestamp, output_message.get()); // use result so that it is not optimizied away by some clever compiler output_message.get().data[0] = number_cruncher_result; publisher_->publish(std::move(output_message)); } private: rclcpp::Publisher<message_t>::SharedPtr publisher_; rclcpp::Subscription<message_t>::SharedPtr subscription_; uint64_t number_crunch_limit_; uint32_t sequence_number_ = 0; uint32_t input_sequence_number_ = 0; }; } // namespace rclcpp_system } // namespace nodes #endif // REFERENCE_SYSTEM__NODES__RCLCPP__TRANSFORM_HPP_ Updated on 2022-04-30 at 21:32:33 +0000","title":"Source code"},{"location":"Modules/","text":"Modules Updated on 2022-04-30 at 21:32:33 +0000","title":"Modules"},{"location":"Modules/#modules","text":"Updated on 2022-04-30 at 21:32:33 +0000","title":"Modules"},{"location":"Namespaces/","text":"Namespaces namespace benchmark namespace conftest namespace nodes namespace rclcpp_system namespace timing namespace rclcpp namespace reference_interfaces namespace msg namespace Message4kb_Constants namespace TransmissionStats_Constants namespace reference_system_py namespace benchmark namespace callback_duration namespace constants namespace dropped_messages namespace memory_usage namespace plot_utils namespace std_latency namespace trace_utils namespace setup namespace std::chrono_literals namespace test_platform namespace test_requirements namespace testing namespace unittest Updated on 2022-04-30 at 21:32:33 +0000","title":"Namespaces"},{"location":"Namespaces/#namespaces","text":"namespace benchmark namespace conftest namespace nodes namespace rclcpp_system namespace timing namespace rclcpp namespace reference_interfaces namespace msg namespace Message4kb_Constants namespace TransmissionStats_Constants namespace reference_system_py namespace benchmark namespace callback_duration namespace constants namespace dropped_messages namespace memory_usage namespace plot_utils namespace std_latency namespace trace_utils namespace setup namespace std::chrono_literals namespace test_platform namespace test_requirements namespace testing namespace unittest Updated on 2022-04-30 at 21:32:33 +0000","title":"Namespaces"},{"location":"Namespaces/namespacebenchmark/","text":"benchmark Attributes Name parser help default action cmdline_args dictionary common_args tuple create_dir list runtimes exe_patterns rmws trace_types list exes trace_type exe rmw runtime_sec Attributes Documentation variable parser parser = argparse.ArgumentParser(description='Benchmark an executor implementation.'); variable help help; variable default default; variable action action; variable cmdline_args cmdline_args = parser.parse_args(); variable common_args dictionary common_args = {'pkg': 'autoware_reference_system', 'directory': cmdline_args.logdir}; variable create_dir tuple create_dir = (not cmdline_args.plot_only); variable runtimes list runtimes = [int(runtime) for runtime in cmdline_args.runtimes.split(',')]; variable exe_patterns exe_patterns; variable rmws rmws; variable trace_types trace_types; variable exes list exes = [exe for pattern in exe_patterns for exe in available_executables(pattern=pattern, pkg=common_args['pkg'])]; variable trace_type trace_type; variable exe exe; variable rmw rmw; variable runtime_sec runtime_sec; Updated on 2022-04-30 at 21:32:33 +0000","title":"benchmark"},{"location":"Namespaces/namespacebenchmark/#benchmark","text":"","title":"benchmark"},{"location":"Namespaces/namespacebenchmark/#attributes","text":"Name parser help default action cmdline_args dictionary common_args tuple create_dir list runtimes exe_patterns rmws trace_types list exes trace_type exe rmw runtime_sec","title":"Attributes"},{"location":"Namespaces/namespacebenchmark/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Namespaces/namespacebenchmark/#variable-parser","text":"parser = argparse.ArgumentParser(description='Benchmark an executor implementation.');","title":"variable parser"},{"location":"Namespaces/namespacebenchmark/#variable-help","text":"help;","title":"variable help"},{"location":"Namespaces/namespacebenchmark/#variable-default","text":"default;","title":"variable default"},{"location":"Namespaces/namespacebenchmark/#variable-action","text":"action;","title":"variable action"},{"location":"Namespaces/namespacebenchmark/#variable-cmdline_args","text":"cmdline_args = parser.parse_args();","title":"variable cmdline_args"},{"location":"Namespaces/namespacebenchmark/#variable-common_args","text":"dictionary common_args = {'pkg': 'autoware_reference_system', 'directory': cmdline_args.logdir};","title":"variable common_args"},{"location":"Namespaces/namespacebenchmark/#variable-create_dir","text":"tuple create_dir = (not cmdline_args.plot_only);","title":"variable create_dir"},{"location":"Namespaces/namespacebenchmark/#variable-runtimes","text":"list runtimes = [int(runtime) for runtime in cmdline_args.runtimes.split(',')];","title":"variable runtimes"},{"location":"Namespaces/namespacebenchmark/#variable-exe_patterns","text":"exe_patterns;","title":"variable exe_patterns"},{"location":"Namespaces/namespacebenchmark/#variable-rmws","text":"rmws;","title":"variable rmws"},{"location":"Namespaces/namespacebenchmark/#variable-trace_types","text":"trace_types;","title":"variable trace_types"},{"location":"Namespaces/namespacebenchmark/#variable-exes","text":"list exes = [exe for pattern in exe_patterns for exe in available_executables(pattern=pattern, pkg=common_args['pkg'])];","title":"variable exes"},{"location":"Namespaces/namespacebenchmark/#variable-trace_type","text":"trace_type;","title":"variable trace_type"},{"location":"Namespaces/namespacebenchmark/#variable-exe","text":"exe;","title":"variable exe"},{"location":"Namespaces/namespacebenchmark/#variable-rmw","text":"rmw;","title":"variable rmw"},{"location":"Namespaces/namespacebenchmark/#variable-runtime_sec","text":"runtime_sec; Updated on 2022-04-30 at 21:32:33 +0000","title":"variable runtime_sec"},{"location":"Namespaces/namespaceconftest/","text":"conftest Functions Name def pytest_configure (config config) def pytest_collection_modifyitems (items items) Functions Documentation function pytest_configure def pytest_configure( config config ) Document pytest.mark.TEST_ID to avoid pytest warning.``` ### function pytest_collection_modifyitems ```python def pytest_collection_modifyitems( items items ) Updated on 2022-04-30 at 21:32:33 +0000","title":"conftest"},{"location":"Namespaces/namespaceconftest/#conftest","text":"","title":"conftest"},{"location":"Namespaces/namespaceconftest/#functions","text":"Name def pytest_configure (config config) def pytest_collection_modifyitems (items items)","title":"Functions"},{"location":"Namespaces/namespaceconftest/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Namespaces/namespaceconftest/#function-pytest_configure","text":"def pytest_configure( config config ) Document pytest.mark.TEST_ID to avoid pytest warning.``` ### function pytest_collection_modifyitems ```python def pytest_collection_modifyitems( items items ) Updated on 2022-04-30 at 21:32:33 +0000","title":"function pytest_configure"},{"location":"Namespaces/namespacenodes/","text":"nodes Namespaces Name nodes::rclcpp_system nodes::timing Classes Name struct nodes::CommandSettings struct nodes::CyclicSettings struct nodes::FusionSettings struct nodes::IntersectionSettings struct nodes::SensorSettings struct nodes::TransformSettings Updated on 2022-04-30 at 21:32:33 +0000","title":"nodes"},{"location":"Namespaces/namespacenodes/#nodes","text":"","title":"nodes"},{"location":"Namespaces/namespacenodes/#namespaces","text":"Name nodes::rclcpp_system nodes::timing","title":"Namespaces"},{"location":"Namespaces/namespacenodes/#classes","text":"Name struct nodes::CommandSettings struct nodes::CyclicSettings struct nodes::FusionSettings struct nodes::IntersectionSettings struct nodes::SensorSettings struct nodes::TransformSettings Updated on 2022-04-30 at 21:32:33 +0000","title":"Classes"},{"location":"Namespaces/namespacenodes_1_1rclcpp__system/","text":"nodes::rclcpp_system Classes Name class nodes::rclcpp_system::Command class nodes::rclcpp_system::Cyclic class nodes::rclcpp_system::Fusion class nodes::rclcpp_system::Intersection class nodes::rclcpp_system::Sensor class nodes::rclcpp_system::Transform Updated on 2022-04-30 at 21:32:33 +0000","title":"nodes::rclcpp_system"},{"location":"Namespaces/namespacenodes_1_1rclcpp__system/#nodesrclcpp_system","text":"","title":"nodes::rclcpp_system"},{"location":"Namespaces/namespacenodes_1_1rclcpp__system/#classes","text":"Name class nodes::rclcpp_system::Command class nodes::rclcpp_system::Cyclic class nodes::rclcpp_system::Fusion class nodes::rclcpp_system::Intersection class nodes::rclcpp_system::Sensor class nodes::rclcpp_system::Transform Updated on 2022-04-30 at 21:32:33 +0000","title":"Classes"},{"location":"Namespaces/namespacenodes_1_1timing/","text":"nodes::timing Classes Name struct nodes::timing::BenchmarkCPUUsage struct nodes::timing::BenchmarkThroughput struct nodes::timing::Default Updated on 2022-04-30 at 21:32:33 +0000","title":"nodes::timing"},{"location":"Namespaces/namespacenodes_1_1timing/#nodestiming","text":"","title":"nodes::timing"},{"location":"Namespaces/namespacenodes_1_1timing/#classes","text":"Name struct nodes::timing::BenchmarkCPUUsage struct nodes::timing::BenchmarkThroughput struct nodes::timing::Default Updated on 2022-04-30 at 21:32:33 +0000","title":"Classes"},{"location":"Namespaces/namespacerclcpp/","text":"rclcpp Updated on 2022-04-30 at 21:32:33 +0000","title":"rclcpp"},{"location":"Namespaces/namespacerclcpp/#rclcpp","text":"Updated on 2022-04-30 at 21:32:33 +0000","title":"rclcpp"},{"location":"Namespaces/namespacereference__interfaces/","text":"reference_interfaces Namespaces Name reference_interfaces::msg Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_interfaces"},{"location":"Namespaces/namespacereference__interfaces/#reference_interfaces","text":"","title":"reference_interfaces"},{"location":"Namespaces/namespacereference__interfaces/#namespaces","text":"Name reference_interfaces::msg Updated on 2022-04-30 at 21:32:33 +0000","title":"Namespaces"},{"location":"Namespaces/namespacereference__interfaces_1_1msg/","text":"reference_interfaces::msg Namespaces Name reference_interfaces::msg::Message4kb_Constants reference_interfaces::msg::TransmissionStats_Constants Classes Name struct reference_interfaces::msg::Message4kb struct reference_interfaces::msg::TransmissionStats Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_interfaces::msg"},{"location":"Namespaces/namespacereference__interfaces_1_1msg/#reference_interfacesmsg","text":"","title":"reference_interfaces::msg"},{"location":"Namespaces/namespacereference__interfaces_1_1msg/#namespaces","text":"Name reference_interfaces::msg::Message4kb_Constants reference_interfaces::msg::TransmissionStats_Constants","title":"Namespaces"},{"location":"Namespaces/namespacereference__interfaces_1_1msg/#classes","text":"Name struct reference_interfaces::msg::Message4kb struct reference_interfaces::msg::TransmissionStats Updated on 2022-04-30 at 21:32:33 +0000","title":"Classes"},{"location":"Namespaces/namespacereference__interfaces_1_1msg_1_1Message4kb__Constants/","text":"reference_interfaces::msg::Message4kb_Constants Attributes Name const uint64 STATS_CAPACITY Attributes Documentation variable STATS_CAPACITY const uint64 STATS_CAPACITY = 63; Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_interfaces::msg::Message4kb_Constants"},{"location":"Namespaces/namespacereference__interfaces_1_1msg_1_1Message4kb__Constants/#reference_interfacesmsgmessage4kb_constants","text":"","title":"reference_interfaces::msg::Message4kb_Constants"},{"location":"Namespaces/namespacereference__interfaces_1_1msg_1_1Message4kb__Constants/#attributes","text":"Name const uint64 STATS_CAPACITY","title":"Attributes"},{"location":"Namespaces/namespacereference__interfaces_1_1msg_1_1Message4kb__Constants/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Namespaces/namespacereference__interfaces_1_1msg_1_1Message4kb__Constants/#variable-stats_capacity","text":"const uint64 STATS_CAPACITY = 63; Updated on 2022-04-30 at 21:32:33 +0000","title":"variable STATS_CAPACITY"},{"location":"Namespaces/namespacereference__interfaces_1_1msg_1_1TransmissionStats__Constants/","text":"reference_interfaces::msg::TransmissionStats_Constants Attributes Name const uint64 NODE_NAME_LENGTH Attributes Documentation variable NODE_NAME_LENGTH const uint64 NODE_NAME_LENGTH = 48; Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_interfaces::msg::TransmissionStats_Constants"},{"location":"Namespaces/namespacereference__interfaces_1_1msg_1_1TransmissionStats__Constants/#reference_interfacesmsgtransmissionstats_constants","text":"","title":"reference_interfaces::msg::TransmissionStats_Constants"},{"location":"Namespaces/namespacereference__interfaces_1_1msg_1_1TransmissionStats__Constants/#attributes","text":"Name const uint64 NODE_NAME_LENGTH","title":"Attributes"},{"location":"Namespaces/namespacereference__interfaces_1_1msg_1_1TransmissionStats__Constants/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Namespaces/namespacereference__interfaces_1_1msg_1_1TransmissionStats__Constants/#variable-node_name_length","text":"const uint64 NODE_NAME_LENGTH = 48; Updated on 2022-04-30 at 21:32:33 +0000","title":"variable NODE_NAME_LENGTH"},{"location":"Namespaces/namespacereference__system__py/","text":"reference_system_py Namespaces Name reference_system_py::benchmark reference_system_py::callback_duration reference_system_py::constants reference_system_py::dropped_messages reference_system_py::memory_usage reference_system_py::plot_utils reference_system_py::std_latency reference_system_py::trace_utils Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system_py"},{"location":"Namespaces/namespacereference__system__py/#reference_system_py","text":"","title":"reference_system_py"},{"location":"Namespaces/namespacereference__system__py/#namespaces","text":"Name reference_system_py::benchmark reference_system_py::callback_duration reference_system_py::constants reference_system_py::dropped_messages reference_system_py::memory_usage reference_system_py::plot_utils reference_system_py::std_latency reference_system_py::trace_utils Updated on 2022-04-30 at 21:32:33 +0000","title":"Namespaces"},{"location":"Namespaces/namespacereference__system__py_1_1benchmark/","text":"reference_system_py::benchmark Functions Name def available_executables (pkg pkg, pattern pattern =' *') def get_benchmark_directory (base_directory base_directory, executable executable, runtime_sec runtime_sec, rmw rmw, create create =False) def get_benchmark_directories_below (base_directory base_directory, runtime_sec runtime_sec =None) def terminatingRos2Run (pkg pkg, executable executable, rmw rmw, env env =os.environ, args args =[], ** kwargs) def roudi_daemon (env env =os.environ, roudi_config_path roudi_config_path =None) def generate_callback_trace (executable executable, pkg pkg, directory directory, runtime_sec runtime_sec, rmw rmw) def generate_std_trace (executable executable, pkg pkg, directory directory, runtime_sec runtime_sec, rmw rmw) def generate_memory_trace (executable executable, pkg pkg, directory directory, runtime_sec runtime_sec, rmw rmw) def generate_trace (trace_type trace_type, * args, ** kwargs) def generate_callback_report (executable executable, pkg pkg, directory directory, runtime_sec runtime_sec, rmw rmw) def generate_memory_report (executable executable, pkg pkg, directory directory, runtime_sec runtime_sec, rmw rmw) def generate_report (trace_type trace_type, * args, ** kwargs) def generate_summary_report (trace_type trace_type, pkg pkg, directory directory, runtime_sec runtime_sec) def setup_benchmark_directory (pkg pkg, create create =False) Attributes Name bool tracetools_available ROS_HOME Functions Documentation function available_executables def available_executables( pkg pkg, pattern pattern =' *' ) function get_benchmark_directory def get_benchmark_directory( base_directory base_directory, executable executable, runtime_sec runtime_sec, rmw rmw, create create =False ) Return the directory to place measurements and reports for the given experiment. If `create` is True, the directory is created if it does not exist yet. function get_benchmark_directories_below def get_benchmark_directories_below( base_directory base_directory, runtime_sec runtime_sec =None ) Return all benchmark directories found below `base_directory`.``` ### function terminatingRos2Run ```python def terminatingRos2Run( pkg pkg, executable executable, rmw rmw, env env =os.environ, args args =[], ** kwargs ) Run the given executable (part of the given package) under the given rmw. The executable is automatically terminated upon exit from the context function roudi_daemon def roudi_daemon( env env =os.environ, roudi_config_path roudi_config_path =None ) Context manager that runs a RouDi instance for the duration of the context. The `env` parameter specifies environment variables for the RouDi process. The `roudi_config_path` parameter can be used to provide a RouDi toml configuration file. function generate_callback_trace def generate_callback_trace( executable executable, pkg pkg, directory directory, runtime_sec runtime_sec, rmw rmw ) Generate a tracefile for the given executable using the 'callback' method. The 'callback' method measures the executable using 'ros2 trace' function generate_std_trace def generate_std_trace( executable executable, pkg pkg, directory directory, runtime_sec runtime_sec, rmw rmw ) Generate a tracefile for the given executable using the 'std' method. The 'std' method logs stdout of the executable. function generate_memory_trace def generate_memory_trace( executable executable, pkg pkg, directory directory, runtime_sec runtime_sec, rmw rmw ) Generate a tracefile for the given executable using the 'memory' method. The 'memory' method uses `psrecord` to profile memory and CPU usage. function generate_trace def generate_trace( trace_type trace_type, * args, ** kwargs ) function generate_callback_report def generate_callback_report( executable executable, pkg pkg, directory directory, runtime_sec runtime_sec, rmw rmw ) Generate a per-executable report from the 'callback' trace file.``` ### function generate_memory_report ```python def generate_memory_report( executable executable, pkg pkg, directory directory, runtime_sec runtime_sec, rmw rmw ) Generate a per-executable report from the 'memory' trace file.``` ### function generate_report ```python def generate_report( trace_type trace_type, * args, ** kwargs ) function generate_summary_report def generate_summary_report( trace_type trace_type, pkg pkg, directory directory, runtime_sec runtime_sec ) Generate a summary report for the given `trace_type`, using all traces under `directory`.``` ### function setup_benchmark_directory ```python def setup_benchmark_directory( pkg pkg, create create =False ) Attributes Documentation variable tracetools_available bool tracetools_available = True; variable ROS_HOME ROS_HOME = Path(os.environ.get('ROS_HOME', os.environ['HOME']+'/.ros')); Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system_py::benchmark"},{"location":"Namespaces/namespacereference__system__py_1_1benchmark/#reference_system_pybenchmark","text":"","title":"reference_system_py::benchmark"},{"location":"Namespaces/namespacereference__system__py_1_1benchmark/#functions","text":"Name def available_executables (pkg pkg, pattern pattern =' *') def get_benchmark_directory (base_directory base_directory, executable executable, runtime_sec runtime_sec, rmw rmw, create create =False) def get_benchmark_directories_below (base_directory base_directory, runtime_sec runtime_sec =None) def terminatingRos2Run (pkg pkg, executable executable, rmw rmw, env env =os.environ, args args =[], ** kwargs) def roudi_daemon (env env =os.environ, roudi_config_path roudi_config_path =None) def generate_callback_trace (executable executable, pkg pkg, directory directory, runtime_sec runtime_sec, rmw rmw) def generate_std_trace (executable executable, pkg pkg, directory directory, runtime_sec runtime_sec, rmw rmw) def generate_memory_trace (executable executable, pkg pkg, directory directory, runtime_sec runtime_sec, rmw rmw) def generate_trace (trace_type trace_type, * args, ** kwargs) def generate_callback_report (executable executable, pkg pkg, directory directory, runtime_sec runtime_sec, rmw rmw) def generate_memory_report (executable executable, pkg pkg, directory directory, runtime_sec runtime_sec, rmw rmw) def generate_report (trace_type trace_type, * args, ** kwargs) def generate_summary_report (trace_type trace_type, pkg pkg, directory directory, runtime_sec runtime_sec) def setup_benchmark_directory (pkg pkg, create create =False)","title":"Functions"},{"location":"Namespaces/namespacereference__system__py_1_1benchmark/#attributes","text":"Name bool tracetools_available ROS_HOME","title":"Attributes"},{"location":"Namespaces/namespacereference__system__py_1_1benchmark/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Namespaces/namespacereference__system__py_1_1benchmark/#function-available_executables","text":"def available_executables( pkg pkg, pattern pattern =' *' )","title":"function available_executables"},{"location":"Namespaces/namespacereference__system__py_1_1benchmark/#function-get_benchmark_directory","text":"def get_benchmark_directory( base_directory base_directory, executable executable, runtime_sec runtime_sec, rmw rmw, create create =False ) Return the directory to place measurements and reports for the given experiment. If `create` is True, the directory is created if it does not exist yet.","title":"function get_benchmark_directory"},{"location":"Namespaces/namespacereference__system__py_1_1benchmark/#function-get_benchmark_directories_below","text":"def get_benchmark_directories_below( base_directory base_directory, runtime_sec runtime_sec =None ) Return all benchmark directories found below `base_directory`.``` ### function terminatingRos2Run ```python def terminatingRos2Run( pkg pkg, executable executable, rmw rmw, env env =os.environ, args args =[], ** kwargs ) Run the given executable (part of the given package) under the given rmw. The executable is automatically terminated upon exit from the context","title":"function get_benchmark_directories_below"},{"location":"Namespaces/namespacereference__system__py_1_1benchmark/#function-roudi_daemon","text":"def roudi_daemon( env env =os.environ, roudi_config_path roudi_config_path =None ) Context manager that runs a RouDi instance for the duration of the context. The `env` parameter specifies environment variables for the RouDi process. The `roudi_config_path` parameter can be used to provide a RouDi toml configuration file.","title":"function roudi_daemon"},{"location":"Namespaces/namespacereference__system__py_1_1benchmark/#function-generate_callback_trace","text":"def generate_callback_trace( executable executable, pkg pkg, directory directory, runtime_sec runtime_sec, rmw rmw ) Generate a tracefile for the given executable using the 'callback' method. The 'callback' method measures the executable using 'ros2 trace'","title":"function generate_callback_trace"},{"location":"Namespaces/namespacereference__system__py_1_1benchmark/#function-generate_std_trace","text":"def generate_std_trace( executable executable, pkg pkg, directory directory, runtime_sec runtime_sec, rmw rmw ) Generate a tracefile for the given executable using the 'std' method. The 'std' method logs stdout of the executable.","title":"function generate_std_trace"},{"location":"Namespaces/namespacereference__system__py_1_1benchmark/#function-generate_memory_trace","text":"def generate_memory_trace( executable executable, pkg pkg, directory directory, runtime_sec runtime_sec, rmw rmw ) Generate a tracefile for the given executable using the 'memory' method. The 'memory' method uses `psrecord` to profile memory and CPU usage.","title":"function generate_memory_trace"},{"location":"Namespaces/namespacereference__system__py_1_1benchmark/#function-generate_trace","text":"def generate_trace( trace_type trace_type, * args, ** kwargs )","title":"function generate_trace"},{"location":"Namespaces/namespacereference__system__py_1_1benchmark/#function-generate_callback_report","text":"def generate_callback_report( executable executable, pkg pkg, directory directory, runtime_sec runtime_sec, rmw rmw ) Generate a per-executable report from the 'callback' trace file.``` ### function generate_memory_report ```python def generate_memory_report( executable executable, pkg pkg, directory directory, runtime_sec runtime_sec, rmw rmw ) Generate a per-executable report from the 'memory' trace file.``` ### function generate_report ```python def generate_report( trace_type trace_type, * args, ** kwargs )","title":"function generate_callback_report"},{"location":"Namespaces/namespacereference__system__py_1_1benchmark/#function-generate_summary_report","text":"def generate_summary_report( trace_type trace_type, pkg pkg, directory directory, runtime_sec runtime_sec ) Generate a summary report for the given `trace_type`, using all traces under `directory`.``` ### function setup_benchmark_directory ```python def setup_benchmark_directory( pkg pkg, create create =False )","title":"function generate_summary_report"},{"location":"Namespaces/namespacereference__system__py_1_1benchmark/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Namespaces/namespacereference__system__py_1_1benchmark/#variable-tracetools_available","text":"bool tracetools_available = True;","title":"variable tracetools_available"},{"location":"Namespaces/namespacereference__system__py_1_1benchmark/#variable-ros_home","text":"ROS_HOME = Path(os.environ.get('ROS_HOME', os.environ['HOME']+'/.ros')); Updated on 2022-04-30 at 21:32:33 +0000","title":"variable ROS_HOME"},{"location":"Namespaces/namespacereference__system__py_1_1callback__duration/","text":"reference_system_py::callback_duration Functions Name def summary (data_model data_model, size size) def individual (data_model data_model, size size) Functions Documentation function summary def summary( data_model data_model, size size ) function individual def individual( data_model data_model, size size ) Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system_py::callback_duration"},{"location":"Namespaces/namespacereference__system__py_1_1callback__duration/#reference_system_pycallback_duration","text":"","title":"reference_system_py::callback_duration"},{"location":"Namespaces/namespacereference__system__py_1_1callback__duration/#functions","text":"Name def summary (data_model data_model, size size) def individual (data_model data_model, size size)","title":"Functions"},{"location":"Namespaces/namespacereference__system__py_1_1callback__duration/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Namespaces/namespacereference__system__py_1_1callback__duration/#function-summary","text":"def summary( data_model data_model, size size )","title":"function summary"},{"location":"Namespaces/namespacereference__system__py_1_1callback__duration/#function-individual","text":"def individual( data_model data_model, size size ) Updated on 2022-04-30 at 21:32:33 +0000","title":"function individual"},{"location":"Namespaces/namespacereference__system__py_1_1constants/","text":"reference_system_py::constants Attributes Name string TRACE_CALLBACK string TRACE_MEMORY string TRACE_STD string TRACE_DIRECTORY int SIZE_SUMMARY int SIZE_SUBPLOT int SIZE_TABLE_ROW int SIZE_TABLE_WIDTH string SIZE_TITLE string SIZE_AXIS_LABEL string SIZE_CATEGORY_LABEL string SIZE_MAJOR_LABEL Attributes Documentation variable TRACE_CALLBACK string TRACE_CALLBACK = 'tracing'; variable TRACE_MEMORY string TRACE_MEMORY = 'memory'; variable TRACE_STD string TRACE_STD = 'log'; variable TRACE_DIRECTORY string TRACE_DIRECTORY = 'tracing'; variable SIZE_SUMMARY int SIZE_SUMMARY = 800; variable SIZE_SUBPLOT int SIZE_SUBPLOT = 500; variable SIZE_TABLE_ROW int SIZE_TABLE_ROW = 50; variable SIZE_TABLE_WIDTH int SIZE_TABLE_WIDTH = 1250; variable SIZE_TITLE string SIZE_TITLE = '22px'; variable SIZE_AXIS_LABEL string SIZE_AXIS_LABEL = '20px'; variable SIZE_CATEGORY_LABEL string SIZE_CATEGORY_LABEL = '15px'; variable SIZE_MAJOR_LABEL string SIZE_MAJOR_LABEL = '14px'; Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system_py::constants"},{"location":"Namespaces/namespacereference__system__py_1_1constants/#reference_system_pyconstants","text":"","title":"reference_system_py::constants"},{"location":"Namespaces/namespacereference__system__py_1_1constants/#attributes","text":"Name string TRACE_CALLBACK string TRACE_MEMORY string TRACE_STD string TRACE_DIRECTORY int SIZE_SUMMARY int SIZE_SUBPLOT int SIZE_TABLE_ROW int SIZE_TABLE_WIDTH string SIZE_TITLE string SIZE_AXIS_LABEL string SIZE_CATEGORY_LABEL string SIZE_MAJOR_LABEL","title":"Attributes"},{"location":"Namespaces/namespacereference__system__py_1_1constants/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Namespaces/namespacereference__system__py_1_1constants/#variable-trace_callback","text":"string TRACE_CALLBACK = 'tracing';","title":"variable TRACE_CALLBACK"},{"location":"Namespaces/namespacereference__system__py_1_1constants/#variable-trace_memory","text":"string TRACE_MEMORY = 'memory';","title":"variable TRACE_MEMORY"},{"location":"Namespaces/namespacereference__system__py_1_1constants/#variable-trace_std","text":"string TRACE_STD = 'log';","title":"variable TRACE_STD"},{"location":"Namespaces/namespacereference__system__py_1_1constants/#variable-trace_directory","text":"string TRACE_DIRECTORY = 'tracing';","title":"variable TRACE_DIRECTORY"},{"location":"Namespaces/namespacereference__system__py_1_1constants/#variable-size_summary","text":"int SIZE_SUMMARY = 800;","title":"variable SIZE_SUMMARY"},{"location":"Namespaces/namespacereference__system__py_1_1constants/#variable-size_subplot","text":"int SIZE_SUBPLOT = 500;","title":"variable SIZE_SUBPLOT"},{"location":"Namespaces/namespacereference__system__py_1_1constants/#variable-size_table_row","text":"int SIZE_TABLE_ROW = 50;","title":"variable SIZE_TABLE_ROW"},{"location":"Namespaces/namespacereference__system__py_1_1constants/#variable-size_table_width","text":"int SIZE_TABLE_WIDTH = 1250;","title":"variable SIZE_TABLE_WIDTH"},{"location":"Namespaces/namespacereference__system__py_1_1constants/#variable-size_title","text":"string SIZE_TITLE = '22px';","title":"variable SIZE_TITLE"},{"location":"Namespaces/namespacereference__system__py_1_1constants/#variable-size_axis_label","text":"string SIZE_AXIS_LABEL = '20px';","title":"variable SIZE_AXIS_LABEL"},{"location":"Namespaces/namespacereference__system__py_1_1constants/#variable-size_category_label","text":"string SIZE_CATEGORY_LABEL = '15px';","title":"variable SIZE_CATEGORY_LABEL"},{"location":"Namespaces/namespacereference__system__py_1_1constants/#variable-size_major_label","text":"string SIZE_MAJOR_LABEL = '14px'; Updated on 2022-04-30 at 21:32:33 +0000","title":"variable SIZE_MAJOR_LABEL"},{"location":"Namespaces/namespacereference__system__py_1_1dropped__messages/","text":"reference_system_py::dropped_messages Functions Name def individual (data_model data_model, size size) def parseData (data_model data_model) def getRunTime (start start, end end) def calcTotals (run_time run_time, dataframe dataframe) def generateNodeGraph (dataframe dataframe) def countDropped (dataframe dataframe, node_graph node_graph) Attributes Name bool nx_available Functions Documentation function individual def individual( data_model data_model, size size ) function parseData def parseData( data_model data_model ) function getRunTime def getRunTime( start start, end end ) function calcTotals def calcTotals( run_time run_time, dataframe dataframe ) function generateNodeGraph def generateNodeGraph( dataframe dataframe ) function countDropped def countDropped( dataframe dataframe, node_graph node_graph ) Attributes Documentation variable nx_available bool nx_available = True; Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system_py::dropped_messages"},{"location":"Namespaces/namespacereference__system__py_1_1dropped__messages/#reference_system_pydropped_messages","text":"","title":"reference_system_py::dropped_messages"},{"location":"Namespaces/namespacereference__system__py_1_1dropped__messages/#functions","text":"Name def individual (data_model data_model, size size) def parseData (data_model data_model) def getRunTime (start start, end end) def calcTotals (run_time run_time, dataframe dataframe) def generateNodeGraph (dataframe dataframe) def countDropped (dataframe dataframe, node_graph node_graph)","title":"Functions"},{"location":"Namespaces/namespacereference__system__py_1_1dropped__messages/#attributes","text":"Name bool nx_available","title":"Attributes"},{"location":"Namespaces/namespacereference__system__py_1_1dropped__messages/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Namespaces/namespacereference__system__py_1_1dropped__messages/#function-individual","text":"def individual( data_model data_model, size size )","title":"function individual"},{"location":"Namespaces/namespacereference__system__py_1_1dropped__messages/#function-parsedata","text":"def parseData( data_model data_model )","title":"function parseData"},{"location":"Namespaces/namespacereference__system__py_1_1dropped__messages/#function-getruntime","text":"def getRunTime( start start, end end )","title":"function getRunTime"},{"location":"Namespaces/namespacereference__system__py_1_1dropped__messages/#function-calctotals","text":"def calcTotals( run_time run_time, dataframe dataframe )","title":"function calcTotals"},{"location":"Namespaces/namespacereference__system__py_1_1dropped__messages/#function-generatenodegraph","text":"def generateNodeGraph( dataframe dataframe )","title":"function generateNodeGraph"},{"location":"Namespaces/namespacereference__system__py_1_1dropped__messages/#function-countdropped","text":"def countDropped( dataframe dataframe, node_graph node_graph )","title":"function countDropped"},{"location":"Namespaces/namespacereference__system__py_1_1dropped__messages/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Namespaces/namespacereference__system__py_1_1dropped__messages/#variable-nx_available","text":"bool nx_available = True; Updated on 2022-04-30 at 21:32:33 +0000","title":"variable nx_available"},{"location":"Namespaces/namespacereference__system__py_1_1memory__usage/","text":"reference_system_py::memory_usage Functions Name def summary_from_directories (dirs dirs, duration duration, size size) def individual (path path, size size) Functions Documentation function summary_from_directories def summary_from_directories( dirs dirs, duration duration, size size ) function individual def individual( path path, size size ) Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system_py::memory_usage"},{"location":"Namespaces/namespacereference__system__py_1_1memory__usage/#reference_system_pymemory_usage","text":"","title":"reference_system_py::memory_usage"},{"location":"Namespaces/namespacereference__system__py_1_1memory__usage/#functions","text":"Name def summary_from_directories (dirs dirs, duration duration, size size) def individual (path path, size size)","title":"Functions"},{"location":"Namespaces/namespacereference__system__py_1_1memory__usage/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Namespaces/namespacereference__system__py_1_1memory__usage/#function-summary_from_directories","text":"def summary_from_directories( dirs dirs, duration duration, size size )","title":"function summary_from_directories"},{"location":"Namespaces/namespacereference__system__py_1_1memory__usage/#function-individual","text":"def individual( path path, size size ) Updated on 2022-04-30 at 21:32:33 +0000","title":"function individual"},{"location":"Namespaces/namespacereference__system__py_1_1plot__utils/","text":"reference_system_py::plot_utils Functions Name def plot_barplot (fig fig, data_source data_source, fill_color fill_color ='gray') Functions Documentation function plot_barplot def plot_barplot( fig fig, data_source data_source, fill_color fill_color ='gray' ) Plot a barplot in `fig` using data from `data_source`. `data_source` is assumed to contain the following columns: - 'x' contains the x-coordinate - 'low' and 'high' contain the minimum/maximum - 'box_bottom' and 'box_top' contain the beginning/end of the box (mean +- stddev) - 'mean' contains the mean value Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system_py::plot_utils"},{"location":"Namespaces/namespacereference__system__py_1_1plot__utils/#reference_system_pyplot_utils","text":"","title":"reference_system_py::plot_utils"},{"location":"Namespaces/namespacereference__system__py_1_1plot__utils/#functions","text":"Name def plot_barplot (fig fig, data_source data_source, fill_color fill_color ='gray')","title":"Functions"},{"location":"Namespaces/namespacereference__system__py_1_1plot__utils/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Namespaces/namespacereference__system__py_1_1plot__utils/#function-plot_barplot","text":"def plot_barplot( fig fig, data_source data_source, fill_color fill_color ='gray' ) Plot a barplot in `fig` using data from `data_source`. `data_source` is assumed to contain the following columns: - 'x' contains the x-coordinate - 'low' and 'high' contain the minimum/maximum - 'box_bottom' and 'box_top' contain the beginning/end of the box (mean +- stddev) - 'mean' contains the mean value Updated on 2022-04-30 at 21:32:33 +0000","title":"function plot_barplot"},{"location":"Namespaces/namespacereference__system__py_1_1std__latency/","text":"reference_system_py::std_latency Functions Name def summary_from_directories (dirs dirs, duration duration, size size) def parse_stats_from_values (latency_ latency_, min_ min_, max_ max_, average_ average_, deviation_ deviation_) def parseLogSummaryFromFiles (files files, duration duration) Functions Documentation function summary_from_directories def summary_from_directories( dirs dirs, duration duration, size size ) function parse_stats_from_values def parse_stats_from_values( latency_ latency_, min_ min_, max_ max_, average_ average_, deviation_ deviation_ ) function parseLogSummaryFromFiles def parseLogSummaryFromFiles( files files, duration duration ) Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system_py::std_latency"},{"location":"Namespaces/namespacereference__system__py_1_1std__latency/#reference_system_pystd_latency","text":"","title":"reference_system_py::std_latency"},{"location":"Namespaces/namespacereference__system__py_1_1std__latency/#functions","text":"Name def summary_from_directories (dirs dirs, duration duration, size size) def parse_stats_from_values (latency_ latency_, min_ min_, max_ max_, average_ average_, deviation_ deviation_) def parseLogSummaryFromFiles (files files, duration duration)","title":"Functions"},{"location":"Namespaces/namespacereference__system__py_1_1std__latency/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Namespaces/namespacereference__system__py_1_1std__latency/#function-summary_from_directories","text":"def summary_from_directories( dirs dirs, duration duration, size size )","title":"function summary_from_directories"},{"location":"Namespaces/namespacereference__system__py_1_1std__latency/#function-parse_stats_from_values","text":"def parse_stats_from_values( latency_ latency_, min_ min_, max_ max_, average_ average_, deviation_ deviation_ )","title":"function parse_stats_from_values"},{"location":"Namespaces/namespacereference__system__py_1_1std__latency/#function-parselogsummaryfromfiles","text":"def parseLogSummaryFromFiles( files files, duration duration ) Updated on 2022-04-30 at 21:32:33 +0000","title":"function parseLogSummaryFromFiles"},{"location":"Namespaces/namespacereference__system__py_1_1trace__utils/","text":"reference_system_py::trace_utils Functions Name def initDataModel (path path) Functions Documentation function initDataModel def initDataModel( path path ) Updated on 2022-04-30 at 21:32:33 +0000","title":"reference_system_py::trace_utils"},{"location":"Namespaces/namespacereference__system__py_1_1trace__utils/#reference_system_pytrace_utils","text":"","title":"reference_system_py::trace_utils"},{"location":"Namespaces/namespacereference__system__py_1_1trace__utils/#functions","text":"Name def initDataModel (path path)","title":"Functions"},{"location":"Namespaces/namespacereference__system__py_1_1trace__utils/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Namespaces/namespacereference__system__py_1_1trace__utils/#function-initdatamodel","text":"def initDataModel( path path ) Updated on 2022-04-30 at 21:32:33 +0000","title":"function initDataModel"},{"location":"Namespaces/namespacesetup/","text":"setup Attributes Name string package_name name version description license author author_email data_files packages tests_require entry_points Attributes Documentation variable package_name string package_name = 'reference_system'; variable name name; variable version version; variable description description; variable license license; variable author author; variable author_email author_email; variable data_files data_files; variable packages packages; variable tests_require tests_require; variable entry_points entry_points; Updated on 2022-04-30 at 21:32:33 +0000","title":"setup"},{"location":"Namespaces/namespacesetup/#setup","text":"","title":"setup"},{"location":"Namespaces/namespacesetup/#attributes","text":"Name string package_name name version description license author author_email data_files packages tests_require entry_points","title":"Attributes"},{"location":"Namespaces/namespacesetup/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Namespaces/namespacesetup/#variable-package_name","text":"string package_name = 'reference_system';","title":"variable package_name"},{"location":"Namespaces/namespacesetup/#variable-name","text":"name;","title":"variable name"},{"location":"Namespaces/namespacesetup/#variable-version","text":"version;","title":"variable version"},{"location":"Namespaces/namespacesetup/#variable-description","text":"description;","title":"variable description"},{"location":"Namespaces/namespacesetup/#variable-license","text":"license;","title":"variable license"},{"location":"Namespaces/namespacesetup/#variable-author","text":"author;","title":"variable author"},{"location":"Namespaces/namespacesetup/#variable-author_email","text":"author_email;","title":"variable author_email"},{"location":"Namespaces/namespacesetup/#variable-data_files","text":"data_files;","title":"variable data_files"},{"location":"Namespaces/namespacesetup/#variable-packages","text":"packages;","title":"variable packages"},{"location":"Namespaces/namespacesetup/#variable-tests_require","text":"tests_require;","title":"variable tests_require"},{"location":"Namespaces/namespacesetup/#variable-entry_points","text":"entry_points; Updated on 2022-04-30 at 21:32:33 +0000","title":"variable entry_points"},{"location":"Namespaces/namespacestd_1_1chrono__literals/","text":"std::chrono_literals Updated on 2022-04-30 at 21:32:33 +0000","title":"std::chrono_literals"},{"location":"Namespaces/namespacestd_1_1chrono__literals/#stdchrono_literals","text":"Updated on 2022-04-30 at 21:32:33 +0000","title":"std::chrono_literals"},{"location":"Namespaces/namespacetest__platform/","text":"test_platform Functions Name def test_platform (record_property record_property) Attributes Name dictionary platforms Functions Documentation function test_platform def test_platform( record_property record_property ) Attributes Documentation variable platforms dictionary platforms = {}; Updated on 2022-04-30 at 21:32:33 +0000","title":"test_platform"},{"location":"Namespaces/namespacetest__platform/#test_platform","text":"","title":"test_platform"},{"location":"Namespaces/namespacetest__platform/#functions","text":"Name def test_platform (record_property record_property)","title":"Functions"},{"location":"Namespaces/namespacetest__platform/#attributes","text":"Name dictionary platforms","title":"Attributes"},{"location":"Namespaces/namespacetest__platform/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Namespaces/namespacetest__platform/#function-test_platform","text":"def test_platform( record_property record_property )","title":"function test_platform"},{"location":"Namespaces/namespacetest__platform/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Namespaces/namespacetest__platform/#variable-platforms","text":"dictionary platforms = {}; Updated on 2022-04-30 at 21:32:33 +0000","title":"variable platforms"},{"location":"Namespaces/namespacetest__requirements/","text":"test_requirements Classes Name class test_requirements::TestRequirementsAutowareReferenceSystem Functions Name def generate_test_description (ready_fn ready_fn) Attributes Name dictionary checks dictionary reference_system Functions Documentation function generate_test_description def generate_test_description( ready_fn ready_fn ) Attributes Documentation variable checks dictionary checks = {'topic_exists': False, 'pubs_match': False, 'subs_match': False}; variable reference_system dictionary reference_system = { '/FrontLidarDriver': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/RearLidarDriver': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointCloudMap': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/Visualizer': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/Lanelet2Map': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointsTransformerFront': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointsTransformerRear': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/VoxelGridDownsampler': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointCloudMapLoader': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/EuclideanClusterDetector': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/ObjectCollisionEstimator': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/MPCController': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/ParkingPlanner': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/LanePlanner': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointCloudFusion': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()}, '/NDTLocalizer': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()}, '/VehicleInterface': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/Lanelet2GlobalPlanner': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()}, '/Lanelet2MapLoader': {'pub_count': 1, 'sub_count': 3, 'checks': checks.copy()}, '/BehaviorPlanner': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()} # does not exist as topic but only as a node # '/VehicleDBWSystem': {'pub_count': 0, 'sub_count': 0, 'checks': checks.copy()} }; Updated on 2022-04-30 at 21:32:33 +0000","title":"test_requirements"},{"location":"Namespaces/namespacetest__requirements/#test_requirements","text":"","title":"test_requirements"},{"location":"Namespaces/namespacetest__requirements/#classes","text":"Name class test_requirements::TestRequirementsAutowareReferenceSystem","title":"Classes"},{"location":"Namespaces/namespacetest__requirements/#functions","text":"Name def generate_test_description (ready_fn ready_fn)","title":"Functions"},{"location":"Namespaces/namespacetest__requirements/#attributes","text":"Name dictionary checks dictionary reference_system","title":"Attributes"},{"location":"Namespaces/namespacetest__requirements/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Namespaces/namespacetest__requirements/#function-generate_test_description","text":"def generate_test_description( ready_fn ready_fn )","title":"function generate_test_description"},{"location":"Namespaces/namespacetest__requirements/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Namespaces/namespacetest__requirements/#variable-checks","text":"dictionary checks = {'topic_exists': False, 'pubs_match': False, 'subs_match': False};","title":"variable checks"},{"location":"Namespaces/namespacetest__requirements/#variable-reference_system","text":"dictionary reference_system = { '/FrontLidarDriver': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/RearLidarDriver': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointCloudMap': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/Visualizer': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/Lanelet2Map': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointsTransformerFront': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointsTransformerRear': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/VoxelGridDownsampler': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointCloudMapLoader': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/EuclideanClusterDetector': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/ObjectCollisionEstimator': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/MPCController': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/ParkingPlanner': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/LanePlanner': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/PointCloudFusion': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()}, '/NDTLocalizer': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()}, '/VehicleInterface': {'pub_count': 1, 'sub_count': 1, 'checks': checks.copy()}, '/Lanelet2GlobalPlanner': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()}, '/Lanelet2MapLoader': {'pub_count': 1, 'sub_count': 3, 'checks': checks.copy()}, '/BehaviorPlanner': {'pub_count': 1, 'sub_count': 2, 'checks': checks.copy()} # does not exist as topic but only as a node # '/VehicleDBWSystem': {'pub_count': 0, 'sub_count': 0, 'checks': checks.copy()} }; Updated on 2022-04-30 at 21:32:33 +0000","title":"variable reference_system"},{"location":"Namespaces/namespacetesting/","text":"testing Updated on 2022-04-30 at 21:32:33 +0000","title":"testing"},{"location":"Namespaces/namespacetesting/#testing","text":"Updated on 2022-04-30 at 21:32:33 +0000","title":"testing"},{"location":"Namespaces/namespaceunittest/","text":"unittest Updated on 2022-04-30 at 21:32:33 +0000","title":"unittest"},{"location":"Namespaces/namespaceunittest/#unittest","text":"Updated on 2022-04-30 at 21:32:33 +0000","title":"unittest"},{"location":"Pages/","text":"Pages page Profiling executors using the Autoware reference system page The reference system Updated on 2022-04-30 at 21:32:33 +0000","title":"Pages"},{"location":"Pages/#pages","text":"page Profiling executors using the Autoware reference system page The reference system Updated on 2022-04-30 at 21:32:33 +0000","title":"Pages"},{"location":"Pages/md_autoware_reference_system_README/","text":"Profiling executors using the Autoware reference system Introduction This tutorial incorporates the open-sourced autoware_reference_system and can be used to fairly and repeatably test the performance of the various executors available within the greater ROS 2 community. The example simulates a real world scenario, Autoware.Auto and its LiDAR data pipeline, that can be used to evaluate the performance of the executor. To this end, the example comes with built-in performance measurements that make it easy to compare the performance between executor implementations in a repeatable way. Quick Start Some tools are provided in order to automate and standardize the report generation process for this autoware_reference_system . First, install and build the dependencies (ade) $ python3 -m pip install psrecord bokeh # optional dependency: networkx (ade) $ cd workspace (ade) $ colcon build --packages-up-to autoware_reference_system The easiest way to run the benchmarks is through the ctest interface. Rebuild the package with the RUN_BENCHMARK option and run colcon test : (ade) $ colcon build --packages-select autoware_reference_system \\ --cmake-force-configure --cmake-args -DRUN_BENCHMARK=ON (ade) $ colcon test --packages-select autoware_reference_system After the tests have run, reports can be found as .html files in $ROS_HOME/benchmark_autoware_reference_system/<timestamp> ( $ROS_HOME defaults to ~/.ros ). The symlink $ROS_HOME/benchmark_autoware_reference_system/latest always points to the latest results. Detailed reports to individual test runs can be found in subdirectories of the form <duration>/<middleware>/<executable> . More details on all the supported CMake arguments can be found in the supported CMake argument section below. By default the tests uses the default ROS 2 middleware set for the system. To run the tests for all available RMWs, add the -DALL_RMWS=ON CMake argument to the colcon build step. The test duration can be configured through the RUN_TIMES variable in CMakelists.txt . A separate set of tests is created for each chosen runtime. Test Results and Reports Reports are automatically generated depending on which tests are run. The main test directory ( $ROS_HOME/benchmark_autoware_reference_system/latest by default) contains the summary reports , which aggregate metrics across all tested configurations. Below this main test directory, each tested configuration has a subdirectory of the form <duration>/<middleware>/<executable name> . This directory contains the raw trace data and additional per-test reports in .html format. Tweaking the benchmark setup To get more fine-grained control over the benchmarking process invoke the benchmark script directly. To get a summary of the available options, call (ade) $ $(ros2 pkg prefix --share autoware_reference_system)/scripts/benchmark.py --help As an example, to run all benchmarks starting with autoware_ and the autoware_default_multithreaded benchmark for 15 seconds run (ade) $ $(ros2 pkg prefix --share autoware_reference_system)/scripts/benchmark.py \\ 15 'autoware_*' The --logdir option can be used to store the measurement results and reports in a custom directory, without adding a timestamp. Note that this may overwrite existing measurement results in the same directory. Key Performance Indicators (KPIs) The performance measurement evaluates the executor using the following metrics. In general, the lowest value within each KPI is considered to be the better performance. CPU utilization In general a lower CPU utilization is better since it enables you to choose a smaller CPU or have more functionality on a larger CPU for other things. Memory utilization In general a lower memory utilization is better since it enables you to choose a smaller memory or have more space for other things Number of dropped sensor samples in transform nodes The nodes in the reference system always use the most recent sensor data (i.e., use a history depth of 1) This is a common strategy in real-world settings, as old sensor data is much less valuable than new sensor data For example an image from 30 seconds ago is much less helpful while driving down the road than an image from 0.1 second ago Fusion nodes drop messages during normal operation if the inputs publish with different frequencies In transform nodes, however, dropped messages indicate that the transform node cannot keep up with its input Number of front LiDAR samples that did not trigger an update in the Object Collision Estimator The Front and Rear LiDARs have the same publishing frequency This means Object Collision Estimator should run for every LiDAR sample Count number of executions of Object Collision Estimator and Front LiDAR and report any difference Worst-case Latency between Front LiDAR and the Object Collision Estimator For worst-case latency we want to identify obstacles in time (i.e. early enough that we can still emergency-brake). Average Latency between Front LiDAR and Object Collision Estimator For average latency we want to identify obstacles as soon as possible so we can account for the obstacle in our planning. The Behavior Planner should be as cyclical as possible The desired behavior of the Behavior Planner is to be as cyclical as possible, meaning it should be executed as close to its set frequency of 100ms as possible Measure the jitter and drift over time of the timer callback Message Types A single message type is used for the entire reference system when generating results in order to simplify the setup as well as make it more repeatable and extensible. This means only one message type from the list below is used during any given experimental run for every node in the reference system. Message4kB reference message with a fixed size of 4 kilobytes (kB) Other messages with different fixed sizes could be added here in the future. When reporting results it is important to specify the message type used during the experiment, as the message size impacts the metrics. Autoware Reference System Built from a handful of building-block node types , each one of these nodes are meant to simulate a real-world node from the Autoware.Auto project LiDAR data pipeline. Under each node type are the requirements used for this specific reference system, autoware_reference_system . Future reference systems could have slightly different requirements and still use the same building-block node types. For simplicity, every node except for the command nodes only publishes one topic, and this topic has the same name as the node that publishes it. However, each topic can be subscribed to by multiple different nodes. Also for simplicity, every node that does processing (aka number crunching) by default is configured to do that processing for the same amount of time: roughly 10 milliseconds. This processing time varies drastically depending on what platform you are on since each node does a fixed amount of actual work, not a fixed amount of time. See the Configuring Processing Time section for more details. Message Type all nodes use the same message type during any single test run default message type: Message4kB to be implemented: Message64kB Message256kB Message512kB Message1024kB Message5120kB Sensor Nodes all sensor node have a publishing rate (cycle time) of 100 milliseconds all sensor nodes publish the same message type total of 5 sensor nodes : Front LiDAR Driver Rear LiDAR Driver Point Cloud Map Visualizer Lanelet2Map Transform Nodes all transform nodes have one subscriber and one publisher all transform nodes start processing after a message is received publishes message after processing is complete total of 10 transform nodes: Front Points Transformer Rear Points Transformer Voxel Grid Downsampler Point Cloud Map Loader Ray Ground Filter Object Collision Estimator MPC Controller Parking Planner Lane Planner Fusion Nodes all fusion nodes have two subscribers and one publisher for this reference system all fusion nodes start processing after a message is received from all subscriptions all fusion nodes have a max input time difference between the first input received and last input received before publishing of 9999 seconds publishes message after processing is complete total of 5 fusion nodes: Point Cloud Fusion NDT Localizer Vehicle Interface Lanelet2 Global Planner Lanelet 2 Map Loader Cyclic Nodes for this reference system there is only 1 cyclic node this cyclic node has 6 subscribers and one publisher** this cyclic node starts processing after a message is received from any** single subscription publishes message after processing is complete Command Nodes all command nodes have 1 subscriber and zero publishers all command nodes prints out the final latency statistics after a message is received on the specified topic total of 2 command nodes: VehicleDBWSystem IntersectionOutput Intersection Nodes for this reference system there is only EuclideanClusterDetector this intersection node has 2 subscribers and 2 publishers publishes message after processing is complete on the correspoding publisher Configure Processing Time Many nodes in the reference system are actually performing some pseudo-work by finding prime numbers up until some maximum value. Depending on the platform, this maximum value will need to be changed so that these nodes do not take an absurd amount of time. This maximum value should be chosen on a platform-by-platform basis so that the total run time of this work takes some desired length of time. In order to make finding this maximum value a bit easier across many different platforms a simple number_cruncher_benchmark is provided that will loop over various maximum values and spit out how long each one takes to run. After running this executable on your platform you should have a good idea what maximum value you should use in your timing configuration so that each node does some measurable work for some desired amount of time. Here is an example output of the number_cruncher_benchmark run on a typical development platform (Intel 9i7): ros2 run autoware_reference_system number_cruncher_benchmark maximum_number run time 64 0.001609ms 128 0.002896ms 256 0.006614ms 512 0.035036ms 1024 0.050957ms 2048 0.092732ms 4096 0.22837ms 8192 0.566779ms 16384 1.48837ms 32768 3.64588ms 65536 9.6687ms 131072 24.1154ms 262144 62.3475ms 524288 162.762ms 1048576 429.882ms 2097152 1149.79ms Run the above command on your system, select your desired run_time and place the corresponding maximum_number in the timing configuration file for the desired nodes. Supported CMake Arguments RUN_BENCHMARK Tell CMake to build the benchmark tests that will check the reference system against its requirements before running a sweep of tests to generate trace files and reports Without the RUN_BENCHMARK variable set to ON only the standard linter tests will be run TEST_PLATFORM Test CMake to build the tests to check if the tests are being run from a supported platform or not This flag can be omitted if you would like to run the tests on a development system before running them on a supported platform The platform tests themselves can and should be improved going forward and are only some simple checks today (architecture, number of CPUs, PREEMPT_RT flag, etc.) Set this to ON to check if the current platform is supported SKIP_TRACING Set to ON to skip the ros2_tracing tests, aka the callback tests This can greatly reduce the length of time the colcon test command takes to run ALL_RMWS Set this to ON if you'd like to run tests on all available RMWs as well Otherwise use only default RMW (first one listed by CMake function get_available_rmw_implementations ) Defaults to OFF Generating Node Graph Image To generate the image shown above you can take advantage of a program called graphviz that has a command line interface (CLI) command dot . First, check out the provided .dot file to get an idea of how the dot syntax works (feel free to modify it for your use case or future reference systems ). To generate the .dot file into an .svg image, run the following command: dot -Tsvg autoware_reference_system.dot Note: you can change the generated image type to any of the supported type parameters if you would like a different filetype. Available benchmarks The package comes with a set of benchmark executables. Many of these benchmarks distinguish hotpath nodes from other nodes; these are the nodes involved in the latency KPI, starting with the front/rear LiDAR and ending in the ObjectCollisionEstimator. Within the hotpath nodes, the benchmarks further distinguish between front/rear LiDAR nodes (the LidarDriver and PointsTransformer in front/rear, respectively) and the fusion chain nodes (everything from PointCloudFusion to ObjectCollisionEstimator). Some benchmarks use real-time priorities and affinities. In this case, hotpath nodes run at priority 1 on cores 1-3; the planner nodes runs at priority 30 on core 0; and all other nodes run without real-time priority on all cores. ROS 2 benchmarks autoware_default_singlethreaded : All nodes are assigned to the same single-threaded ROS executor autoware_default_multithreaded : All nodes are assigned to the same multi-threaded ROS executor autoware_default_staticsinglethreaded : Like autoware_default_singlethreaded , but using the StaticSingleThreadedExecutor . autoware_default_prioritized : Separate executors for front LiDAR nodes, rear LiDAR nodes fusion chain nodes, behavior planner, and everything else. Uses real-time priorities. autoware_default_cbg : Like autoware_default_prioritized , but uses the callback-group executor to remove the non-hotpath subscription in EuclideanClusterDetector from the executor for fusion chain nodes. Updated on 2022-04-30 at 21:32:33 +0000","title":"Profiling executors using the Autoware reference system"},{"location":"Pages/md_autoware_reference_system_README/#profiling-executors-using-the-autoware-reference-system","text":"","title":"Profiling executors using the Autoware reference system"},{"location":"Pages/md_autoware_reference_system_README/#introduction","text":"This tutorial incorporates the open-sourced autoware_reference_system and can be used to fairly and repeatably test the performance of the various executors available within the greater ROS 2 community. The example simulates a real world scenario, Autoware.Auto and its LiDAR data pipeline, that can be used to evaluate the performance of the executor. To this end, the example comes with built-in performance measurements that make it easy to compare the performance between executor implementations in a repeatable way.","title":"Introduction"},{"location":"Pages/md_autoware_reference_system_README/#quick-start","text":"Some tools are provided in order to automate and standardize the report generation process for this autoware_reference_system . First, install and build the dependencies (ade) $ python3 -m pip install psrecord bokeh # optional dependency: networkx (ade) $ cd workspace (ade) $ colcon build --packages-up-to autoware_reference_system The easiest way to run the benchmarks is through the ctest interface. Rebuild the package with the RUN_BENCHMARK option and run colcon test : (ade) $ colcon build --packages-select autoware_reference_system \\ --cmake-force-configure --cmake-args -DRUN_BENCHMARK=ON (ade) $ colcon test --packages-select autoware_reference_system After the tests have run, reports can be found as .html files in $ROS_HOME/benchmark_autoware_reference_system/<timestamp> ( $ROS_HOME defaults to ~/.ros ). The symlink $ROS_HOME/benchmark_autoware_reference_system/latest always points to the latest results. Detailed reports to individual test runs can be found in subdirectories of the form <duration>/<middleware>/<executable> . More details on all the supported CMake arguments can be found in the supported CMake argument section below. By default the tests uses the default ROS 2 middleware set for the system. To run the tests for all available RMWs, add the -DALL_RMWS=ON CMake argument to the colcon build step. The test duration can be configured through the RUN_TIMES variable in CMakelists.txt . A separate set of tests is created for each chosen runtime.","title":"Quick Start"},{"location":"Pages/md_autoware_reference_system_README/#test-results-and-reports","text":"Reports are automatically generated depending on which tests are run. The main test directory ( $ROS_HOME/benchmark_autoware_reference_system/latest by default) contains the summary reports , which aggregate metrics across all tested configurations. Below this main test directory, each tested configuration has a subdirectory of the form <duration>/<middleware>/<executable name> . This directory contains the raw trace data and additional per-test reports in .html format.","title":"Test Results and Reports"},{"location":"Pages/md_autoware_reference_system_README/#tweaking-the-benchmark-setup","text":"To get more fine-grained control over the benchmarking process invoke the benchmark script directly. To get a summary of the available options, call (ade) $ $(ros2 pkg prefix --share autoware_reference_system)/scripts/benchmark.py --help As an example, to run all benchmarks starting with autoware_ and the autoware_default_multithreaded benchmark for 15 seconds run (ade) $ $(ros2 pkg prefix --share autoware_reference_system)/scripts/benchmark.py \\ 15 'autoware_*' The --logdir option can be used to store the measurement results and reports in a custom directory, without adding a timestamp. Note that this may overwrite existing measurement results in the same directory.","title":"Tweaking the benchmark setup"},{"location":"Pages/md_autoware_reference_system_README/#key-performance-indicators-kpis","text":"The performance measurement evaluates the executor using the following metrics. In general, the lowest value within each KPI is considered to be the better performance. CPU utilization In general a lower CPU utilization is better since it enables you to choose a smaller CPU or have more functionality on a larger CPU for other things. Memory utilization In general a lower memory utilization is better since it enables you to choose a smaller memory or have more space for other things Number of dropped sensor samples in transform nodes The nodes in the reference system always use the most recent sensor data (i.e., use a history depth of 1) This is a common strategy in real-world settings, as old sensor data is much less valuable than new sensor data For example an image from 30 seconds ago is much less helpful while driving down the road than an image from 0.1 second ago Fusion nodes drop messages during normal operation if the inputs publish with different frequencies In transform nodes, however, dropped messages indicate that the transform node cannot keep up with its input Number of front LiDAR samples that did not trigger an update in the Object Collision Estimator The Front and Rear LiDARs have the same publishing frequency This means Object Collision Estimator should run for every LiDAR sample Count number of executions of Object Collision Estimator and Front LiDAR and report any difference Worst-case Latency between Front LiDAR and the Object Collision Estimator For worst-case latency we want to identify obstacles in time (i.e. early enough that we can still emergency-brake). Average Latency between Front LiDAR and Object Collision Estimator For average latency we want to identify obstacles as soon as possible so we can account for the obstacle in our planning. The Behavior Planner should be as cyclical as possible The desired behavior of the Behavior Planner is to be as cyclical as possible, meaning it should be executed as close to its set frequency of 100ms as possible Measure the jitter and drift over time of the timer callback","title":"Key Performance Indicators (KPIs)"},{"location":"Pages/md_autoware_reference_system_README/#message-types","text":"A single message type is used for the entire reference system when generating results in order to simplify the setup as well as make it more repeatable and extensible. This means only one message type from the list below is used during any given experimental run for every node in the reference system. Message4kB reference message with a fixed size of 4 kilobytes (kB) Other messages with different fixed sizes could be added here in the future. When reporting results it is important to specify the message type used during the experiment, as the message size impacts the metrics.","title":"Message Types"},{"location":"Pages/md_autoware_reference_system_README/#autoware-reference-system","text":"Built from a handful of building-block node types , each one of these nodes are meant to simulate a real-world node from the Autoware.Auto project LiDAR data pipeline. Under each node type are the requirements used for this specific reference system, autoware_reference_system . Future reference systems could have slightly different requirements and still use the same building-block node types. For simplicity, every node except for the command nodes only publishes one topic, and this topic has the same name as the node that publishes it. However, each topic can be subscribed to by multiple different nodes. Also for simplicity, every node that does processing (aka number crunching) by default is configured to do that processing for the same amount of time: roughly 10 milliseconds. This processing time varies drastically depending on what platform you are on since each node does a fixed amount of actual work, not a fixed amount of time. See the Configuring Processing Time section for more details. Message Type all nodes use the same message type during any single test run default message type: Message4kB to be implemented: Message64kB Message256kB Message512kB Message1024kB Message5120kB Sensor Nodes all sensor node have a publishing rate (cycle time) of 100 milliseconds all sensor nodes publish the same message type total of 5 sensor nodes : Front LiDAR Driver Rear LiDAR Driver Point Cloud Map Visualizer Lanelet2Map Transform Nodes all transform nodes have one subscriber and one publisher all transform nodes start processing after a message is received publishes message after processing is complete total of 10 transform nodes: Front Points Transformer Rear Points Transformer Voxel Grid Downsampler Point Cloud Map Loader Ray Ground Filter Object Collision Estimator MPC Controller Parking Planner Lane Planner Fusion Nodes all fusion nodes have two subscribers and one publisher for this reference system all fusion nodes start processing after a message is received from all subscriptions all fusion nodes have a max input time difference between the first input received and last input received before publishing of 9999 seconds publishes message after processing is complete total of 5 fusion nodes: Point Cloud Fusion NDT Localizer Vehicle Interface Lanelet2 Global Planner Lanelet 2 Map Loader Cyclic Nodes for this reference system there is only 1 cyclic node this cyclic node has 6 subscribers and one publisher** this cyclic node starts processing after a message is received from any** single subscription publishes message after processing is complete Command Nodes all command nodes have 1 subscriber and zero publishers all command nodes prints out the final latency statistics after a message is received on the specified topic total of 2 command nodes: VehicleDBWSystem IntersectionOutput Intersection Nodes for this reference system there is only EuclideanClusterDetector this intersection node has 2 subscribers and 2 publishers publishes message after processing is complete on the correspoding publisher","title":"Autoware Reference System"},{"location":"Pages/md_autoware_reference_system_README/#configure-processing-time","text":"Many nodes in the reference system are actually performing some pseudo-work by finding prime numbers up until some maximum value. Depending on the platform, this maximum value will need to be changed so that these nodes do not take an absurd amount of time. This maximum value should be chosen on a platform-by-platform basis so that the total run time of this work takes some desired length of time. In order to make finding this maximum value a bit easier across many different platforms a simple number_cruncher_benchmark is provided that will loop over various maximum values and spit out how long each one takes to run. After running this executable on your platform you should have a good idea what maximum value you should use in your timing configuration so that each node does some measurable work for some desired amount of time. Here is an example output of the number_cruncher_benchmark run on a typical development platform (Intel 9i7): ros2 run autoware_reference_system number_cruncher_benchmark maximum_number run time 64 0.001609ms 128 0.002896ms 256 0.006614ms 512 0.035036ms 1024 0.050957ms 2048 0.092732ms 4096 0.22837ms 8192 0.566779ms 16384 1.48837ms 32768 3.64588ms 65536 9.6687ms 131072 24.1154ms 262144 62.3475ms 524288 162.762ms 1048576 429.882ms 2097152 1149.79ms Run the above command on your system, select your desired run_time and place the corresponding maximum_number in the timing configuration file for the desired nodes.","title":"Configure Processing Time"},{"location":"Pages/md_autoware_reference_system_README/#supported-cmake-arguments","text":"RUN_BENCHMARK Tell CMake to build the benchmark tests that will check the reference system against its requirements before running a sweep of tests to generate trace files and reports Without the RUN_BENCHMARK variable set to ON only the standard linter tests will be run TEST_PLATFORM Test CMake to build the tests to check if the tests are being run from a supported platform or not This flag can be omitted if you would like to run the tests on a development system before running them on a supported platform The platform tests themselves can and should be improved going forward and are only some simple checks today (architecture, number of CPUs, PREEMPT_RT flag, etc.) Set this to ON to check if the current platform is supported SKIP_TRACING Set to ON to skip the ros2_tracing tests, aka the callback tests This can greatly reduce the length of time the colcon test command takes to run ALL_RMWS Set this to ON if you'd like to run tests on all available RMWs as well Otherwise use only default RMW (first one listed by CMake function get_available_rmw_implementations ) Defaults to OFF","title":"Supported CMake Arguments"},{"location":"Pages/md_autoware_reference_system_README/#generating-node-graph-image","text":"To generate the image shown above you can take advantage of a program called graphviz that has a command line interface (CLI) command dot . First, check out the provided .dot file to get an idea of how the dot syntax works (feel free to modify it for your use case or future reference systems ). To generate the .dot file into an .svg image, run the following command: dot -Tsvg autoware_reference_system.dot Note: you can change the generated image type to any of the supported type parameters if you would like a different filetype.","title":"Generating Node Graph Image"},{"location":"Pages/md_autoware_reference_system_README/#available-benchmarks","text":"The package comes with a set of benchmark executables. Many of these benchmarks distinguish hotpath nodes from other nodes; these are the nodes involved in the latency KPI, starting with the front/rear LiDAR and ending in the ObjectCollisionEstimator. Within the hotpath nodes, the benchmarks further distinguish between front/rear LiDAR nodes (the LidarDriver and PointsTransformer in front/rear, respectively) and the fusion chain nodes (everything from PointCloudFusion to ObjectCollisionEstimator). Some benchmarks use real-time priorities and affinities. In this case, hotpath nodes run at priority 1 on cores 1-3; the planner nodes runs at priority 30 on core 0; and all other nodes run without real-time priority on all cores.","title":"Available benchmarks"},{"location":"Pages/md_autoware_reference_system_README/#ros-2-benchmarks","text":"autoware_default_singlethreaded : All nodes are assigned to the same single-threaded ROS executor autoware_default_multithreaded : All nodes are assigned to the same multi-threaded ROS executor autoware_default_staticsinglethreaded : Like autoware_default_singlethreaded , but using the StaticSingleThreadedExecutor . autoware_default_prioritized : Separate executors for front LiDAR nodes, rear LiDAR nodes fusion chain nodes, behavior planner, and everything else. Uses real-time priorities. autoware_default_cbg : Like autoware_default_prioritized , but uses the callback-group executor to remove the non-hotpath subscription in EuclideanClusterDetector from the executor for fusion chain nodes. Updated on 2022-04-30 at 21:32:33 +0000","title":"ROS 2 benchmarks"},{"location":"Pages/md_reference_system_README/","text":"The reference system With the distributed development of ROS across many different organizations it is sometimes hard to benchmark and concretely show how a certain change to a certain system improves or reduces the performance of that system. For example did a change from one executor to another actually reduce the CPU or was it something else entirely? The reference_system package was developed to provide the fundamental building blocks to create complex systems that then can be used to evaluate features or performance in a standardized and repeatable way. The first project to use this reference_system is the autoware_reference_system . Future reference systems could be proposed that are more complex using the same basic node building blocks within the reference_system package. Defining a reference system A reference system is defined by: A platform is defined by: Hardware (e.g. an off-the-shelf single-board computer, embedded ECU, etc.) if there are multiple configurations available for such hardware, ensure it is specified Operating System (OS) like RT Linux, QNX, etc. along with any special configurations made for simplicity and ease of benchmarking, all nodes must run on a single process a fixed number of nodes each node with: a fixed number of publishers and subscribers a fixed processing time or a fixed publishing rate a fixed message type of fixed size to be used for every node With these defined attributes the reference system can be replicated across many different possible configurations to be used to benchmark each configuration against the other in a reliable and fair manner. With this approach portable and repeatable tests can also be defined to reliably confirm if a given reference system meets the requirements. Supported Platforms To enable as many people as possible to replicate this reference system, the platform(s) were chosen to be easily accessible (inexpensive, high volume), have lots of documentation, large community use and will be supported well into the future. Platforms were not chosen for performance of the reference system - we know we could run \u201cfaster\u201d with a more powerful CPU or GPU but then it would be harder for others to validate findings and test their own configurations. Accessibility is the key here and will be considered if more platforms want to be added to this benchmark list. Platforms: Raspberry Pi 4B : 4 GB RAM version is the assumed default other versions could also be tested / added by the community real-time Linux kernel Note: create an issue __to add more platforms to the list, keeping in mind the above criteria !!! warning Each reference system can be run on other targets as well however the results will change drastically depending on the specifications of the target hardware. Base node types Most real-world systems can be boiled down to only a handful of base node \"types\" that are then repeated to make the real-world system. This does not cover all possible node types, however it allows for numerous complicated systems to be developed using the same base building blocks. Sensor Node input node to system one publisher, zero subscribers publishes message cyclically at some fixed frequency Transform Node one subscriber, one publisher starts processing for N milliseconds after a message is received publishes message after processing is complete Fusion Node 2 subscribers, one publisher starts processing for N milliseconds after a message is received from all subscriptions publishes message after processing is complete Cyclic Node N subscribers, one publisher cyclically processes all received messages since the last cycle for N milliseconds publishes message after processing is complete Command Node prints output stats everytime a message is received Intersection Node behaves like N transform nodes N subscribers, N publisher bundled together in one-to-one connections starts processing on connection where sample was received publishes message after processing is complete These basic building-block nodes can be mixed-and-matched to create quite complex systems that replicate real-world scenarios to benchmark different configurations against each other. New base node types can be added if necessary. Implemented reference systems The first reference system benchmark proposed is based on the Autoware.Auto LiDAR data pipeline as stated above and shown in the node graph image above as well. Autoware Reference System ROS2 Executors Single Threaded Static Single Threaded Multithreaded Callback Group Prioritized Results below show various characteristics of the same simulated system (Autoware.Auto). Testing and Dependencies Common benchmarking scripts are provided within the reference_system/reference_system_py directory which is a python module itself. The methods and tools provided there can assist with running standardized benchmarking tests and with generating reports as well. See the autoware_reference_system for an example Unit and integration tests have also been written for the reference_system and can be found within the test directory . If a new system type is to be added, new unit and integration tests should also be added as well. Setup Raspberry Pi 4 for the test The goal is to provide a clean computation environment for the test avoiding an interference of other Ubuntu components. Setup a constant CPU frequency Frequency is setup to 1.50 GHz for all CPUs # run it as root sudo su echo -n \"setup constant CPU frequency to 1.50 GHz ... \" # disable ondemand governor systemctl disable ondemand # set performance governor for all cpus echo performance | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor >/dev/null # set constant frequency echo 1500000 | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_min_freq >/dev/null echo 1500000 | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_max_freq >/dev/null # reset frequency counters echo 1 | tee /sys/devices/system/cpu/cpu*/cpufreq/stats/reset >/dev/null echo done sleep 1 # get freq info echo `cpufreq-info | grep stats | cut -d ' ' -f 23-25` Isolate CPUs CPU 2,3 are isolated to run tests. sudo apt install -y sysstat u-boot-tools # modify kernel cmdline cd ~ dd if=/boot/firmware/boot.scr of=boot.script bs=72 skip=1 # edit boot.script and modify bootargs to ubuntu@ubuntu:~$ cat boot.script | grep \"setenv bootargs\" | head -1 setenv bootargs \" ${bootargs} rcu_nocbs=2,3 nohz_full=2,3 isolcpus=2,3 irqaffinity=0,1 audit=0 watchdog=0 skew_tick=1 quiet splash\" # generate boot.scr mkimage -A arm64 -O linux -T script -C none -d boot.script boot.scr # replace boot.scr sudo cp boot.scr /boot/firmware/boot.scr sudo reboot # check cmdline ubuntu@ubuntu:~$ cat /proc/cmdline coherent_pool=1M 8250.nr_uarts=1 snd_bcm2835.enable_compat_alsa=0 snd_bcm2835.enable_hdmi=1 bcm2708_fb.fbwidth=0 bcm2708_fb.fbheight=0 bcm2708_fb.fbswap=1 smsc95xx.macaddr=DC:A6:32:2E:5 4:97 vc_mem.mem_base=0x3ec00000 vc_mem.mem_size=0x40000000 net.ifnames=0 dwc_otg.lpm_enable=0 console=ttyS0,115200 console=tty1 root=LABEL=writable rootfstype=ext4 elevator=deadline roo twait fixrtc rcu_nocbs=2,3 nohz_full=2,3 isolcpus=2,3 irqaffinity=0,1 audit=0 watchdog=0 skew_tick=1 quiet splash # check interrupts # Only the number of interrupts handled by CPU 0,1 increases. watch -n1 cat /proc/interrupts # check soft interrupts watch -n1 cat /proc/softirqs # check isolated CPUs cat /sys/devices/system/cpu/isolated 2-3 cat /sys/devices/system/cpu/present 0-3 # run reference system on CPU2 taskset -c 2 install/autoware_reference_system/lib/autoware_reference_system/autoware_default_singlethreaded > /dev/null # get pid RF_PID=`pidof autoware_default_singlethreaded` && cat /proc/$RF_PID/status | grep ^Cpu # check how many threads are running ps -aL | grep $RF_PID 3835 3835 ttyS0 00:03:46 autoware_defaul 3835 3836 ttyS0 00:00:00 autoware_defaul 3835 3837 ttyS0 00:00:00 autoware_defaul 3835 3838 ttyS0 00:00:00 autoware_defaul 3835 3839 ttyS0 00:00:00 gc 3835 3840 ttyS0 00:00:00 dq.builtins 3835 3841 ttyS0 00:00:00 dq.user 3835 3842 ttyS0 00:00:00 tev 3835 3843 ttyS0 00:00:00 recv 3835 3844 ttyS0 00:00:00 recvMC 3835 3845 ttyS0 00:00:00 recvUC 3835 3846 ttyS0 00:00:00 autoware_defaul Hints If you run colcon build on a Raspberry Pi 4 with little memory, use export MAKEFLAGS=\"-j 1\" to inhibit parallelism. Otherwise, the system could hang due to memory swapping. Updated on 2022-04-30 at 21:32:33 +0000","title":"The reference system"},{"location":"Pages/md_reference_system_README/#the-reference-system","text":"With the distributed development of ROS across many different organizations it is sometimes hard to benchmark and concretely show how a certain change to a certain system improves or reduces the performance of that system. For example did a change from one executor to another actually reduce the CPU or was it something else entirely? The reference_system package was developed to provide the fundamental building blocks to create complex systems that then can be used to evaluate features or performance in a standardized and repeatable way. The first project to use this reference_system is the autoware_reference_system . Future reference systems could be proposed that are more complex using the same basic node building blocks within the reference_system package.","title":"The reference system"},{"location":"Pages/md_reference_system_README/#defining-a-reference-system","text":"A reference system is defined by: A platform is defined by: Hardware (e.g. an off-the-shelf single-board computer, embedded ECU, etc.) if there are multiple configurations available for such hardware, ensure it is specified Operating System (OS) like RT Linux, QNX, etc. along with any special configurations made for simplicity and ease of benchmarking, all nodes must run on a single process a fixed number of nodes each node with: a fixed number of publishers and subscribers a fixed processing time or a fixed publishing rate a fixed message type of fixed size to be used for every node With these defined attributes the reference system can be replicated across many different possible configurations to be used to benchmark each configuration against the other in a reliable and fair manner. With this approach portable and repeatable tests can also be defined to reliably confirm if a given reference system meets the requirements.","title":"Defining a reference system"},{"location":"Pages/md_reference_system_README/#supported-platforms","text":"To enable as many people as possible to replicate this reference system, the platform(s) were chosen to be easily accessible (inexpensive, high volume), have lots of documentation, large community use and will be supported well into the future. Platforms were not chosen for performance of the reference system - we know we could run \u201cfaster\u201d with a more powerful CPU or GPU but then it would be harder for others to validate findings and test their own configurations. Accessibility is the key here and will be considered if more platforms want to be added to this benchmark list. Platforms: Raspberry Pi 4B : 4 GB RAM version is the assumed default other versions could also be tested / added by the community real-time Linux kernel Note: create an issue __to add more platforms to the list, keeping in mind the above criteria !!! warning Each reference system can be run on other targets as well however the results will change drastically depending on the specifications of the target hardware.","title":"Supported Platforms"},{"location":"Pages/md_reference_system_README/#base-node-types","text":"Most real-world systems can be boiled down to only a handful of base node \"types\" that are then repeated to make the real-world system. This does not cover all possible node types, however it allows for numerous complicated systems to be developed using the same base building blocks. Sensor Node input node to system one publisher, zero subscribers publishes message cyclically at some fixed frequency Transform Node one subscriber, one publisher starts processing for N milliseconds after a message is received publishes message after processing is complete Fusion Node 2 subscribers, one publisher starts processing for N milliseconds after a message is received from all subscriptions publishes message after processing is complete Cyclic Node N subscribers, one publisher cyclically processes all received messages since the last cycle for N milliseconds publishes message after processing is complete Command Node prints output stats everytime a message is received Intersection Node behaves like N transform nodes N subscribers, N publisher bundled together in one-to-one connections starts processing on connection where sample was received publishes message after processing is complete These basic building-block nodes can be mixed-and-matched to create quite complex systems that replicate real-world scenarios to benchmark different configurations against each other. New base node types can be added if necessary.","title":"Base node types"},{"location":"Pages/md_reference_system_README/#implemented-reference-systems","text":"The first reference system benchmark proposed is based on the Autoware.Auto LiDAR data pipeline as stated above and shown in the node graph image above as well. Autoware Reference System ROS2 Executors Single Threaded Static Single Threaded Multithreaded Callback Group Prioritized Results below show various characteristics of the same simulated system (Autoware.Auto).","title":"Implemented reference systems"},{"location":"Pages/md_reference_system_README/#testing-and-dependencies","text":"Common benchmarking scripts are provided within the reference_system/reference_system_py directory which is a python module itself. The methods and tools provided there can assist with running standardized benchmarking tests and with generating reports as well. See the autoware_reference_system for an example Unit and integration tests have also been written for the reference_system and can be found within the test directory . If a new system type is to be added, new unit and integration tests should also be added as well.","title":"Testing and Dependencies"},{"location":"Pages/md_reference_system_README/#setup-raspberry-pi-4-for-the-test","text":"The goal is to provide a clean computation environment for the test avoiding an interference of other Ubuntu components.","title":"Setup Raspberry Pi 4 for the test"},{"location":"Pages/md_reference_system_README/#setup-a-constant-cpu-frequency","text":"Frequency is setup to 1.50 GHz for all CPUs # run it as root sudo su echo -n \"setup constant CPU frequency to 1.50 GHz ... \" # disable ondemand governor systemctl disable ondemand # set performance governor for all cpus echo performance | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor >/dev/null # set constant frequency echo 1500000 | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_min_freq >/dev/null echo 1500000 | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_max_freq >/dev/null # reset frequency counters echo 1 | tee /sys/devices/system/cpu/cpu*/cpufreq/stats/reset >/dev/null echo done sleep 1 # get freq info echo `cpufreq-info | grep stats | cut -d ' ' -f 23-25`","title":"Setup a constant CPU frequency"},{"location":"Pages/md_reference_system_README/#isolate-cpus","text":"CPU 2,3 are isolated to run tests. sudo apt install -y sysstat u-boot-tools # modify kernel cmdline cd ~ dd if=/boot/firmware/boot.scr of=boot.script bs=72 skip=1 # edit boot.script and modify bootargs to ubuntu@ubuntu:~$ cat boot.script | grep \"setenv bootargs\" | head -1 setenv bootargs \" ${bootargs} rcu_nocbs=2,3 nohz_full=2,3 isolcpus=2,3 irqaffinity=0,1 audit=0 watchdog=0 skew_tick=1 quiet splash\" # generate boot.scr mkimage -A arm64 -O linux -T script -C none -d boot.script boot.scr # replace boot.scr sudo cp boot.scr /boot/firmware/boot.scr sudo reboot # check cmdline ubuntu@ubuntu:~$ cat /proc/cmdline coherent_pool=1M 8250.nr_uarts=1 snd_bcm2835.enable_compat_alsa=0 snd_bcm2835.enable_hdmi=1 bcm2708_fb.fbwidth=0 bcm2708_fb.fbheight=0 bcm2708_fb.fbswap=1 smsc95xx.macaddr=DC:A6:32:2E:5 4:97 vc_mem.mem_base=0x3ec00000 vc_mem.mem_size=0x40000000 net.ifnames=0 dwc_otg.lpm_enable=0 console=ttyS0,115200 console=tty1 root=LABEL=writable rootfstype=ext4 elevator=deadline roo twait fixrtc rcu_nocbs=2,3 nohz_full=2,3 isolcpus=2,3 irqaffinity=0,1 audit=0 watchdog=0 skew_tick=1 quiet splash # check interrupts # Only the number of interrupts handled by CPU 0,1 increases. watch -n1 cat /proc/interrupts # check soft interrupts watch -n1 cat /proc/softirqs # check isolated CPUs cat /sys/devices/system/cpu/isolated 2-3 cat /sys/devices/system/cpu/present 0-3 # run reference system on CPU2 taskset -c 2 install/autoware_reference_system/lib/autoware_reference_system/autoware_default_singlethreaded > /dev/null # get pid RF_PID=`pidof autoware_default_singlethreaded` && cat /proc/$RF_PID/status | grep ^Cpu # check how many threads are running ps -aL | grep $RF_PID 3835 3835 ttyS0 00:03:46 autoware_defaul 3835 3836 ttyS0 00:00:00 autoware_defaul 3835 3837 ttyS0 00:00:00 autoware_defaul 3835 3838 ttyS0 00:00:00 autoware_defaul 3835 3839 ttyS0 00:00:00 gc 3835 3840 ttyS0 00:00:00 dq.builtins 3835 3841 ttyS0 00:00:00 dq.user 3835 3842 ttyS0 00:00:00 tev 3835 3843 ttyS0 00:00:00 recv 3835 3844 ttyS0 00:00:00 recvMC 3835 3845 ttyS0 00:00:00 recvUC 3835 3846 ttyS0 00:00:00 autoware_defaul","title":"Isolate CPUs"},{"location":"Pages/md_reference_system_README/#hints","text":"If you run colcon build on a Raspberry Pi 4 with little memory, use export MAKEFLAGS=\"-j 1\" to inhibit parallelism. Otherwise, the system could hang due to memory swapping. Updated on 2022-04-30 at 21:32:33 +0000","title":"Hints"}]}